{"meta":{"title":"Supertramp","subtitle":"You are being watched.","description":"You're being watched.","author":"supertramp","url":"https://supertramp7.github.io","root":"/"},"pages":[{"title":"CATEGORIES","date":"2022-02-19T08:24:58.000Z","updated":"2022-03-01T13:10:35.284Z","comments":true,"path":"categories/index.html","permalink":"https://supertramp7.github.io/categories/index.html","excerpt":"","text":""},{"title":"TAGS","date":"2022-02-19T08:21:52.000Z","updated":"2022-02-19T08:23:21.829Z","comments":true,"path":"tags/index.html","permalink":"https://supertramp7.github.io/tags/index.html","excerpt":"","text":""},{"title":"MOOD","date":"2022-02-28T10:34:06.000Z","updated":"2022-03-01T13:35:22.354Z","comments":true,"path":"daily/mood/index.html","permalink":"https://supertramp7.github.io/daily/mood/index.html","excerpt":"","text":"As I Began To Love Myself Charlie Chaplin"},{"title":"STUDY","date":"2022-02-28T10:34:18.000Z","updated":"2022-03-01T12:38:08.380Z","comments":true,"path":"daily/study/index.html","permalink":"https://supertramp7.github.io/daily/study/index.html","excerpt":"","text":""},{"title":"As I Began To Love Myself","date":"2022-03-01T13:25:03.000Z","updated":"2022-03-01T17:17:15.027Z","comments":true,"path":"daily/mood/mood220301/index.html","permalink":"https://supertramp7.github.io/daily/mood/mood220301/index.html","excerpt":"","text":"var ap = new APlayer({ element: document.getElementById(\"aplayer-WYYyaWrI\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"As I Began To Love Myself\", author: \"Charlie Chaplin\", url: \"/assets/mood-musics/As I Began To Love Myself.mp3\", pic: \"/assets/mood-covers/ban220301.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); span.content { display: block; margin: 10px auto; text-align: center; } p { color: #1C6C95; font-size: 16px; font-style: italic; font-weight: bold; line-height: 40px; } h2{ color: #1C6C95; text-decoration: underline; font-style: italic; } As I began to love myself I found that anguish and emotional suffering are only warning signs that I was living against my own truth Today, I know, this is“AUTHENTICITY” 当我真正开始爱自己， 我发觉烦闷和痛苦，不过是警示我，我过去曾违心而活。 今天，我明白了，这便是“真实”。 As I began to love myself I understood how much it can offend somebody as I try to force my desires on this person even though I knew the time was not right and the person was not ready for it and even though this person was me Today I call it “RESPECT” 当我真正开始爱自己， 我才发现以一己私欲强人所难，是何等冒犯， 即使我知道，时候未到，人也会未有准备， 即便那人是我自己。 今天，我称之为“尊重”。 As I began to love myself I stopped craving for a different life and I could see that everything that surrounded me was inviting me to grow Today I call it “MATURITY” 当我真正开始爱自己， 我不再渴求别样的生活， 目光所及，周遭的一切都在促使我成长。 今天，我称之为“成熟”。 As I began to love myself I understood that at any circumstance I am in the right place at the right time and everything happens at the exactly right moment so I could be calm Today I call it “SELF-CONFIDENCE” 当我真正开始爱我自己， 我明白了在任何情况下， 我都出现在对的地点，对的时间； 世事皆注定， 而我也得以从容不迫。 今天，我称之为“自信”。 As I began to love myself I quit stealing my own time and I stopped designing huge projects for the future Today I only do what brings me joy and happiness things I love to do and that make my heart cheer and I do them in my own way and in my own rhythm Today I call it “HONESTY” 当我真正开始爱自己， 我不再匆匆忙忙， 也不再计划未来的壮举。 如今，我只行快乐之事，只行热爱之事， 只行欢心之事——以我自己的方式，自己的节奏。 今天，我称之为“诚实”。 As I began to love myself I freed myself of anything that is no good for my health food, people, things, situations and everything that drew me down and away from myself At first I called this attitude a healthy egoism Today I know it is “LOVE OF ONESELF” 当我真正开始爱自己， 我让自己远离一切有损健康之事 食物，人群，事物，处境， 或者一切让我心神疲惫，背离初心之事。 起初，我称这样的态度为“健康的利己”。 而今天，我称之为“关爱自我”。 As I began to love myself I quit trying to always be right and ever since I was wrong less of the time Today I discovered that is “MODESTY” 当我真正开始爱自己， 我不再试图永不犯错， 而从此，我犯的错却更少了。 今天，我发觉，这便是“谦逊”。 As I began to love myself I refused to go on living in the past and worry about the future Now I only live for the moment where EVERYTHING is happening Today I live each day, day by day and I call it “PERFECTION” 当我真正开始爱自己， 我拒绝担忧过去和未来， 此刻，我只活在当下， 见证当下发生的一切。 如今我专注每一天， 我称之为“尽善”。 As I began to love myself I recognized that my mind can disturb me and it can make me sick But as I connected it to my heart my mind became a valuable ally Today I call this connection “WISDOM OF THE HEART” 当我真正开始爱自己， 我意识到，思绪或许会让我饱受煎熬。 但当连接心灵之时， 我的思绪便成了宝贵的盟友。 如今，我称这个连接为“心灵的智慧”。 We no longer need to fear arguments confrontations or any kind of problems with ourselves or others Even stars collide and out of their crashing new world are born Today I know, That is LIFE 我们无须再惧怕纷争， 对抗，自身或他人的任何问题。 纵使星星也会相撞， 由此诞生出新的世界。 今天我知道了，这便是人生！ &lt;BACK&nbsp;"}],"posts":[{"title":"积\t累","slug":"accumulate","date":"2022-04-25T02:20:55.000Z","updated":"2022-04-25T03:02:22.879Z","comments":true,"path":"accumulate/","link":"","permalink":"https://supertramp7.github.io/accumulate/","excerpt":"","text":"JavaBean规范（1）JavaBean 类必须是一个公共类，并将其访问属性设置为 public ，如： public class user{ …}（2）JavaBean 类必须有一个空的构造函数：类中必须有一个不带参数的公用构造器，例如：public User() {…} （3）一个javaBean类不应有公共实例变量，类变量都为private ，如： private int id; ( 4 )javaBean属性是具有getter/setter方法的成员变量。也可以只提供getter方法，这样的属性叫只读属性；也可以只提供setter方法，这样的属性叫只写属性； 如果属性类型为boolean类型，那么读方法的格式可以是get或is。例如名为abc的boolean类型的属性，它的读方法可以是getAbc()，也可以是isAbc()； 一般JavaBean属性以小写字母开头，驼峰命名格式，相应的 getter/setter 方法是 get/set 接上首字母大写的属性名。例如：属性名为userName，其对应的getter/setter 方法是 getUserName/setUserName。 但是，还有一些特殊情况： 1、如果属性名的第二个字母大写，那么该属性名直接用作 getter/setter 方法中 get/set 的后部分，就是说大小写不变。例如属性名为uName，方法是getuName/setuName。 2、如果前两个字母是大写（一般的专有名词和缩略词都会大写），也是属性名直接用作 getter/setter 方法中 get/set 的后部分。例如属性名为URL，方法是getURL/setURL。 3、如果首字母大写，也是属性名直接用作 getter/setter 方法中 get/set 的后部分。例如属性名为Name，方法是getName/setName，这种是最糟糕的情况，会找不到属性出错，因为默认的属性名是name。 所以在JavaBean命名时应该注意符合以上命名规范。 Java项目中 实体类（ENTITY，VO，DTO）ENTITYEntity（PO）每个属性基本上都对应数据库表里面的某个字段。完全是一个符合Java Bean规范的纯Java对象，没有增加别的属性和方法。持久对象是由insert数据库创建，由数据库delete删除的。基本上持久对象生命周期和数据库密切相关。 VO这个有两种理解，在我接触的项目中更加偏向 第二种 表现层对象(View Object) VO：值对象(Value Object)，通常用于业务层之间的数据传递，和Entity一样也是仅仅包含数据而已。但应是抽象出的业务对象，可以和表对应，也可以不，这根据业务的需要。 VO：表现层对象(View Object)，主要对应展示界面显示的数据对象，用一个VO对象来封装整个界面展示所需要的对象数据。 DTODTO：数据传输对象(Data Transfer Object)，是一种设计模式之间传输数据的软件应用系统。数据传输目标往往是数据访问对象从数据库中检索数据。数据传输对象与数据交互对象或数据访问对象之间的差异是一个以不具有任何行为除了存储和检索的数据（访问和存取器）。简单来说，当我们需要一个对象10个字段的内容，但这个对象总共有20个字段，我们不需要把整个PO对象全部字段传输到客户端，而是可以用DTO重新封装，传递到客户端。此时，如果这个对象用来对应界面的展现，就叫VO。说白了，就是对Entity 的一个映射，减少数据的请求之类的数据字段的个数。 持久对象的生命周期（瞬时态、持久态、脱管态）在Hibernate中，持久化对象在操作过程中可以分为三个时期，这三个时期是与Session的周期相关的，因为Hibernate中的操作都是基于Session完成的。所以Session对象的生命周期也关系着持久化对象的生命周期。持久化对象的三种生命周期分别是瞬时态（Transient）、持久态（Persistent）和脱管态（Detached）。 瞬时态 瞬时态的对象是刚刚用new关键字创建出来的，还没有进入Session管理，此时的对象没有和数据库中的记录对应，从未与任何持久化上下文关联过，没有持久化标识（相当于没有主键值） 示例代码如下： 1234user.setName(&quot;JJ&quot;);user.setCity(&quot;广州&quot;);session.save(user);//持久化tx.commit(); 此时user就是处于瞬时态的持久化对象。 瞬时态的特征如下： 1）在数据库中没有与之匹配的数据。 2）没有纳入Session的管理。 持久态 通过Session的save（）、persist（）或者saveOrUpdate（）方法保存处于瞬时态的对象 后，该对象就变为持久态，此时Session中已存在该对象，并且对应数据库中的一条记录。 示例代码如下： 12345678SessionFactory sessionFactory=config.buildSessionfactory();Session session =sessionFactory.getCurrentSession();Transaction tx=session.beginTransaction();User user =new User();user.setName(&quot;JJ&quot;);user.setCity(&quot;广州&quot;);session.save(user);//持久化tx.commit(); 在调用save（）方法后，持久化对象user就变为持久态，但是执行了commit（）方法之后，数据库操作才会执行。Session对象的get（）和load（）方法也可以返回一个持久态的对象，这个对象代表数据库中的一条记录。 持久态的特征如下： 1）对象在数据库中有与之对应的数据 2）纳入了Session的管理 3）在清理缓存（脏数据检查）的时候，会和数据库同步。即在Session对象失效之前， 对持久态对象的任何修改，在调用Session对象的close（）或Transaction对象的commit（）方法后，数据库表中对应的数据会同时更新。 脱管态 脱管态，是离开Session管理的状态。处于脱管态的持久化对象的标识符属性和数据库表中某条记录的主键相对应，但他脱离了Session的管理，再次对其操作时，Hibernate无法感知其变化。 示例代码如下： 123456789SessionFactory sessionFactory=config.buildSessionfactory();Session session =sessionFactory.getCurrentSession();Transaction tx=session.beginTransaction();User user =new User();user.setName(&quot;JJ&quot;);user.setCity(&quot;广州&quot;);session.save(user);tx.commit();user.setCity(&quot;汕头&quot;); 虽然后来又修改了user对象的city属性，但是在脱管态修改的，程序结束也不能在影响数据库中数据的变化。处于脱管态的对象可以重新调用Session对象的update（）方法回到持久态，否则Java虚拟机会在适当的时机进行垃圾回收。 重新回到持久态的实例代码如下： 12345678910111213SessionFactory sessionFactory=config.buildSessionfactory();Session session =sessionFactory.getCurrentSession();Transaction tx=session.beginTransaction();User user =new User();user.setName(&quot;JJ&quot;);user.setCity(&quot;广州&quot;);session.save(user);tx.commit();user.setCity(&quot;汕头&quot;);session=sessionFactory.getCurrentSession();tx=session.beginTransaction();session.update(user)//重新持久化tx.commit(); 脱管态的特征如下： 1）在数据库中有与之匹配的数据 2）没有纳入Session的管理","categories":[{"name":"java","slug":"java","permalink":"https://supertramp7.github.io/categories/java/"}],"tags":[{"name":"-java -javabean -vo -hibernate","slug":"java-javabean-vo-hibernate","permalink":"https://supertramp7.github.io/tags/java-javabean-vo-hibernate/"}]},{"title":"ssh整合","slug":"ssh","date":"2022-03-17T11:38:50.000Z","updated":"2022-04-08T07:18:04.314Z","comments":true,"path":"ssh/","link":"","permalink":"https://supertramp7.github.io/ssh/","excerpt":"","text":"回顾SSH框架知识点Hibernate框架1 hibernate核心配置文件 0）orm思想 对象关系映射 1）数据库信息 2）hibernate信息 3）映射配置 4）hibernate核心配置文件 如果单纯使用hibernate框架，核心配置文件名称 hibernate.cfg.xml和位置 src下面 固定的 hibernate和spring整合时候，hibernate核心配置文件名称和位置没有固定要求的 2 hibernate映射配置文件 1）实体类和数据库表映射关系—使用orm思想 3 hibernate操作的步骤 1）在spring框架对hibernate框架进行封装，使用hibernateTemplate Struts2框架1 Action操作 1）action创建三种方式 继承类 ActionSupport 2）配置action访问路径 创建struts.xml配置文件，这个文件名称和位置固定 src下面的 3）配置访问action的多个方法 使用通配符方式配置 4）在action获取表单提交数据 获取request对象 使用ServletActionContext类获取 属性封装 模型驱动（重点） 表达式封装 5）在action操作域对象 使用ServletActionContext获取域对象 6）配置struts2的过滤器 2 值栈 1）向值栈放数据 set方法 push方法 定义变量，生成get方法 2）从值栈获在jsp中使用struts2标签+ognl获取 &lt;s:propert&gt; &lt;s:iterator&gt; 3 拦截器 1）aop和责任链模式 2）自定义拦截器 继承MethodFilterInterceptor 重写类里面的方法 配置拦截器和action关联 Spring框架1 spring核心配置文件 1）名称和位置没有固定要求 2）在spring核心配置文件中引入schema约束 2 创建对象 1）xml配置方式： 2）注解方式：四个注解 3 注入属性(对象类型属性) 1）xml配置方式： 2）注解方式：两个注解 autowired resource 4 使用ServletContext对象和监听器实现 1）在服务器启动时候，加载spring配置文件，创建对象 2）配置spring的监听器 3）指定spring配置文件位置 5 jdbcTemplate 6 spring事务配置 1）xml方式 2）注解方式 SSH框架整合思想 1 三大框架应用在javaee三层结构 2 struts2框架和spring整合 1）struts2的action在spring配置 3 spring框架和hibernate框架整合 1）hibernate的sessionFactory交给spring配置 2）把hibernate数据库配置交给spring配置 Spring框架整合struts2框架把struts2的action交给spring管理实现过程第一步 导入struts2的jar包 1）导入用于整合的jar包 struts2-spring-plugin-2.3.24.jar 第二步 创建action 第三步 创建struts2核心配置文件，配置action 1）位置在src下面，名称是struts.xml 第四步 配置struts2过滤器 第五步 导入spring的jar包 第六步 创建spring配置文件 1）引入约束 2）配置spring监听器 123&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 3）指定spring配置文件位置 1234&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:bean1.xml&lt;/param-value&gt;&lt;/context-param&gt; 第七步 把action交给spring进行配置 1&lt;bean id=&quot;userAction&quot; class=&quot;com.demo.action.UserAction&quot; scope=&quot;prototype&quot;&gt; 1）在spring配置action对象，在struts.xml中也配置action对象 2）解决： 只需要在spring里面配置action对象，不要在struts.xml中配置 1234&lt;!-- 在action标签里面不能写action全路径 class属性值写在spring配置action对象的bean标签的id值--&gt;&lt;action name=&quot;user&quot; class=&quot;userAction&quot;&gt; Spring框架整合hibernate框架把hibernate核心配置文件中配置数据库信息在spring进行配置把hibernate里的sessionFactory创建交给spring管理具体实现第一步 导入hibernate的jar包 1）导入struts2和hibernate的jar包时候有jar冲突问题 在struts2里面有jar包 javassist-3.11.0.GA.jar 在hibernate里面有jar包 javassist-3.18.1-GA.jar 删除低版本的jar包 2）导入spring整合持久化层框架需要导入jar包 spring-orm-4.2.4.RELEASE.jar 第二步 搭建hibernate环境搭建 1） 创建实体类 2） 配置实体类映射关系 3） 创建核心配置文件 第三步 把hibernate核心配置文件数据库配置，在spring进行配置 1）把hibernate核心文件中数据库配置去掉了，在spring配置 12345678&lt;!-- 配置c3p0连接池 --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!-- 注入属性值 --&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///ssh&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 第四步 把hibernate的sessionFactory交给spring配置 1）服务器启动时候，加载spring配置文件，把配置文件中对象创建 2）把sessionFactory对象创建在spring配置 3）因为创建sessionFactory代码不是new出来的，而是多行代码实现的 123456//静态代码块实现static &#123; //加载核心配置文件 cfg = new Configuration().configure(); sessionFactory = cfg.buildSessionFactory();&#125; 4）spring里面针对上面情况，封装类，配置类对象可以创建sessionFactory 12345678&lt;!-- sessionFactory创建交给spring管理 --&gt;&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt; &lt;!-- 因为在hibernate核心配置文件中，没有数据库配置，数据库配置在spring里面配置，注入dataSource --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;!-- 指定使用hibernate核心配置文件 --&gt; &lt;property name=&quot;configLocations&quot; value=&quot;classpath:hibernate.cfg.xml&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 第五步 在dao里面使用hibernateTemplate 1）在dao得到hibernateTemplate的对象 12345// 注入hibernateTemplateprivate HibernateTemplate hibernateTemplate;public void setHibernateTemplate(HibernateTemplate hibernateTemplate) &#123; this.hibernateTemplate = hibernateTemplate; 12345678910&lt;!-- 创建实现类对象 --&gt;&lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.demo.dao.UserDaoImpl&quot;&gt; &lt;property name=&quot;hibernateTemplate&quot; ref=&quot;hibernateTemplate&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 创建hibernateTemplate对象 --&gt;&lt;bean id=&quot;hibernateTemplate&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTemplate&quot;&gt; &lt;!-- 注入sessionFactory --&gt; &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 2）调用hibernate模板里面save方法添加 12345User user = new User();user.setUsername(&quot;rose&quot;);user.setAddress(&quot;korea&quot;);hibernateTemplate.save(user); 没有配置事务，做操作时候，出现异常 第六步 配置事务 12345678&lt;!-- 第一步 配置事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt; &lt;!--注入sessionFactory--&gt; &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 第二步 开启事务注解 --&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; 12@Transactionalpublic class UserService &#123; HibernateTemplate介绍1 HibernateTemplate对hibernate框架进行封装 直接调用HibernateTemplate里面的方法实现功能 2 HibernateTemplate常用的方法 Serializable save(Object entity) ：添加操作 void update(Object entity) ：修改操作 void delete(Object entity) ：删除操作 T get(Class entityClass, Serializable id) ：根据id查询 T load(Class entityClass, Serializable id)： 根据id查询 123// get方法：根据id查询User user = hibernateTemplate.get(User.class, 2);System.out.println(user.getUsername() +&quot;--&quot;+ user.getAddress()); List find(String queryString, Object… values) ：查询操作的方法 public List&lt;?&gt; find(final String queryString, final Object... values 1）第一个参数是 hql语句 2）语句参数值 1234567891011// find方法：查询所有记录List&lt;User&gt; list = (List&lt;User&gt;) hibernateTemplate.find(&quot;from User &quot;);for (User user : list) &#123; System.out.println(user.getUsername() +&quot;--&quot;+ user.getAddress());&#125;// find方法：条件查询 List&lt;User&gt; list1 = (List&lt;User&gt;) hibernateTemplate.find(&quot;from User where username=?&quot;, &quot;rose&quot;);for (User user : list1) &#123; System.out.println(user.getUsername() +&quot;--&quot;+ user.getAddress());&#125; SSH框架整合过程导入jar包搭建struts2环境1 创建action，创建struts.xml配置文件，配置action 2 配置struts2的过滤器 搭建hibernate环境1 创建实体类 2 配置实体类和数据库表映射关系 3 创建hibernate核心配置文件 引入映射配置文件 搭建spring环境1 创建spring核心配置文件 2 让spring配置文件在服务器启动时候加载 配置监听器 指定spring配置文件位置 struts2和spring整合1 把action在spring配置（action多实例的） 2 在struts.xml中action标签class属性里面写 bean的id值 spring和hibernate整合1 把hibernate核心配置文件中数据库配置，在spring里面配置 2 把hibernate的sessionFactory在spring配置 在dao里面使用hibernateTemplate1 在dao注入hibernateTemplate对象 2 在hibernateTemplate对象中注入sessionFactory 配置事务整合其他方式1 spring整合hibernate时候，可以不写hibernate核心配置文件 1）把hibernate核心配置文件中，基本信息配置和映射引入都放到spring配置 123456789101112131415161718192021222324252627&lt;!-- sessionFactory创建交给spring管理 --&gt;&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt; &lt;!-- 因为在hibernate核心配置文件中，没有数据库配置，数据库配置在spring里面配置，注入dataSource --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;!-- 指定使用hibernate核心配置文件 --&gt; &lt;!-- &lt;property name=&quot;configLocations&quot; value=&quot;classpath:hibernate.cfg.xml&quot;&gt;&lt;/property&gt; --&gt; &lt;!-- 配置hibernate基本信息 --&gt; &lt;property name=&quot;hibernateProperties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;hibernate.show_sql&quot;&gt;true&lt;/prop&gt; &lt;prop key=&quot;hibernate.format_sql&quot;&gt;true&lt;/prop&gt; &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/prop&gt; &lt;prop key=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- 配置映射文件引入 --&gt; &lt;property name=&quot;mappingResources&quot;&gt; &lt;list&gt; &lt;value&gt;cn/itcast/entity/User.hbm.xml&lt;/value&gt; &lt;!-- &lt;value&gt;....&lt;/value&gt; --&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; Spring分模块开发1 在spring里面配置多个内容，造成配置混乱，不利用维护 2 把spring核心配置文件中，一部分配置放到单独的配置文件中，在spring核心配置文件中引入单独配置文件 12&lt;!-- 引入其他spring配置文件 --&gt;&lt;import resource=&quot;classpath:user.xml&quot;/&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- user.xml --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- 配置action的对象 --&gt; &lt;bean id=&quot;userAction&quot; class=&quot;cn.itcast.action.UserAction&quot; scope=&quot;prototype&quot;&gt; &lt;!-- 注入service --&gt; &lt;property name=&quot;userService&quot; ref=&quot;userService&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 创建service对象 --&gt; &lt;bean id=&quot;userService&quot; class=&quot;cn.itcast.service.UserService&quot;&gt; &lt;!-- 注入dao 接口 = 实现类对象 --&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDaoImpl&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 创建实现类对象 --&gt; &lt;bean id=&quot;userDaoImpl&quot; class=&quot;cn.itcast.dao.UserDaoImpl&quot;&gt; &lt;property name=&quot;hibernateTemplate&quot; ref=&quot;hibernateTemplate&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 创建hibernateTemplate对象 --&gt; &lt;bean id=&quot;hibernateTemplate&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTemplate&quot;&gt; &lt;!-- 注入sessionFactory --&gt; &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt;","categories":[{"name":"java","slug":"java","permalink":"https://supertramp7.github.io/categories/java/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"https://supertramp7.github.io/tags/ssh/"},{"name":"java","slug":"java","permalink":"https://supertramp7.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://supertramp7.github.io/tags/spring/"},{"name":"hibernate","slug":"hibernate","permalink":"https://supertramp7.github.io/tags/hibernate/"},{"name":"struts2","slug":"struts2","permalink":"https://supertramp7.github.io/tags/struts2/"}]},{"title":"Hibernate知识点","slug":"hibernate","date":"2022-03-10T17:09:09.000Z","updated":"2022-04-08T06:18:23.709Z","comments":true,"path":"hibernate/","link":"","permalink":"https://supertramp7.github.io/hibernate/","excerpt":"","text":"WEB内容回顾JavaEE三层结构1 web层：struts2框架 2 service层：spring框架 3 dao层：hibernate框架 1）对数据库进行crud操作 MVC思想1 m：模型 2 v：视图 3 c：控制器 Hibernate概述什么是框架1 写程序，使用框架之后，帮我们实现一部分功能，使用框架好处，少写一部分代码实现功能 什么是hibernate框架（重点）1 hibernate框架应用在javaee三层结构中 dao层框架 2 在dao层里面做对数据库crud操作，使用hibernate实现crud操作 hibernate底层代码就是jdbc，hibernate对jdbc进行封装 使用hibernate好处，不需要写复杂jdbc代码了， 不需要写sql语句实现 3 hibernate开源的轻量级的框架 4 hibernate版本 Hibernate3.x Hibernate4.x Hibernate5.x（学习） 什么是orm思想（重点）1 hibernate使用orm思想对数据库进行crud操作 2 在web阶段学习 javabean，更正确的叫法 实体类 3 orm：object relational mapping，对象关系映射 文字描述： 1）让实体类和数据库表进行一一对应关系 让实体类首先和数据库表对应 让实体类属性 和 表里面字段对应 2）不需要直接操作数据库表，而操作表对应实体类对象 Hibernate入门搭建hibernate环境（重点）1 导入hibernate的jar包 因为使用hibernate时候，有日志信息输出，hibernate本身没有日志输出的jar包，导入其他日志的jar包 不要忘记还有mysql驱动的jar包 antlr-2.7.7.jardom4j-1.6.1.jargeronimo-jta_1.1_spec-1.1.1.jarhibernate-commons-annotations-5.0.1.Final.jarhibernate-core-5.0.7.Final.jarhibernate-entitymanager-5.0.7.Final.jarhibernate-jpa-2.1-api-1.0.0.Final.jarjandex-2.0.0.Final.jarjavassist-3.18.1-GA.jarjboss-logging-3.3.0.Final.jarlog4j-1.2.16.jarmysql-connector-java-5.0.4-bin.jarslf4j-api-1.6.1.jarslf4j-log4j12-1.7.2.jar 2 创建实体类 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.demo.entity;public class User &#123; // hibernate 要求实体类有一个属性唯一的 private int uid; private String username; private String password; private String address; public int getUid() &#123; return uid; &#125; public void setUid(int uid) &#123; this.uid = uid; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 1）使用hibernate时候，不需要自己手动创建表，hibernate帮把表创建 3 配置实体类和数据库表一一对应关系（映射关系） 使用配置文件实现映射关系 1）创建xml格式的配置文件 映射配置文件名称和位置没有固定要求 建议：在实体类所在包里面创建，实体类名称.hbm.xml 2）配置是是xml格式，在配置文件中首先引入xml约束 学过约束dtd、schema，在hibernate里面引入的约束dtd约束 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt; 3）配置映射关系 1234567891011121314151617181920212223242526272829303132&lt;hibernate-mapping&gt;&lt;!-- 1 配置类和表对应 class标签 name属性：实体类全路径 table属性：数据库表名称--&gt; &lt;class name=&quot;com.demo.entity.User&quot; table=&quot;t_user&quot;&gt;&lt;!-- 2 配置实体类id和表id对应 hibernate要求实体类有一个属性唯一值 hibernate要求表有字段作为唯一值--&gt; &lt;!-- id标签 name属性：实体类里面id属性名称 column属性：生成的表字段名称 --&gt; &lt;id name=&quot;uid&quot; column=&quot;uid&quot;&gt; &lt;!-- 设置数据库表id增长策略 native:生成表id值就是主键自动增长 --&gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;!-- 配置其他属性和表字段对应 name属性：实体类属性名称 column属性：生成表字段名称 --&gt; &lt;property name=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; column=&quot;password&quot;&gt;&lt;/property&gt; &lt;property name=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 4 创建hibernate的核心配置文件 1）核心配置文件格式xml，但是核心配置文件名称和位置固定的 位置：必须src下面 名称：必须hibernate.cfg.xml 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 第一部分： 配置数据库信息 必须的 --&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:///hibernate&lt;/property&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt;&lt;/property&gt; &lt;!-- 第二部分： 配置hibernate信息 可选的--&gt; &lt;!-- 输出底层sql语句 --&gt; &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 输出底层sql语句格式 --&gt; &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt; &lt;!-- hibernate帮创建表，需要配置之后 update: 如果已经有表，更新，如果没有，创建 --&gt; &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;!-- 配置数据库方言 在mysql里面实现分页 关键字 limit，只能使用mysql里面 在oracle数据库，实现分页rownum 让hibernate框架识别不同数据库的自己特有的语句 --&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 第三部分： 把映射文件放到核心配置文件中 必须的--&gt; &lt;mapping resource=&quot;com/demo/entity/User.hbm.xml&quot;/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 实现添加操作1 加载hibernate核心配置文件 2 创建SessionFactory对象 3 使用SessionFactory创建session对象 4 开启事务 5 写具体逻辑 crud操作 6 提交事务 7 关闭资源 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.demo.test;import com.demo.entity.User;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import org.junit.Test;public class HibernateTest &#123; @Test public void testAdd()&#123;// 第一步 加载hibernate核心配置文件 // 到src下面找到名称是hibernate.cfg.xml // 在hibernate里面封装对象 Configuration cfg = new Configuration(); cfg.configure();// 第二步 创建SessionFactory对象 //读取hibernate核心配置文件内容，创建sessionFactory //在过程中，根据映射关系，在配置数据库里面把表创建 SessionFactory sessionFactory = cfg.buildSessionFactory();// 第三步 使用SessionFactory创建session对象 // 类似于连接 Session session = sessionFactory.openSession();// 第四步 开启事务 Transaction tx = session.beginTransaction();// 第五步 写具体逻辑 crud操作 // 添加功能 User user = new User(); user.setUsername(&quot;lili&quot;); user.setPassword(&quot;123&quot;); user.setAddress(&quot;thailand&quot;); // 调用session的方法实现添加 session.save(user);// 第六步 提交事务 tx.commit();// 第七步 关闭资源 session.close(); sessionFactory.close(); &#125;&#125; 看到效果： 1 是否生成表 1234567CREATE TABLE `t_user` ( `uid` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(255) DEFAULT NULL, `password` varchar(255) DEFAULT NULL, `address` varchar(255) DEFAULT NULL, PRIMARY KEY (`uid`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; 2 看表是否有记录 Hibernate配置文件详解Hibernate映射配置文件（重点）1 映射配置文件名称和位置没有固定要求 2 映射配置文件中，标签name属性值写实体类相关内容 1）class标签name属性值实体类全路径 2）id标签和property标签name属性值 实体类属性名称 3 id标签和property标签，column属性可以省略的 1）不写值和name属性值一样的 4 property标签type属性，设置生成表字段的类型，自动对应类型 Hibernate核心配置文件1 配置写位置要求 12&lt;hibernate-configuration&gt; &lt;session-factory&gt; 2 配置三部分要求 1）数据库部分必须的 2）hibernate部分可选的 3）映射文件必须的 3 核心配置文件名称和位置固定的 1）位置：src下面 2）名称：hibernate.cfg.xml Hibernate核心apiConfiguration1 代码 12Configuration cfg = new Configuration();cfg.configure(); 1）到src下面找到名称hibernate.cfg.xml配置文件，创建对象，把配置文件放到对象里面（加载核心配置文件） SessionFactory（重点）1 使用configuration对象创建sessionFactory对象 1SessionFactory sessionFactory = cfg.buildSessionFactory(); 1）创建sessionfactory过程中做事情： 根据核心配置文件中，有数据库配置，有映射文件部分，到数据库里面根据映射关系把表创建 1&lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt; 2 创建sessionFactory过程中，这个过程特别耗资源的 1）在hibernate操作中，建议一个项目一般创建一个sessionFactory对象 3 具体实现 1）写工具类，写静态代码块实现 静态代码块在类加载时候执行，执行一次 1234567891011121314151617181920212223242526package com.demo.utils;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;public class HibernateUtils &#123; static Configuration cfg = null; static SessionFactory sessionFactory = null; // 静态代码块实现 static &#123; // 加载核心配置文件 cfg = new Configuration(); cfg.configure(); // 创建SessionFactory对象 sessionFactory = cfg.buildSessionFactory(); &#125; // 提供方法返回sessionFactory public static SessionFactory getSessionFactory()&#123; return sessionFactory; &#125;&#125; Session（重点）1 session类似于jdbc中connection 1Session session = sessionFactory.openSession(); 2 调用session里面不同的方法实现crud操作 1）添加 save方法 2）修改 update方法 3）删除 delete方法 4）根据id查询 get方法 3 session对象单线程对象 1）session对象不能共用，只能自己使用 Transaction1 事务对象 1Transaction tx = session.beginTransaction(); 2 事务提交和回滚方法 12tx.commit();tx.rollback(); 3 事务概念 1）事务四个特性 原子性、一致性、隔离性、持久性 解决配置文件没有提示问题1 可以上网 2 把约束文件引入到项目中 演示常见错误1 在映射配置文件中，把name属性值写错了，和实体类属性名称不一样，出现异常 1Caused by: org.hibernate.property.access.spi.PropertyAccessBuildingException: Could not locate field nor getter method for property named [com.demo.entity.User#username1] 2 在核心配置文件中，没有引入映射配置文件 1org.hibernate.MappingException: Unknown entity: com.demo.entity.User 3 测试配置是否正确 1）在工具类，写静态代码块，创建sessionFactory，过程中根据配置把表创建 2）让工具类执行，在工具类写main方法可以了 3）如果出现异常，弹出框 点击确定，在控制台有异常输出 4 配置文件里面属性值，双引号里面不能有空格 5 注意输入法全角问题 实体类编写规则1 实体类里面属性私有的 2 私有属性使用公开的set和get方法操作 3 要求实体类有属性作为唯一值（一般使用id值） 4 实体类属性建议不使用基本数据类型，使用基本数据类型对应的包装类 1）八个基本数据类型对应的包装类 int – Integer char - Character 其他的都是首字母大写 比如 double – Double 2）比如 表示学生的分数，假如 int score; 比如学生得了0分 ，int score = 0; 如果表示学生没有参加考试，int score = 0;不能准确表示学生是否参加考试 解决： 使用包装类可以了， Integer score = 0;表示学生得了0分 Integer score = null;表示学生没有参加考试 Hibernate主键生成策略1 hibernate要求实体类里面有一个属性作为唯一值，对应表主键，主键可以不同生成策略 2 hibernate主键生成策略有很多的值 3 在class属性里面有很多值 1）native： 根据使用的数据库帮选择哪个值 2）uuid：之前web阶段写代码生成uuid值，hibernate帮我们生成uuid值 4 演示生成策略值 uuid 1）使用uuid生成策略，实体类id属性类型 必须 字符串类型 private String uid; 2）配置部分写出uuid值 &lt;generator class=&quot;uuid&quot;&gt;&lt;/generator&gt; 1234567CREATE TABLE &#96;t_user&#96; ( &#96;uid&#96; varchar(255) NOT NULL, &#96;username&#96; varchar(255) DEFAULT NULL, &#96;password&#96; varchar(255) DEFAULT NULL, &#96;address&#96; varchar(255) DEFAULT NULL, PRIMARY KEY (&#96;uid&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8; 实体类操作crud操作1 添加操作 1）调用session里面的save方法实现 12345678910111213141516// 添加功能User user = new User();user.setUsername(&quot;rose&quot;);user.setPassword(&quot;1232&quot;);user.setAddress(&quot;australia&quot;);// 调用session的方法实现添加session.save(user);Hibernate: insert into t_user (username, password, address) values (?, ?, ?) 2 根据id查询 1）调用session里面的get方法实现 123456789101112131415161718// 根据id查询// 调用session里面的get方法// 第一个参数：实体类的class// 第二个参数：id值User user = session.get(User.class, 1);System.out.println(user);Hibernate: select user0_.uid as uid1_0_0_, user0_.username as username2_0_0_, user0_.password as password3_0_0_, user0_.address as address4_0_0_ from t_user user0_ where user0_.uid=?User&#123;uid=1, username=&#x27;rose&#x27;, password=&#x27;1232&#x27;, address=&#x27;australia&#x27;&#125; 3 修改操作 1）首先查询，再修改值 1234567891011121314151617181920212223242526272829&#x2F;&#x2F; 修改操作&#x2F;&#x2F; 修改uid&#x3D;2记录username值&#x2F;&#x2F; 1 根据id查询User user &#x3D; session.get(User.class, 2);&#x2F;&#x2F; 2 向返回的user对象里面设置修改之后的值user.setUsername(&quot;lisa&quot;);&#x2F;&#x2F; 3 调用session的方法update修改&#x2F;&#x2F; 执行过程：到user对象里面找到uid值，根据uid进行修改session.update(user);Hibernate: select user0_.uid as uid1_0_0_, user0_.username as username2_0_0_, user0_.password as password3_0_0_, user0_.address as address4_0_0_ from t_user user0_ where user0_.uid&#x3D;?Hibernate: update t_user set username&#x3D;?, password&#x3D;?, address&#x3D;? where uid&#x3D;? 2）直接根据id修改 12345678910111213141516// 把uid=1的记录username修改// 没设置的值会会修改成nullUser user = new User();user.setUid(1);user.setUsername(&quot;cheayoung&quot;);session.update(user);Hibernate: update t_user set username=?, password=?, address=? where uid=? 4 删除操作 1）调用session里面delete方法实现 123456789101112131415161718192021// 删除操作// 第一种 根据id查询对象再删除User user = session.get(User.class, 5);session.delete(user);Hibernate: select user0_.uid as uid1_0_0_, user0_.username as username2_0_0_, user0_.password as password3_0_0_, user0_.address as address4_0_0_ from t_user user0_ where user0_.uid=?Hibernate: delete from t_user where uid=? 1234567891011// 第二种 直接设置对象id删除User user = new User();user.setUid(6);session.delete(user);Hibernate: delete from t_user where uid=? 实体类对象状态1 实体类状态有三种 1）瞬时态：对象里面没有id值，对象与session没有关联 2）持久态：对象里面有id值，对象与session关联 3）托管态：对象有id值，对象与session没有关联 2 演示操作实体类对象的方法 1）saveOrUpdate方法：实现添加、实现修改 123456789101112131415User user = new User();user.setUsername(&quot;bp&quot;);user.setPassword(&quot;213&quot;);user.setAddress(&quot;sdfadf&quot;);// 实体类对象状态是瞬时态，做添加操作session.saveOrUpdate(user);Hibernate: insert into t_user (username, password, address) values (?, ?, ?) 12345678910111213141516171819User user = new User();user.setUid(7);user.setUsername(&quot;fff&quot;);user.setPassword(&quot;ffff&quot;);// user.setAddress(&quot;sdfadf&quot;);// 实体类对象状态是托管态，做修改操作// 没设置的值会会修改成nullsession.saveOrUpdate(user);Hibernate: update t_user set username=?, password=?, address=? where uid=? 12345678910111213141516171819202122232425User user = session.get(User.class, 7);user.setAddress(&quot;asdfsdafsadf&quot;);// 实体类对象状态是持久态，做修改操作session.saveOrUpdate(user);Hibernate: select user0_.uid as uid1_0_0_, user0_.username as username2_0_0_, user0_.password as password3_0_0_, user0_.address as address4_0_0_ from t_user user0_ where user0_.uid=?Hibernate: update t_user set username=?, password=?, address=? where uid=? Hibernate的一级缓存什么是缓存1 数据存到数据库里面，数据库本身是文件系统，使用流方式操作文件效率不是很高 1）把数据存到内存里面，不需要使用流方式，可以直接读取内存中数据 2）把数据放到内存中，提高读取效率 Hibernate缓存1 hibernate框架中提供很多优化方式，hibernate的缓存就是一个优化方式 2 hibernate缓存特点 第一类 hibernate的一级缓存 1）hibernate的一级缓存默认打开的 2）hibernate的一级缓存使用范围，是session范围，从session创建到session关闭范围 3）hibernate的一级缓存中，存储数据必须 持久态数据 第二类 hibernate的二级缓存 1）目前已经不使用了，替代技术 redis 2）二级缓存默认不是打开的，需要配置 3）二级缓存使用范围，是sessionFactory范围 验证一级缓存存在1 验证方式 1）首先根据uid=1查询，返回对象 第一步执行get方法之后，发送sql语句查询数据库 2）再根据uid=1查询，返回对象 第二个执行get方法之后，没有发送sql语句，查询一级缓存内容 12345678910111213141516171819202122// 1 根据uid=2查询// 第一步执行get方法之后，是否发送sql语句User user1 = session.get(User.class, 6);System.out.println(user1);// 2 根据uid=2查询// 第二步执行get方法之后，是否发送sql语句User user2 = session.get(User.class, 6);System.out.println(user2);Hibernate: select user0_.uid as uid1_0_0_, user0_.username as username2_0_0_, user0_.password as password3_0_0_, user0_.address as address4_0_0_ from t_user user0_ where user0_.uid=?User&#123;uid=2, username=&#x27;lisa&#x27;, password=&#x27;123&#x27;, address=&#x27;thailand&#x27;&#125;User&#123;uid=2, username=&#x27;lisa&#x27;, password=&#x27;123&#x27;, address=&#x27;thailand&#x27;&#125; Hibernate一级缓存执行过程1 首先，查询一级缓存，查询一级缓存发现没数据，才会去查询数据，返回user1对象（持久态对象） 2 其次，把user1持久态对象放到一级缓存中 3 当第二次查询时，查询一级缓存，发现一级缓存有相同的数据，直接返回 Hibernate一级缓存特性1 持久态自动更新数据库 123456// 1 根据id查询User user = session.get(User.class, 7);// 2 设置返回对象值user.setUsername(&quot;test&quot;);// 3 调用方法实现// session.update(user); 2 执行过程（了解） Hibernate的事务操作事务相关概念1 什么是事务 事务是操作的最基本单元，表示一组操作，要么都成功，有一个失败都失败 2 事务特性 原子性、隔离性、一致性、持久性 3 不考虑隔离性产生问题 1）脏读：一个事务处理过程里读取了另一个未提交的事务中的数据 2）不可重复读：一个事务两次读取同一行的数据，结果得到不同状态的结果，中间正好另一个事务更新了该数据，两次结果相异，不可被信任 3）虚读或幻读：一个事务执行两次查询，第二次结果集包含第一次中没有或某些行已经被删除的数据，造成两次结果不一致 4 设置事务隔离级别 1）mysql默认隔离级别 repeatable read 事务代码规范写法1 代码结构 12345678try &#123; 开启事务 提交事务&#125;catch() &#123; 回滚事务&#125;finally &#123; 关闭&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.demo.test;import com.demo.entity.User;import com.demo.utils.HibernateUtils;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.junit.Test;public class HibernateTest4 &#123; // 事务规范代码 @Test public void testTx() &#123; SessionFactory sessionFactory = null; Session session = null; Transaction tx = null; try &#123; sessionFactory = HibernateUtils.getSessionFactory(); session = sessionFactory.openSession(); // 开启事务 tx = session.beginTransaction(); // 添加 User user = new User(); user.setUsername(&quot;草你麻痹&quot;); user.setPassword(&quot;我想杀人了&quot;); user.setAddress(&quot;我恨你们所有人！！！&quot;); session.save(user); int i = 10 / 0; // 提交事务 tx.commit(); &#125; catch (Exception e) &#123; // 输入异常 e.printStackTrace(); // 回滚事务 tx.rollback(); &#125; finally &#123; // 关闭资源 session.close(); sessionFactory.close(); &#125; &#125;&#125; Hibernate绑定session1 session类似于jdbc的connection，之前web阶段学过 ThreadLocal 2 帮实现与本地线程绑定session 3 获取与本地线程session 1）在hibernate核心配置文件中配置 123&lt;!-- 在hibernate核心配置文件中配置 --&gt;&lt;!-- 与本地线程绑定session --&gt;&lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;/property&gt; 2）调用sessionFactory里面的方法得到 1234// 提供返回与本地线程绑定的session的方法public static Session getSessionObject()&#123; return sessionFactory.getCurrentSession();&#125; 4 获取与本地线程绑定session时候，关闭session报错，不需要手动关闭了 org.hibernate.SessionException: Session was already closed Hibernate其他的api（查询）Query对象1 使用query对象，不需要写sql语句，但是写hql语句 1）hql：hibernate query language，hibernate提供查询语言，这个hql语句和普通sql语句很相似 2）hql和sql语句区别： 使用sql操作表和表字段 使用hql操作实体类和属性 2 查询所有hql语句 1）from 实体类名称 3 Query对象使用 1）创建Query对象 2）调用query对象里面的方法得到结果 12345678910// 1 创建Query对象// 方法里面写hql语句Query query = session.createQuery(&quot;from User&quot;);// 2 调用Query对象里面的方法得到结果List&lt;User&gt; list = query.list();for (User user : list) &#123; System.out.println(user);&#125; Criteria对象1 使用这个对象查询操作，但是使用这个对象时候，不需要写语句，直接调用方法实现 2 实现过程 1）创建criteria对象 2）调用对象里面的方法得到结果 123456789// 1 创建criteria对象Criteria criteria = session.createCriteria(User.class);// 2 调用对象里面的方法得到结果List&lt;User&gt; list = criteria.list();for (User user : list) &#123; System.out.println(user);&#125; SQLQuery对象1 使用hibernate时候，调用底层sql实现 2 实现过程 1）创建对象 2）调用对象的方法得到结果 返回list集合每部分是数组 1234567891011// 1 创建对象// 参数普通sql语句SQLQuery sqlQuery = session.createSQLQuery(&quot;select * from t_user&quot;);// 2 调用SQLQuery对象的方法得到结果// 返回list集合，默认里面每部分数组结构List&lt;Object[]&gt; list = sqlQuery.list();for (Object[] obj : list) &#123; System.out.println(Arrays.toString(obj));&#125; 返回list中每部分是对象形式 123456789// 1 创建对象// 参数普通sql语句SQLQuery sqlQuery = session.createSQLQuery(&quot;select * from t_user&quot;);// 返回的list中每部分是对象形式sqlQuery.addEntity(User.class);// 调用sqlQuery里面的方法List&lt;User&gt; list = sqlQuery.list();System.out.println(list); 客户列表功能表与表之间关系回顾（重点）一对多1 分类和商品关系，一个分类里面有多个商品，一个商品只能属于一个分类 2 客户和联系人是一对多关系 客户：与公司有业务往来，百度、新浪、360 联系人：公司里面的员工，百度里面有很多员工，联系员工 公司和公司员工的关系 客户是一，联系人是多 一个客户里面有多个联系人，一个联系人只能属于一个客户 3 一对多建表：通过外键建立关系 多对多1 订单和商品关系，一个订单里面有多个商品，一个商品属于多个订单 2 用户和角色多对多关系 用户： 小王、小马、小宋 角色：总经理、秘书、司机、保安 比如小王 可以 是总经理，可以是司机 比如小宋 可以是司机，可以是秘书，可以保安 比如小马 可以是 秘书，可以是总经理 一个用户里面可以有多个角色，一个角色里面可以有多个用户 3 多对多建表：创建第三张表维护关系 一对一1 在中国，一个男人只能有一个妻子，一个女人只能有一个丈夫 Hibernate的一对多操作（重点）一对多映射配置（重点）以客户和联系人为例：客户是一，联系人是多 1 创建两个实体类，客户和联系人 2 让两个实体类之间互相表示 1）在客户实体类里面表示多个联系人 一个客户里面有多个联系人 1234567891011// 在客户实体类里面表示多个联系人，一个客户有多个联系人// hibernate要求使用集合表示多的数据，使用set集合private Set&lt;LinkMan&gt; setLinkMan = new HashSet&lt;&gt;();public Set&lt;LinkMan&gt; getSetLinkMan() &#123; return setLinkMan;&#125;public void setSetLinkMan(Set&lt;LinkMan&gt; setLinkMan) &#123; this.setLinkMan = setLinkMan;&#125; 2）在联系人实体类里面表示所属客户 一个联系人只能属于一个客户 12345678910// 在联系人实体类里面表示所属客户，一个联系人只能属于一个客户private Customer customer;public Customer getCustomer() &#123; return customer;&#125;public void setCustomer(Customer customer) &#123; this.customer = customer;&#125; 3 配置映射关系 1）一般一个实体类对应一个映射文件 2）把映射最基本配置完成 3）在映射文件中，配置一对多关系 在客户映射文件中，表示所有联系人 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping&gt; &lt;!-- 1 配置类和表对应 class标签 name属性：实体类全路径 table属性：数据库表名称 --&gt; &lt;class name=&quot;com.demo.entity.Customer&quot; table=&quot;t_customer&quot;&gt; &lt;id name=&quot;cid&quot; column=&quot;cid&quot;&gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;custName&quot; column=&quot;custName&quot;&gt;&lt;/property&gt; &lt;property name=&quot;custLevel&quot; column=&quot;custLevel&quot;&gt;&lt;/property&gt; &lt;property name=&quot;custSource&quot; column=&quot;custSource&quot;&gt;&lt;/property&gt; &lt;property name=&quot;custPhone&quot; column=&quot;custPhone&quot;&gt;&lt;/property&gt; &lt;property name=&quot;custMobile&quot; column=&quot;custMobile&quot;&gt;&lt;/property&gt; &lt;!-- 在客户映射文件中，表示所有联系人 使用set标签表示所有联系人 set标签里面有name属性： 属性值写在客户实体类里面表示联系人的set集合名称 inverse属性默认值：false不放弃关系维护 true表示放弃关系维护 --&gt; &lt;set name=&quot;setLinkMan&quot; inverse=&quot;true&quot;&gt; &lt;!-- 一对多建表，有外键 hibernate机制：双向维护外键，在一和多那一方都配置外键 column属性值：外键名称 --&gt; &lt;key column=&quot;clid&quot;&gt;&lt;/key&gt; &lt;!-- 客户所有的联系人，class里面写联系人实体类全路径 --&gt; &lt;one-to-many class=&quot;com.demo.entity.LinkMan&quot;/&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 在联系人映射文件中，表示所属客户 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping&gt; &lt;!-- 1 配置类和表对应 class标签 name属性：实体类全路径 table属性：数据库表名称 --&gt; &lt;class name=&quot;com.demo.entity.LinkMan&quot; table=&quot;t_linkman&quot;&gt; &lt;id name=&quot;lkm_id&quot; column=&quot;lkm_id&quot;&gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;lkm_name&quot; column=&quot;lkm_name&quot;&gt;&lt;/property&gt; &lt;property name=&quot;lkm_gender&quot; column=&quot;lkm_gender&quot;&gt;&lt;/property&gt; &lt;property name=&quot;lkm_phone&quot; column=&quot;lkm_phone&quot;&gt;&lt;/property&gt; &lt;!-- 表示联系人所属客户 name属性：因为在联系人实体类使用customer对象表示，写customer名称 class属性：customer全路径 column属性：外键名称 --&gt; &lt;many-to-one name=&quot;customer&quot; class=&quot;com.demo.entity.Customer&quot; column=&quot;clid&quot;&gt;&lt;/many-to-one&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 4 创建核心配置文件，把映射文件引入到核心配置文件中 123&lt;!-- 第三部分： 把映射文件放到核心配置文件中 必须的--&gt;&lt;mapping resource=&quot;com/demo/entity/Customer.hbm.xml&quot;&gt;&lt;/mapping&gt;&lt;mapping resource=&quot;com/demo/entity/LinkMan.hbm.xml&quot;&gt;&lt;/mapping&gt; 测试 运行工具类 1234567891011121314151617181920CREATE TABLE &#96;t_customer&#96; ( &#96;cid&#96; int(11) NOT NULL AUTO_INCREMENT, &#96;custName&#96; varchar(255) DEFAULT NULL, &#96;custLevel&#96; varchar(255) DEFAULT NULL, &#96;custSource&#96; varchar(255) DEFAULT NULL, &#96;custPhone&#96; varchar(255) DEFAULT NULL, &#96;custMobile&#96; varchar(255) DEFAULT NULL, PRIMARY KEY (&#96;cid&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8; CREATE TABLE &#96;t_linkman&#96; ( &#96;lkm_id&#96; int(11) NOT NULL AUTO_INCREMENT, &#96;lkm_name&#96; varchar(255) DEFAULT NULL, &#96;lkm_gender&#96; varchar(255) DEFAULT NULL, &#96;lkm_phone&#96; varchar(255) DEFAULT NULL, &#96;clid&#96; int(11) DEFAULT NULL, PRIMARY KEY (&#96;lkm_id&#96;), KEY &#96;FKjtgu0oocf35ij4fmulu123vwk&#96; (&#96;clid&#96;), CONSTRAINT &#96;FKjtgu0oocf35ij4fmulu123vwk&#96; FOREIGN KEY (&#96;clid&#96;) REFERENCES &#96;t_customer&#96; (&#96;cid&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8; 一对多级联操作一对多级联保存1 添加一个客户，为这个客户添加一个联系人 1）复杂写法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.demo.test;import com.demo.entity.Customer;import com.demo.entity.LinkMan;import com.demo.utils.HibernateUtils;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.junit.Test;public class HibernateOnetoMany &#123; @Test public void testAdd()&#123; SessionFactory sessionFactory = null; Transaction tx = null; Session session = null; try &#123; sessionFactory = HibernateUtils.getSessionFactory(); session = sessionFactory.openSession(); tx = session.beginTransaction(); // 添加一个客户，为这个客户添加一个联系人 // 1 创建客户和联系人对象 Customer customer = new Customer(); customer.setCustName(&quot;sm&quot;); customer.setCustLevel(&quot;1&quot;); customer.setCustSource(&quot;11&quot;); customer.setCustPhone(&quot;1111&quot;); customer.setCustMobile(&quot;32424&quot;); LinkMan linkMan = new LinkMan(); linkMan.setLkm_name(&quot;wendy&quot;); linkMan.setLkm_gender(&quot;0&quot;); linkMan.setLkm_phone(&quot;232423&quot;); // 2 在客户表示所有联系人，在联系人表示客户 // 建立客户对象和联系人对象关系 // 2.1 把联系人对象 放到客户对象的set集合里面 linkMan.setCustomer(customer); // 3 保存到数据库 session.save(customer); session.save(linkMan); tx.commit(); &#125;catch (Exception e)&#123; tx.rollback(); &#125;finally &#123; session.close(); sessionFactory.close(); &#125; &#125;&#125; 2）简化写法 一般根据客户添加联系人 第一步 在客户映射文件中进行配置 在客户映射文件里面set标签进行配置 1&lt;set name=&quot;setLinkMan&quot; cascade=&quot;save-update&quot;&gt; 第二步 创建客户和联系人对象，只需要把联系人放到客户里面就可以了，最终只需要保存客户就可以了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.demo.test;import com.demo.entity.Customer;import com.demo.entity.LinkMan;import com.demo.utils.HibernateUtils;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.junit.Test;public class HibernateOnetoMany &#123; @Test public void testAdd()&#123; SessionFactory sessionFactory = null; Transaction tx = null; Session session = null; try &#123; sessionFactory = HibernateUtils.getSessionFactory(); session = sessionFactory.openSession(); tx = session.beginTransaction(); // 添加一个客户，为这个客户添加一个联系人 // 1 创建客户和联系人对象 Customer customer = new Customer(); customer.setCustName(&quot;jyp&quot;); customer.setCustLevel(&quot;2&quot;); customer.setCustSource(&quot;1dsf1&quot;); customer.setCustPhone(&quot;11asdf11&quot;); customer.setCustMobile(&quot;3dafs2424&quot;); LinkMan linkMan = new LinkMan(); linkMan.setLkm_name(&quot;momo&quot;); linkMan.setLkm_gender(&quot;0&quot;); linkMan.setLkm_phone(&quot;232adsf423&quot;); // 2 把联系人放到客户里面 customer.getSetLinkMan().add(linkMan); // 3 保存到数据库 session.save(customer); tx.commit(); &#125;catch (Exception e)&#123; tx.rollback(); &#125;finally &#123; session.close(); sessionFactory.close(); &#125; &#125;&#125; 一对多级联删除1 删除某个客户，把客户里面所有的联系人删除 2 具体实现 第一步 在客户映射文件set标签，进行配置 1）使用属性cascade属性值 delete 1&lt;set name=&quot;setLinkMan&quot; cascade=&quot;save-update,delete&quot;&gt; 第二步 在代码中直接删除客户 1）根据id查询对象，调用session里面delete方法删除 1234// 1 根据id查询客户对象Customer customer = session.get(Customer.class, 3);// 2 调用方法删除session.delete(customer); 3 执行过程 1）根据id查询客户 123456789101112Hibernate: select customer0_.cid as cid1_0_0_, customer0_.custName as custName2_0_0_, customer0_.custLevel as custLeve3_0_0_, customer0_.custSource as custSour4_0_0_, customer0_.custPhone as custPhon5_0_0_, customer0_.custMobile as custMobi6_0_0_ from t_customer customer0_ where customer0_.cid&#x3D;? 2）根据外键id值查询联系人 12345678910111213Hibernate: select setlinkman0_.clid as clid5_1_0_, setlinkman0_.lkm_id as lkm_id1_1_0_, setlinkman0_.lkm_id as lkm_id1_1_1_, setlinkman0_.lkm_name as lkm_name2_1_1_, setlinkman0_.lkm_gender as lkm_gend3_1_1_, setlinkman0_.lkm_phone as lkm_phon4_1_1_, setlinkman0_.clid as clid5_1_1_ from t_linkman setlinkman0_ where setlinkman0_.clid&#x3D;? 3）把联系人外键设置为null 1234567Hibernate: update t_linkman set clid&#x3D;null where clid&#x3D;? 4）删除联系人和客户 123456789101112Hibernate: delete from t_linkman where lkm_id&#x3D;?Hibernate: delete from t_customer where cid&#x3D;? 一对多修改操作（inverse属性）1 让lisa联系人所属客户不是yg，而是sm 12345678// 1 根据id查询lisa联系人，根据id查询sm的客户Customer sm = session.get(Customer.class, 2);LinkMan lisa = session.get(LinkMan.class, 1);// 2 设置持久态对象值// 把联系人放到客户里面sm.getSetLinkMan().add(lisa);// 把客户放到联系人里面lisa.setCustomer(sm); 2 inverse属性 1）因为hibernate双向维护外键，在客户和联系人里面都需要维护外键，修改客户时候修改一次外键，修改联系人时候也修改一次外键，造成效率问题 1234567891011121314151617Hibernate: update t_linkman set lkm_name&#x3D;?, lkm_gender&#x3D;?, lkm_phone&#x3D;?, clid&#x3D;? where lkm_id&#x3D;?Hibernate: update t_linkman set clid&#x3D;? where lkm_id&#x3D;? 2）解决方式：让其中的一方不维护外键 一对多里面，让其中一方放弃外键维护 一个国家有总统，国家有很多人，总统不能认识国家所有人，国家所有人可以认识总统 3）具体实现： 在放弃关系维护映射文件中，进行配置，在set标签上使用inverse属性 1234&lt;!-- inverse属性默认值：false不放弃关系维护 true表示放弃关系维护--&gt;&lt;set name=&quot;setLinkMan&quot; inverse=&quot;true&quot;&gt; Hibernate多对多操作多对多映射配置以用户和角色为例演示 1 创建实体类，用户和角色 2 让两个实体类之间互相表示 1）一个用户里面表示所有角色，使用set集合 12345678910// 一个用户可以有多个角色private Set&lt;Role&gt; setRole = new HashSet&lt;&gt;();public Set&lt;Role&gt; getSetRole() &#123; return setRole;&#125;public void setSetRole(Set&lt;Role&gt; setRole) &#123; this.setRole = setRole;&#125; 2）一个角色有多个用户，使用set集合 12345678910// 一个角色有多个用户private Set&lt;User&gt; setUser = new HashSet&lt;&gt;();public Set&lt;User&gt; getSetUser() &#123; return setUser;&#125;public void setSetUser(Set&lt;User&gt; setUser) &#123; this.setUser = setUser;&#125; 3 配置映射关系 1）基本配置 2）配置多对多关系 在用户里面表示所有角色，使用set标签 1234567891011121314&lt;!-- 在用户里面表示所有角色，使用set标签 name属性：角色set集合名称 table属性：第三张表名称--&gt;&lt;set name=&quot;setRole&quot; table=&quot;user_role&quot; cascade=&quot;save-update,delete&quot;&gt; &lt;!-- key标签里面配置 配置当前映射文件在第三张表外键名称 --&gt; &lt;key column=&quot;userid&quot;&gt;&lt;/key&gt; &lt;!-- class：角色实体类全路径 column：角色在第三张表外键名称 --&gt; &lt;many-to-many class=&quot;com.demo.entity.Role&quot; column=&quot;roleid&quot;&gt;&lt;/many-to-many&gt;&lt;/set&gt; 在角色里面表示所有用户，使用set标签 123456&lt;!-- 在角色里面表示所有用户，使用set标签 --&gt;&lt;set name=&quot;setUser&quot; table=&quot;user_role&quot;&gt; &lt;!-- 角色在第三张表外键 --&gt; &lt;key column=&quot;roleid&quot;&gt;&lt;/key&gt; &lt;many-to-many class=&quot;com.demo.entity.User&quot; column=&quot;userid&quot;&gt;&lt;/many-to-many&gt;&lt;/set&gt; 测试 12345678CREATE TABLE &#96;user_role&#96; ( &#96;userid&#96; int(11) NOT NULL, &#96;roleid&#96; int(11) NOT NULL, PRIMARY KEY (&#96;roleid&#96;,&#96;userid&#96;), KEY &#96;FKkca1ytil11i8ffamb9x4it65m&#96; (&#96;userid&#96;), CONSTRAINT &#96;FKkca1ytil11i8ffamb9x4it65m&#96; FOREIGN KEY (&#96;userid&#96;) REFERENCES &#96;t_user&#96; (&#96;user_id&#96;), CONSTRAINT &#96;FKcwof70ufe1sg8jh46fhrgv5wp&#96; FOREIGN KEY (&#96;roleid&#96;) REFERENCES &#96;t_role&#96; (&#96;role_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8; 多对多级联保存根据用户保存角色 1 在用户配置文件中set标签进行配置，cascade值save-update 2 写代码实现 1）创建用户和角色对象，把角色放到用户里面，最终保存用户就可以了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Testpublic void testAdd()&#123; SessionFactory sessionFactory = null; Transaction tx = null; Session session = null; try &#123; sessionFactory = HibernateUtils.getSessionFactory(); session = sessionFactory.openSession(); tx = session.beginTransaction(); // 添加两个用户，为每个用户添加两个角色 // 1 创建对象 User user1 = new User(); user1.setUser_name(&quot;jisoo&quot;); user1.setUser_password(&quot;111111&quot;); User user2 = new User(); user2.setUser_name(&quot;jennie&quot;); user2.setUser_password(&quot;2222222&quot;); Role role1 = new Role(); role1.setRole_name(&quot;visual&quot;); role1.setRole_memo(&quot;visual&quot;); Role role2 = new Role(); role2.setRole_name(&quot;dancer&quot;); role2.setRole_memo(&quot;dancer&quot;); Role role3 = new Role(); role3.setRole_name(&quot;singer&quot;); role3.setRole_memo(&quot;singer&quot;); // 建立关系，把角色放到用户里面 // user1 -- role1/role2 user1.getSetRole().add(role1); user1.getSetRole().add(role2); // user2 -- role2/role3 user2.getSetRole().add(role2); user2.getSetRole().add(role3); // 保存用户 session.save(user1); session.save(user2); tx.commit(); &#125;catch (Exception e)&#123; tx.rollback(); &#125;finally &#123; session.close(); sessionFactory.close(); &#125;&#125; 多对多级联删除（了解，不常用）1 在set标签进行配置，cascade值delete 2 删除用户 12User user = session.get(User.class, 1);session.delete(user); 维护第三张表关系1 用户和角色多对多关系，维护关系通过第三张表维护 2 让某个用户有某个角色 第一步 根据id查询用户和角色 第二步 把角色放到用户里面 1）把角色对象放到用户set集合 12345678// 让某个用户有某个角色// 让jisoo有singer角色// 1 查询jisoo和singerUser jisoo = session.get(User.class, 1);Role singer = session.get(Role.class, 3);// 2 把角色放到用户的set集合里面jisoo.getSetRole().add(singer); 3 让某个用户没有某个角色 第一步 根据id查询用户和角色 第二步 从用户里面把角色去掉 1）从set集合里面把角色移除 12345678// 让某个用户没有某个角色// 让jisoo没有dancer角色// 1 查询jisoo和dancerUser jisoo = session.get(User.class, 1);Role dancer = session.get(Role.class, 2);// 从用户里面把角色去掉jisoo.getSetRole().remove(dancer); Hibernate查询方式 1 对象导航查询 1）根据id查询某个客户，再查询这个客户里面所有的联系人 2 OID查询 1）根据id查询某一条记录，返回对象 3 HQL查询 1）Query对象，写hql语句实现查询 4 QBC查询 1）Criteria对象 5 本地sql查询 1）SQLQuery对象，使用普通sql实现查询 对象导航查询1 查询某个客户里面所有联系人过程，使用对象导航实现 2 代码 1234567// 根据cid=1客户，再查询这个客户里面所有联系人Customer customer = session.get(Customer.class, 1);// 再查询这个客户里面所有联系人// 直接得到客户里面联系人的set集合Set&lt;LinkMan&gt; linkMEN = customer.getSetLinkMan();System.out.println(linkMEN.size()); OID查询1 根据id查询记录 1）调用session里面的get方法实现 1Customer customer = session.get(Customer.class, 1); HQL查询1 hql：hibernate query language，hibernate提供一种查询语言，hql语言和普通sql很相似 区别：普通sql操作数据库表和字段，hql操作实体类和属性 2 常用的hql语句 1）查询所有： from 实体类名称 2）条件查询： from 实体类名称 where 属性名称=? 3）排序查询： from 实体类名称 order by 实体类属性名称 asc/desc 3 使用hql查询操作时候，使用Query对象 1）创建Query对象，写hql语句 2）调用query对象里面的方法得到结果 查询所有1 查询所有客户记录 1）创建Query对象，写hql语句 2）调用query对象里面的方法得到结果 2 查询所有： from 实体类名称 12345678// 1 创建Query对象Query query = session.createQuery(&quot;from Customer&quot;);// 2 调用方法得到对象List&lt;Customer&gt; list = query.list();for (Customer c : list) &#123; System.out.println(c.getCid() +&quot;-&quot;+ c.getCustName());&#125; 条件查询1 hql条件查询语句写法： 1） from 实体类名称 where 实体类属性名称=? and实体类属性名称=? from 实体类名称 where 实体类属性名称 like ? 2 代码 12345678910111213141516// 1 创建Query对象// SELECT * FROM t_customer WHERE cid=? AND custName=?Query query = session.createQuery(&quot;from Customer c where c.cid=? and c.custName=?&quot;);// 2 设置条件值// 向?里面设置值，setParameter方法两个参数// 第一个参数：int类型是?位置，?位置从0开始// 第二个参数：具体参数值// 设置第一个?值query.setParameter(0, 1);// 设置第二个?值query.setParameter(1, &quot;yg&quot;);List&lt;Customer&gt; list = query.list();for (Customer c : list) &#123; System.out.println(c.getCid() +&quot;-&quot;+ c.getCustName());&#125; 模糊查询 12345678910// 1 创建Query对象Query query = session.createQuery(&quot;from Customer c where c.custName like ?&quot;);// 2 设置条件值query.setParameter(0, &quot;%m%&quot;);List&lt;Customer&gt; list = query.list();for (Customer c : list) &#123; System.out.println(c.getCid() +&quot;-&quot;+ c.getCustName());&#125; 排序查询1 hql排序语句写法 1）from 实体类名称 order by 实体类属性名称 asc(正序)/desc(倒序) 12345678// 1 创建Query对象Query query = session.createQuery(&quot;from Customer order by cid desc&quot;);List&lt;Customer&gt; list = query.list();for (Customer c : list) &#123; System.out.println(c.getCid() +&quot;-&quot;+ c.getCustName());&#125; 分页查询1 mysql实现分页 1）使用关键字 limit实现 SELECT * FROM t_customer LIMIT 0,3 2 在hql中实现分页 1）在hql操作中，在语句里面不能写limit，hibernate的Query对象封装两个方法实现分页操作 12345678910111213141516// 1 创建Query对象// 写查询所有的语句Query query = session.createQuery(&quot;from Customer&quot;);// 2 设置分页数据// 2.1 设置开始位置query.setFirstResult(0);// 2.2 设置每页记录数query.setMaxResults(3);// 3 调用方法得到结果List&lt;Customer&gt; list = query.list();for (Customer c : list) &#123; System.out.println(c.getCid() +&quot;-&quot;+ c.getCustName());&#125; 投影查询1 投影查询：查询不是所有字段值，而是部分字段的值 2 投影查询hql语句写法： 1）select 实体类属性名称1, 实体类属性名称2 from 实体类名称 2）select 后面不能写 * ，不支持的 3 具体实现 123456// 1 创建Query对象Query query = session.createQuery(&quot;select custName from Customer&quot;);// 2 调用方法得到结果List&lt;Customer&gt; list = query.list();System.out.println(list); 聚集函数使用1 常用的聚集函数 1）count、sum、avg、max、min 2 hql聚集函数语句写法 1）查询表记录数 select count(*) from 实体类名称 12345678910111213// 1 创建Query对象 Query query = session.createQuery(&quot;select count(*) from Customer&quot;); // 2 调用方法得到结果 // query对象里面有方法，直接返回对象形式 Object obj = query.uniqueResult(); // 返回int类型// int count = (int) obj; // 会出现类型转换异常 // 首先把obj变成long类型，再变成int类型 Long lobj = (Long) obj; int count = lobj.intValue(); System.out.println(count); QBC查询 1 使用hql查询需要写hql语句实现，但是使用qbc时候，不需要写语句了，使用方法实现 2 使用qbc时候，操作实体类和属性 3 使用qbc，使用Criteria对象实现 查询所有1 创建Criteria对象 2 调用方法得到结果 12345678// 1 创建对象Criteria criteria = session.createCriteria(Customer.class);// 2 调用方法得到结果List&lt;Customer&gt; list = criteria.list();for (Customer c : list) &#123; System.out.println(c.getCid()+&quot; - &quot;+c.getCustName());&#125; 条件查询1 没有语句，使用封装的方法实现 123456789101112131415161718// 1 创建对象Criteria criteria = session.createCriteria(Customer.class);// 2 使用Criteria对象里面的方法设置条件值// 首先使用add方法，表示设置条件值// 在add方法里面使用类的方法实现条件设置// 类似于cid=?criteria.add(Restrictions.eq(&quot;cid&quot;, 1));criteria.add(Restrictions.eq(&quot;custName&quot;, &quot;yg&quot;));// 条件查询criteria.add(Restrictions.like(&quot;custName&quot;, &quot;%m%&quot;));// 3 调用方法得到结果List&lt;Customer&gt; list = criteria.list();for (Customer c : list) &#123; System.out.println(c.getCid()+&quot; - &quot;+c.getCustName());&#125; 排序查询1234567891011// 1 创建对象Criteria criteria = session.createCriteria(Customer.class);// 2 设置对哪个属性进行排序，设置排序规则criteria.addOrder(Order.desc(&quot;cid&quot;));List&lt;Customer&gt; list = criteria.list();for (Customer c : list) &#123; System.out.println(c.getCid()+&quot; - &quot;+c.getCustName());&#125; 分页查询1234567891011121314// 1 创建对象Criteria criteria = session.createCriteria(Customer.class);// 2 设置分页数据// 2.1 设置开始位置criteria.setFirstResult(0);// 2.2 每页显示记录数criteria.setMaxResults(3);List&lt;Customer&gt; list = criteria.list();for (Customer c : list) &#123; System.out.println(c.getCid()+&quot; - &quot;+c.getCustName());&#125; 开始位置计算公式： （当前页-1）*每页记录数 统计查询1234567891011// 1 创建对象Criteria criteria = session.createCriteria(Customer.class);// 2 设置操作criteria.setProjection(Projections.rowCount());// 3 调用方法得到结果Object obj = criteria.uniqueResult();Long lobj = (Long) obj;int count = lobj.intValue();System.out.println(count); 离线查询1 servlet调用service，service调用dao 1）在dao里面对数据库crud操作 2）在dao里面使用hibernate框架，使用hibernate框架时候，调用session里面的方法实现功能 12345678910// 1 创建对象DetachedCriteria detachedCriteria = DetachedCriteria.forClass(Customer.class);// 2 最终执行时候才需要到sessionCriteria criteria = detachedCriteria.getExecutableCriteria(session);List&lt;Customer&gt; list = criteria.list();for (Customer c : list) &#123; System.out.println(c.getCid() + &quot; - &quot; + c.getCustName());&#125; HQL多表查询Mysql里面多表查询1 内连接：查关联的数据 SELECT * FROM t_customer c, t_linkman l WHERE c.cid = l.clid SELECT * FROM t_customer c INNER JOIN t_linkman l ON c.cid = l.clid 2 左外连接：查左边表的全部数据，右边表的关联数据 SELECT * FROM t_customer c LEFT OUTER JOIN t_linkman l ON c.cid = l.clid 3 右外连接：查右边表的全部数据，左边表的关联数据 SELECT * FROM t_customer c RIGHT OUTER JOIN t_linkman l ON c.cid = l.clid HQL实现多表查询Hql多表查询 1）内连接 2）左外连接 3）右外连接 4）迫切内连接 5）迫切左外连接 HQL内连接1 内连接查询hql语句写法：以客户和联系人为例 1）from Customer c inner join c.setLinkMan 1234// 1 创建对象Query query = session.createQuery(&quot;from Customer c inner join c.setLinkMan&quot;);List&lt;Customer&gt; list = query.list(); 返回list，list里面每部分是数组形式 2 演示迫切内连接 1）迫切内连接和内连接底层实现一样的 2）区别：使用内连接返回list中每部分是数组，迫切内连接返回list每部分是对象 3）hql语句写法 from Customer c inner join fetch c.setLinkMan HQL左外连接1 左外连接hql语句 1）from Customer c left outer join c.setLinkMan 2）迫切左外连接from Customer c left outer join fetch c.setLinkMan 2 左外连接返回list中每部分是数组，迫切左外连接返回list每部分是对象 3 右外连接hql语句 1）from Customer c right outer join c.setLinkMan Hibernate检索策略检索策略的概念1 hibernate检索策略分为两类 1）立即查询：根据id查询，调用get方法，一调用get方法马上发送语句查询数据库 1234// 根据cid=1客户// 执行get方法之后，是否发送sql语句// 调用get方法马上发送sql语句查询数据库Customer customer = session.get(Customer.class, 1); 2）延迟查询：根据id查询，还有load方法，调用load方法不会马上发送语句查询数据，只有得到对象里面的值时候才会发送语句查询数据库 12345678/** * 1 调用load方法之后，不会马上发送sql语句 * 1）返回对象里面只有id值 * 2 得到对象里面不是id的其他值时候才会发送语句 */Customer customer = session.load(Customer.class, 2);System.out.println(customer.getCid());System.out.println(customer.getCustName()); 2 延迟查询分成两类 1）类级别延迟：根据id查询返回实体类对象，调用load方法不会马上发送语句 2）关联级别延迟： 查询某个客户，再查询这个客户的所有联系人，查询客户的所有联系人的过程是否需要延迟，这个过程称为关联级别延迟 12345678910// 根据cid=1客户，再查询这个客户里面所有联系人Customer customer = session.get(Customer.class, 1);// 再查询这个客户里面所有联系人// 直接得到客户里面联系人的set集合// 得到set集合，没有发送语句Set&lt;LinkMan&gt; linkMEN = customer.getSetLinkMan();// 发送语句System.out.println(linkMEN.size()); 关联级别延迟操作1 在映射文件中进行配置实现 1）根据客户得到所有的联系人，在客户映射文件中配置 2 在set标签上使用属性 1）fetch：值select（默认） 2）lazy：值 true：延迟（默认） false：不延迟 extra：极其延迟 1234567891011121314&lt;set name=&quot;setLinkMan&quot; cascade=&quot;save-update,delete&quot; inverse=&quot;true&quot; fetch=&quot;select&quot; lazy=&quot;true&quot;&gt; &lt;!-- 一对多建表，有外键 hibernate机制：双向维护外键，在一和多那一方都配置外键 column属性值：外键名称 --&gt; &lt;key column=&quot;clid&quot;&gt;&lt;/key&gt; &lt;!-- 客户所有的联系人，class里面写联系人实体类全路径 --&gt; &lt;one-to-many class=&quot;com.demo.entity.LinkMan&quot;/&gt;&lt;/set&gt; 1234567891011121314&lt;set name=&quot;setLinkMan&quot; cascade=&quot;save-update,delete&quot; inverse=&quot;true&quot; fetch=&quot;select&quot; lazy=&quot;false&quot;&gt; &lt;!-- 一对多建表，有外键 hibernate机制：双向维护外键，在一和多那一方都配置外键 column属性值：外键名称 --&gt; &lt;key column=&quot;clid&quot;&gt;&lt;/key&gt; &lt;!-- 客户所有的联系人，class里面写联系人实体类全路径 --&gt; &lt;one-to-many class=&quot;com.demo.entity.LinkMan&quot;/&gt;&lt;/set&gt; 1）调用get之后，发送两条sql语句 1234567891011121314151617181920212223242526Hibernate: select customer0_.cid as cid1_0_0_, customer0_.custName as custName2_0_0_, customer0_.custLevel as custLeve3_0_0_, customer0_.custSource as custSour4_0_0_, customer0_.custPhone as custPhon5_0_0_, customer0_.custMobile as custMobi6_0_0_ from t_customer customer0_ where customer0_.cid&#x3D;?Hibernate: select setlinkman0_.clid as clid5_1_0_, setlinkman0_.lkm_id as lkm_id1_1_0_, setlinkman0_.lkm_id as lkm_id1_1_1_, setlinkman0_.lkm_name as lkm_name2_1_1_, setlinkman0_.lkm_gender as lkm_gend3_1_1_, setlinkman0_.lkm_phone as lkm_phon4_1_1_, setlinkman0_.clid as clid5_1_1_ from t_linkman setlinkman0_ where setlinkman0_.clid&#x3D;?4 1234567891011121314&lt;set name=&quot;setLinkMan&quot; cascade=&quot;save-update,delete&quot; inverse=&quot;true&quot; fetch=&quot;select&quot; lazy=&quot;extra&quot;&gt; &lt;!-- 一对多建表，有外键 hibernate机制：双向维护外键，在一和多那一方都配置外键 column属性值：外键名称 --&gt; &lt;key column=&quot;clid&quot;&gt;&lt;/key&gt; &lt;!-- 客户所有的联系人，class里面写联系人实体类全路径 --&gt; &lt;one-to-many class=&quot;com.demo.entity.LinkMan&quot;/&gt;&lt;/set&gt; 1）极其懒惰，要什么值给什么值 1234567891011121314151617181920Hibernate: select customer0_.cid as cid1_0_0_, customer0_.custName as custName2_0_0_, customer0_.custLevel as custLeve3_0_0_, customer0_.custSource as custSour4_0_0_, customer0_.custPhone as custPhon5_0_0_, customer0_.custMobile as custMobi6_0_0_ from t_customer customer0_ where customer0_.cid&#x3D;?Hibernate: select count(lkm_id) from t_linkman where clid &#x3D;?4 批量抓取1 查询所有的客户，返回list集合，遍历list集合，得到每个客户，得到每个客户的所有联系人 1）上面操作代码，发送多条sql语句 12345678910111213// 查询所有客户Criteria criteria = session.createCriteria(Customer.class);List&lt;Customer&gt; list = criteria.list();// 得到每个客户里面所有的联系人for (Customer c : list) &#123; System.out.println(c.getCid() + &quot; - &quot; + c.getCustName()); // 每个客户里面所有的联系人 Set&lt;LinkMan&gt; setLinkMan = c.getSetLinkMan(); for (LinkMan linkMan : setLinkMan) &#123; System.out.println(linkMan.getLkm_id() + &quot; - &quot; +linkMan.getLkm_name()); &#125;&#125; 2 在客户的映射文件中，set标签配置 1）batch-size值，值越大发送语句越少 &lt;set name=&quot;setLinkMan&quot; batch-size=&quot;10&quot;&gt;","categories":[{"name":"java","slug":"java","permalink":"https://supertramp7.github.io/categories/java/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"https://supertramp7.github.io/tags/ssh/"},{"name":"java","slug":"java","permalink":"https://supertramp7.github.io/tags/java/"},{"name":"hibernate","slug":"hibernate","permalink":"https://supertramp7.github.io/tags/hibernate/"},{"name":"框架","slug":"框架","permalink":"https://supertramp7.github.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"Struts2知识点","slug":"struts2","date":"2022-03-10T17:08:48.000Z","updated":"2022-04-06T12:19:54.062Z","comments":true,"path":"struts2/","link":"","permalink":"https://supertramp7.github.io/struts2/","excerpt":"","text":"Struts2概述1 struts2框架应用javaee三层结构中web层框架 2 struts2框架在struts1和webwork基础之上发展全新的框架 3 struts2解决问题： 4 struts2版本 struts-2.3.24-all.zip 5 web层常见框架 1）struts2 2）springMVC Struts2框架入门1 导入jar包 12345678910111213asm-3.3.jarasm-commons-3.3.jarasm-tree-3.3.jarcommons-fileupload-1.3.1.jarcommons-io-2.2.jarcommons-lang3-3.2.jarfreemarker-2.3.22.jarjavassist-3.11.0.GA.jarlog4j-api-2.2.jarlog4j-core-2.2.jarognl-3.0.6.jarstruts2-core-2.3.24.jarxwork-core-2.3.24.jar 1）在lib中有jar包，不能把这些jar都导入到项目中 2）到apps目录里面，找到示例程序，从示例程序复制jar包 2 创建action 1234567891011/** * 1 每次访问servlet时候，都会执行service方法 * 写类继承HttpServlet，重写类里面的方法 * 在web.xml中配置servlet访问路径 * * 2 访问action，每次访问action时候，默认执行名称execute方法 * 配置action访问路径 */public String execute()&#123; return &quot;ok&quot;;&#125; 3 配置action类访问路径 1）创建struts2核心配置文件 核心配置文件名称和位置是固定的 位置必须在src下面，名称 struts.xml 2）引入dtd约束 123&lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt; 3）action配置 12345678910&lt;struts&gt; &lt;package name=&quot;hellodemo&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt;&lt;!-- name:访问名称--&gt; &lt;action name=&quot;hello&quot; class=&quot;com.demo.action.HelloAction&quot;&gt;&lt;!-- 配置方法的返回值到页面--&gt; &lt;result name=&quot;ok&quot;&gt;/hello.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 访问路径： http://localhost:8080/strust2_demo1/hello.jsp 4 配置struts2过滤器 Struts2执行过程画图分析过程 查看源代码1 过滤器在服务器启动时候创建，创建过滤器时候执行init方法 1）在init方法中主要加载配置文件 包含自己创建的配置文件和struts2自带配置文件 struts.xml web.xml Struts2的核心配置文件struts.xml 1 名称和位置固定的 src文件下 2 在配置文件中主要三个标签 package、action、result，标签里面的属性 标签package1 类似于代码包，区别不同的action，要配置action，必须首先写package标签，在package里面才能 配置action 2 package标签属性 1）name属性 name属性值根功能本身没有关系的， 在一个配置文件中可以写多个package标签，name属性值不能相同的 2）extends属性 属性值固定的，struts-default 写了这个属性之后，在package里面配置的类便具有action功能 3）namespace属性 namespace属性值和action标签里面的name属性值构成访问路径 标签action1 action标签配置action访问路径 2 action标签属性 1）name属性 namespace属性值和action标签里面的name属性值构成访问路径 在package标签里面写多个action标签，但是action的name属性值不能相同的 2）class属性 action全路径 3）method属性 比如在action里面默认执行的方法execute方法，但是在action里面写其他的方法 让action里面多个方法执行，使用method进行配置 标签result1 根据action的方法返回值，配置到不同的路径里面 2 result标签属性 1）name属性 和方法返回值一样 12&lt;!--配置方法的返回值到页面--&gt;&lt;result name=&quot;ok&quot;&gt;/hello.jsp&lt;/result&gt; 2）type属性 配置如何到路径中（转发或者重定向） type属性默认值 做转发操作 Struts2常量配置1 struts2框架，帮我们实现一部分功能，struts2里面有常量，在常量里面封装一部分功能 2 struts2默认的常量位置（记住） 3 修改struts2默认常量值 1）常用的方式 在struts.xml中进行配置 1&lt;constant name=&quot;struts.i18n.encoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/constant&gt; 2）还有两种方式（了解） 在src下面创建 struts.properties，进行修改 在web.xml进行配置 4 介绍最常用常量 1）表单提交数据到action里面，在action可以获取表单提交数据， 2）表单提交数据有中文，有乱码问题，解决： post提交直接设置编码 get提交做编码转换 3）如果在action获取表单通过post方式提交中文，中文乱码问题帮解决了，不需要自己处理问题 分模块开发1 单独写配置文件，把配置文件引入到核心配置文件中 12&lt;!-- 引入hello.xml--&gt;&lt;include file=&quot;com/demo/action/hello.xml&quot;&gt;&lt;/include&gt; Action编写方式创建普通类，这个不继承任何类，不实现任何接口12345678package com.demo.action;public class HelloAction &#123; public String execute()&#123; return &quot;ok&quot;; &#125;&#125; 创建类，实现接口 Action1234567891011121314package com.demo.action;import com.opensymphony.xwork2.Action;/** * 实现接口 */public class UserAction implements Action &#123; @Override public String execute() throws Exception &#123; return SUCCESS; &#125;&#125; 创建类，继承类 ActionSupport（一般使用）class ActionSupport implements Action 1234567891011package com.demo.action;import com.opensymphony.xwork2.ActionSupport;public class PersonAction extends ActionSupport &#123; @Override public String execute() throws Exception &#123; return SUCCESS; &#125;&#125; 访问action的方法（重点）1 有三种方式实现 第一种 使用action标签的method属性，在这个属性里面写执行的action的方法 第二种 使用通配符方式实现 第三种 动态访问实现（不用） 2 演示错误 1）如果action方法有返回值，在配置文件中没有配置，出现错误 2）在action里面的方法有返回值，如果有返回值时候类型必须是String 3）action里面的方法可以没有返回值，没有返回值时候，在result标签不需要配置 把方法写成void 让返回值，返回 ”none” 1234567891011121314package com.demo.action;import com.opensymphony.xwork2.ActionSupport;public class HelloAction extends ActionSupport &#123; @Override public String execute() &#123; System.out.println(&quot;action....&quot;);// return &quot;ok&quot;;// return &quot;none&quot;; return NONE; &#125;&#125; 使用action标签method属性1 创建action，创建多个方法 1234567891011121314151617181920package com.demo.method;import com.opensymphony.xwork2.ActionSupport;public class BookAction extends ActionSupport &#123; // 添加 public String add()&#123; System.out.println(&quot;add.....&quot;); return NONE; &#125; // 修改 public String update()&#123; System.out.println(&quot;update....&quot;); return NONE; &#125;&#125; 2 使用method配置 1234567&lt;package name=&quot;methoddemo&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt; &lt;!-- 有method属性：写要执行的action里面的方法名称 --&gt; &lt;action name=&quot;addAction&quot; class=&quot;com.demo.method.BookAction&quot; method=&quot;add&quot;&gt;&lt;/action&gt; &lt;!-- 执行update方法 --&gt; &lt;action name=&quot;updateAction&quot; class=&quot;com.demo.method.BookAction&quot; method=&quot;update&quot;&gt;&lt;/action&gt;&lt;/package&gt; 缺陷：action每个方法都需要配置，如果action里面有多个方法，配置很多的action 使用通配符实现（重点）1 在action标签里面name属性，name属性值里面写 符号 * 星号 1）* ： 表示匹配任意内容 比如访问hello，* 可以匹配到 比如访问add，* 可以匹配到 12345678910111213&lt;!-- 通配符方式实现 --&gt;&lt;package name=&quot;methoddemo&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt; &lt;!-- name属性值里面写符号 * 1）执行action里面的add方法，访问book_add，使用book_*可以匹配到，* 相当于变成add 2）执行action里面的update方法，访问book_update，使用book_*可以匹配到，* 相当于变成update 上面两个路径使用book_* 可以匹配到 method属性写 * 值 --&gt; &lt;action name=&quot;book_*&quot; class=&quot;com.demo.method.BookAction&quot; method=&quot;&#123;1&#125;&quot;&gt;&lt;/action&gt;&lt;/package&gt; 案例-客户列表12345678910111213141516171819202122232425262728package com.demo.action;import java.util.List;import javax.servlet.http.HttpServletRequest;import org.apache.struts2.ServletActionContext;import com.opensymphony.xwork2.ActionSupport;import com.demo.entity.Customer;import com.demo.service.CustomerService;public class CustomerAction extends ActionSupport &#123; //客户列表 public String list() &#123; //调用service CustomerService service = new CustomerService(); List&lt;Customer&gt; list = service.findAll(); //放到域对象里面（明天讲到） HttpServletRequest request = ServletActionContext.getRequest(); request.setAttribute(&quot;list&quot;, list); return &quot;list&quot;; &#125;&#125; 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt;&lt;struts&gt; &lt;package name=&quot;demo&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt; &lt;action name=&quot;customer_*&quot; class=&quot;com.demo.action.CustomerAction&quot; method=&quot;&#123;1&#125;&quot;&gt; &lt;result name=&quot;list&quot;&gt;/jsp/customer/list.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 结果页面配置全局结果页面1 result标签配置action方法的返回值到不同的路径里面 2 创建两个action，执行默认的方法execute方法，让两个action的方法都返回success，返回success之后，配置到同一个页面里面 1）如果多个action，方法里面返回值相同的，到页面也是相同的，这个时候可以使用全局结果页面配置 12345678&lt;package name=&quot;demo1&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt; &lt;action name=&quot;book&quot; class=&quot;com.demo.action.BookAction&quot;&gt; &lt;result name=&quot;success&quot;&gt;/hello.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=&quot;orders&quot; class=&quot;com.demo.action.OrdersAction&quot;&gt; &lt;result name=&quot;success&quot;&gt;/hello.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 2）在package标签里面配置 1234&lt;!-- 全局结果页面配置 --&gt;&lt;global-results&gt; &lt;result name=&quot;success&quot;&gt;/hello.jsp&lt;/result&gt;&lt;/global-results&gt; 局部结果页面123&lt;action name=&quot;book&quot; class=&quot;com.demo.action.BookAction&quot;&gt; &lt;result name=&quot;success&quot;&gt;/hello.jsp&lt;/result&gt;&lt;/action&gt; 1 配置全局页面，也配置了局部页面，最终以局部配置为准 1234567&lt;!-- 全局结果页面配置 --&gt;&lt;global-results&gt; &lt;result name=&quot;success&quot;&gt;/hello.jsp&lt;/result&gt;&lt;/global-results&gt;&lt;action name=&quot;book&quot; class=&quot;com.demo.action.BookAction&quot;&gt; &lt;result name=&quot;success&quot;&gt;/hello.jsp&lt;/result&gt;&lt;/action&gt; Result标签的type属性1 result标签里面除了name属性之外，还有一个属性 type属性 1）type属性：如何到路径里面（转发还是重定向） 2 type属性值 1）默认值，做转发操作（一次请求，地址栏不变），值是 dispatcher 1&lt;result name=&quot;success&quot; type=&quot;dispatcher&quot;&gt;/world.jsp&lt;/result&gt; 2）做重定向操作（两次请求，地址栏改变），值是 redirect 1&lt;result name=&quot;success&quot; type=&quot;redirect&quot;&gt;/world.jsp&lt;/result&gt; 3）上面两个值dispatcher、redirect，这两个值一般针对到页面中配置， 配置到其他的action里面 chain：转发到action，一般不用，缓存问题 1&lt;result name=&quot;success&quot; type=&quot;chain&quot;&gt;orders&lt;/result&gt; redirectAction：重定向到action 1&lt;result name=&quot;success&quot; type=&quot;redirectAction&quot;&gt;orders&lt;/result&gt; Action获取表单提交数据1 之前web阶段，提交表单到servlet里面，在servlet里面使用request对象里面的方法获取，getParameter，getParameterMap 2 提交表单到action，但是action没有request对象，不能直接使用request对象 3 action获取表单提交数据主要三种方式 1）使用ActionContext类 2）使用ServletActionContext类 3）使用接口注入方式 使用ActionContext类获取 1）因为方法不是静态的方法，需要创建ActionContext类的对象 2）这个ActionContext类对象不是new出来的 1 具体演示 1）创建表单，提交表单到action里面 1234567&lt;%--form1.jsp--%&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/form1.action&quot; method=&quot;post&quot;&gt; username: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; password: &lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;br&gt; address: &lt;input type=&quot;text&quot; name=&quot;address&quot;&gt;&lt;br&gt; &lt;submit&gt;提交&lt;/submit&gt;&lt;/form&gt; 123456&lt;!-- struts.xml --&gt;&lt;!-- 获取表单提交的数据 --&gt;&lt;package name=&quot;demo2&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt; &lt;action name=&quot;form1&quot; class=&quot;com.demo.form.Form1Action&quot;&gt; &lt;/action&gt;&lt;/package&gt; 2）在action使用ActionContext获取数据 1234567891011121314151617181920212223242526272829303132package com.demo.form;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;import java.util.Arrays;import java.util.Map;import java.util.Set;public class Form1Action extends ActionSupport &#123; @Override public String execute() throws Exception &#123; // 第一种方式 使用ActionContext类获取数据 // 1 获取ActionContext对象 ActionContext context = ActionContext.getContext(); // 2 调用getParameters方法得到表单数据 // key是表单输入项name属性值，value是输入的值 Map&lt;String, Object&gt; map = context.getParameters(); Set&lt;String&gt; keys = map.keySet(); for (String key : keys) &#123; // 根据key得到value // 数组形式：因为输入项里面可能有复选框的情况 Object[] obj = (Object[]) map.get(key); System.out.println(Arrays.toString(obj)); &#125; return NONE; &#125;&#125; 使用ServletActionContext类获取 1 调用类里面静态方法，得到request对象 123456789101112131415161718192021222324252627282930package com.demo.form;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;import org.apache.struts2.ServletActionContext;import javax.servlet.http.HttpServletRequest;import java.util.Arrays;import java.util.Map;import java.util.Set;public class Form2Action extends ActionSupport &#123; @Override public String execute() throws Exception &#123; // 第二种方式 使用ServletActionContext获取 // 1 使用ServletActionContext获取request对象 HttpServletRequest request = ServletActionContext.getRequest(); // 2 调用request里面的方法得到结果 String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); String address = request.getParameter(&quot;address&quot;); System.out.println(&quot;username: &quot; + username + &quot;/npassword: &quot; + password + &quot;/naddress: &quot; + address); return NONE; &#125;&#125; 使用接口注入（了解）1 让action实现接口，为了得到request对象 12345678910111213141516171819202122232425262728package com.demo.form;import com.opensymphony.xwork2.ActionSupport;import org.apache.struts2.interceptor.ServletRequestAware;import javax.servlet.http.HttpServletRequest;public class Form3Action extends ActionSupport implements ServletRequestAware &#123; private HttpServletRequest request; @Override public String execute() throws Exception &#123; String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); String address = request.getParameter(&quot;address&quot;); System.out.println(&quot;username: &quot; + username + &quot;/npassword: &quot; + password + &quot;/naddress: &quot; + address); return NONE; &#125; @Override public void setServletRequest(HttpServletRequest request) &#123; this.request = request; &#125;&#125; 在action操作域对象1 request、session、servletContext域对象 2 使用ServletActionContext类操作 123456789101112// 操作三个域对象// 1 request域HttpServletRequest request = ServletActionContext.getRequest();request.getParameter(&quot;req&quot;, &quot;reqValue&quot;);// 2 session域HttpSession session = request.getSession();session.getAttribute(&quot;sess&quot;, &quot;sessValue&quot;);// 3 ServletContext域ServletContext context = ServletActionContext.getServletContext();context.setAttribute(&quot;contextname&quot;, &quot;contextValue&quot;); Struts2封装获取表单数据方式原始方式获取表单封装到实体类对象12345678910111213141516171819202122232425262728293031323334package com.demo.form;import com.demo.entity.User;import com.opensymphony.xwork2.ActionSupport;import org.apache.struts2.ServletActionContext;import javax.servlet.http.HttpServletRequest;/** * 使用ServletActionContext获取表单数据封装到实体类对象里面 */public class Form4Action extends ActionSupport &#123; @Override public String execute() throws Exception &#123; // 1 获取表单数据 HttpServletRequest request = ServletActionContext.getRequest(); String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); String address = request.getParameter(&quot;address&quot;); // 2 封装到实体类对象里面 User user = new User(); user.setUsername(username); user.setPassword(password); user.setAddress(address); System.out.println(user); return NONE; &#125;&#125; 属性封装（会用）1 直接把表单提交属性封装到action的属性里面 2 实现步骤 1）在action成员变量位置定义变量 变量名称和表单输入项的name属性值一样 2）生成变量的set方法（把set和get方法都写出来） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.demo.data;import com.opensymphony.xwork2.ActionSupport;/** * 使用属性封装获取表单数据 */public class DataDemo1Action extends ActionSupport &#123; // 1 定义变量 // 变量的名称要和表单输入项name属性值一样 private String username; private String password; private String address; // 生成变量的set和get方法 public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String execute() throws Exception &#123; System.out.println(&quot;username: &quot; + username + &quot;/npassword: &quot; + password + &quot;/naddress: &quot; + address); return NONE; &#125;&#125; 3 使用属性封装获取表单数据到属性里面，不能把数据直接封装到实体类对象里面 模型驱动封装（重点）1 使用模型驱动方式，可以直接把表单数据封装到实体类对象里面 2 实现步骤 1）action实现接口 ModelDriven 2）实现接口里面的方法 getModel方法 把创建对象返回 3）在action里面创建实体类对象 前提要求：表单输入项name属性值 和 实体类属性名称 一样 12345678910111213141516171819202122232425262728293031package com.demo.data;import com.demo.entity.User;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.ModelDriven;/** * 使用模型驱动的方式获取表单数据 */public class DataDemo2Action extends ActionSupport implements ModelDriven&lt;User&gt; &#123; @Override public String execute() throws Exception &#123; System.out.println(user); return NONE; &#125; // 创建对象 // 前提要求：表单输入项name属性值 和 实体类属性名称 一样 private User user = new User(); @Override public User getModel() &#123; // 返回创建的user对象 return user; &#125;&#125; 3 使用模型驱动和属性封装注意问题： 1）在一个action中，获取表单数据可以属性封装，使用模型驱动封装， 不能同时使用属性封装和模型驱动封装获取同一个表单数据 如果同时使用，之后执行模型驱动 表达式封装（会用）1 实现过程 1）使用表达式封装可以把表单数据封装到实体类对象里面 第一步 在action里面声明实体类 第二步 生成实体类变量的set和get方法 12345678910111213141516171819202122232425262728293031package com.demo.data;import com.demo.entity.User;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.ModelDriven;/** * 使用 表达式封装 的方式获取表单数据 */public class DataDemo3Action extends ActionSupport &#123; // 1 声明实体类 private User user; // 2 生成实体类变量的set和get方法 public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; @Override public String execute() throws Exception &#123; System.out.println(user); return NONE; &#125;&#125; 第三步 在表单输入项的name属性值里面写表达式形式 123456&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/data3.action&quot; method=&quot;post&quot;&gt; username: &lt;input type=&quot;text&quot; name=&quot;user.username&quot;&gt;&lt;br&gt; password: &lt;input type=&quot;text&quot; name=&quot;user.password&quot;&gt;&lt;br&gt; address: &lt;input type=&quot;text&quot; name=&quot;user.address&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 2 把表达式封装归类到属性封装里面 比较表达式封装和模型驱动封装1 使用表达式封装和模型驱动封装都可以把数据封装到实体类对象里面 2 不同点 1）使用模型驱动只能把数据封装到一个实体类对象里面 在一个action里面不能使用模型驱动把数据封装到不同的实体类对象里面 2）使用表达式封装可以把数据封装到不同的实体类对象里面 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.demo.data;import com.demo.entity.Book;import com.demo.entity.User;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.ModelDriven;/** * 使用 表达式封装 的方式获取表单数据 */public class DataDemo3Action extends ActionSupport &#123; // 1 声明实体类 private User user; private Book book; // 2 生成实体类变量的set和get方法 public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public Book getBook() &#123; return book; &#125; public void setBook(Book book) &#123; this.book = book; &#125; @Override public String execute() throws Exception &#123; System.out.println(user); System.out.println(book); return NONE; &#125;&#125; 1234567&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/data3.action&quot; method=&quot;post&quot;&gt; username: &lt;input type=&quot;text&quot; name=&quot;user.username&quot;&gt;&lt;br&gt; password: &lt;input type=&quot;text&quot; name=&quot;user.password&quot;&gt;&lt;br&gt; address: &lt;input type=&quot;text&quot; name=&quot;user.address&quot;&gt;&lt;br&gt; bname: &lt;input type=&quot;text&quot; name=&quot;book.bname&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 封装到集合里面封装数据到List集合1 在action声明List 2 生成list变量的set和get方法 1234567891011121314151617181920212223242526272829303132package com.demo.data;import com.demo.entity.User;import com.opensymphony.xwork2.ActionSupport;import java.util.List;/** * 封装数据到list集合 */public class ListAction extends ActionSupport &#123; // 1 声明List变量 public List&lt;User&gt; list; // 2 生成list变量的set和get方法 public List&lt;User&gt; getList() &#123; return list; &#125; public void setList(List&lt;User&gt; list) &#123; this.list = list; &#125; @Override public String execute() throws Exception &#123; System.out.println(list); return NONE; &#125;&#125; 3 在表单输入项里面写表达式 123456789&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/list.action&quot; method=&quot;post&quot;&gt; username: &lt;input type=&quot;text&quot; name=&quot;list[0].username&quot;&gt;&lt;br&gt; password: &lt;input type=&quot;text&quot; name=&quot;list[0].password&quot;&gt;&lt;br&gt; address: &lt;input type=&quot;text&quot; name=&quot;list[0].address&quot;&gt;&lt;br&gt; username: &lt;input type=&quot;text&quot; name=&quot;list[1].username&quot;&gt;&lt;br&gt; password: &lt;input type=&quot;text&quot; name=&quot;list[1].password&quot;&gt;&lt;br&gt; address: &lt;input type=&quot;text&quot; name=&quot;list[1].address&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 封装数据到Map集合1 声明map集合 2 生成get和set方法 12345678910111213141516171819202122232425262728293031323334package com.demo.data;import com.demo.entity.User;import com.opensymphony.xwork2.ActionSupport;import java.util.Map;/** * 封装数据到map集合 */public class MapAction extends ActionSupport &#123; // 1 声明map变量 public Map&lt;String, User&gt; map; // 2 生成map变量的set和get方法 public Map&lt;String, User&gt; getMap() &#123; return map; &#125; public void setMap(Map&lt;String, User&gt; map) &#123; this.map = map; &#125; @Override public String execute() throws Exception &#123; System.out.println(map); return NONE; &#125;&#125; 3 在表单输入项的name属性值里面写表达式 123456789101112&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/map.action&quot; method=&quot;post&quot;&gt; &lt;%-- 设置key值map[&#x27;key值&#x27;] 设置value值 --%&gt; username: &lt;input type=&quot;text&quot; name=&quot;map[&#x27;one&#x27;].username&quot;&gt;&lt;br&gt; password: &lt;input type=&quot;text&quot; name=&quot;map[&#x27;one&#x27;].password&quot;&gt;&lt;br&gt; address: &lt;input type=&quot;text&quot; name=&quot;map[&#x27;one&#x27;].address&quot;&gt;&lt;br&gt; username: &lt;input type=&quot;text&quot; name=&quot;map[&#x27;two&#x27;].username&quot;&gt;&lt;br&gt; password: &lt;input type=&quot;text&quot; name=&quot;map[&#x27;two&#x27;].password&quot;&gt;&lt;br&gt; address: &lt;input type=&quot;text&quot; name=&quot;map[&#x27;two&#x27;].address&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 封装数据总结1 属性封装 定义变量，变量和表单输入项name属性值一样，生成get和set方法 2 模型驱动封装（重点） 实现接口，实现接口里面的方法，表单输入项name属性值和实体类属性名称一样 3 表达式封装 4 表达式封装和模型驱动封装比较 相同点：可以把数据封装到实体类对象里面 不同点：表达式封装可以封装到不同的实体类里面 案例-添加客户功能1 模型驱动获取表单数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.demo.action;import java.util.List;import javax.servlet.http.HttpServletRequest;import com.opensymphony.xwork2.ModelDriven;import org.apache.struts2.ServletActionContext;import com.opensymphony.xwork2.ActionSupport;import com.demo.entity.Customer;import com.demo.service.CustomerService;public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; private Customer customer = new Customer(); @Override public Customer getModel() &#123; return customer; &#125; // 添加客户 public String addCustomer() &#123; // 调用service的方法添加到数据库 CustomerService service = new CustomerService(); service.addCustomer(customer); return &quot;addCustomer&quot;; &#125; // 到添加页面 public String toAddPage() &#123; return &quot;toAddPage&quot;; &#125; //客户列表 public String list() &#123; //调用service CustomerService service = new CustomerService(); List&lt;Customer&gt; list = service.findAll(); //放到域对象里面（明天讲到） HttpServletRequest request = ServletActionContext.getRequest(); request.setAttribute(&quot;list&quot;, list); return &quot;list&quot;; &#125;&#125; 2 在hibernate实现 123456789101112131415161718192021222324252627// 添加客户的方法@Overridepublic void addCustomer(Customer customer) &#123; SessionFactory sessionFactory = null; Session session = null; Transaction tx = null; try &#123; sessionFactory = HibernateUtils.getSessionFactory(); session = sessionFactory.openSession(); tx = session.beginTransaction(); // 添加代码 // 返回值：添加到数据库里面，生成id值，返回id值 Serializable id = session.save(customer); if (id != null)&#123; System.out.println(&quot;success&quot;); &#125;else&#123; System.out.println(&quot;fail&quot;); &#125; tx.commit(); &#125;catch (Exception e)&#123; tx.rollback(); &#125;finally &#123; session.close(); &#125;&#125; 3 添加之后到列表页面中，让列表的action执行一次 12345&lt;!-- 添加之后到列表页面 请求一次列表的action type属性：chain会有缓存问题，一般使用redirectAction --&gt;&lt;result name=&quot;addCustomer&quot; type=&quot;redirectAction&quot;&gt;customer_list&lt;/result&gt; OGNL概述1 之前web阶段，学习过EL表达式，EL表达式在jsp中获取域对象里面的值 2 OGNL是一种表达式，这个表达式功能更加强大 1）在struts2里面操作值栈数据 2）一般把ognl在struts2操作：和struts2标签一起使用操作值栈 3 OGNL不是struts2的一部分，单独的项目，经常和struts2一起使用 1）使用ognl时候首先导入jar包，struts2提供jar包 OGNL入门案例1 使用ognl+struts2标签实现计算字符串长度 1）在java代码中，调用字符串.length(); 2 使用struts2标签 1）使用jstl时候，导入jar包之外，在jsp页面中引入标签库 使用struts2标签时候，在jsp中引入标签库 1&lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt; 2）使用struts2标签实现操作 1&lt;s:property value=&quot;&#x27;haha&#x27;.length()&quot;/&gt; 什么是值栈1 之前在web阶段，在servlet里面进行操作，把数据放到域对象里面，在页面中使用el表达式获取到，域对象在一定范围内，存值和取值 2 在struts2里面提供本身一种存储机制，类似于域对象，是值栈，可以存值和取值 1）在action里面把数据放到值栈里面，在页面中获取到值栈数据 3 servlet和action区别 1）Servlet：默认在第一次访问时候创建，创建一次，单实例对象 2）Action：访问时候创建，每次访问action时候，都会创建action对象，创建多次，多实例对象 4 值栈存储位置 1）每次访问action时候，都会创建action对象， 2）在每个action对象里面都会有一个值栈对象（只有一个） 获取值栈对象1 获取值栈对象有多种方式 1）常用方式：使用ActionContext类里面的方法得到值栈对象 12345// 1 获取ActionContext类的对象ActionContext context = ActionContext.getContext();// 2 调用方法得到值栈对象ValueStack stack1 = context.getValueStack(); 2 每个action对象中只有一个值栈对象 12345678// 1 获取ActionContext类的对象ActionContext context = ActionContext.getContext();// 2 调用方法得到值栈对象ValueStack stack1 = context.getValueStack();ValueStack stack2 = context.getValueStack();System.out.println(stack1 == stack2); // true 3 栈的结构 值栈内部结构1 值栈分为两部分： 第一部分 root，结构是list集合 1）一般操作都是root里面数据 第二部分 context，结构map集合 2 struts2里面标签 s:debug，使用这个标签可以查看值栈结构和存储值 1）访问action，执行action的方法有返回值，配置返回值到jsp页面中，在jsp页面中使用这个标签 点击超链接看到结构 2）在action没有做任何操作，栈顶元素是 action引用 com.demo.action.ValueStackAction action对象里面有值栈对象 值栈对象里面有action引用 向值栈放数据1 向值栈放数据多种方式 第一种 获取值栈对象，调用值栈对象里面的 set 方法 123456// 第一种 获取值栈对象，调用值栈对象里面的 set 方法// 1 获取值栈对象ActionContext context = ActionContext.getContext();ValueStack valueStack = context.getValueStack();// 2 调用值栈对象里面的 set 方法valueStack.set(&quot;username&quot;,&quot;zoey&quot;); ![获取值栈对象，调用值栈对象里面的 set 方法](/struts2/获取值栈对象，调用值栈对象里面的 set 方法.png) 第二种 获取值栈对象，调用值栈对象里面的 push方法 123456// 第二种 获取值栈对象，调用值栈对象里面的 push方法// 1 获取值栈对象ActionContext context = ActionContext.getContext();ValueStack valueStack = context.getValueStack();// 2 调用值栈对象里面的 push方法valueStack.push(&quot;aaaA&quot;); ![获取值栈对象，调用值栈对象里面的 push方法](/struts2/获取值栈对象，调用值栈对象里面的 push方法.png) 第三种 在action定义变量，生成变量的get方法（重点） 123456789101112// 1 定义变量private String name;// 2 生成get方法public String getName() &#123; return name;&#125;@Overridepublic String execute() throws Exception &#123; // 3 在执行的方法里面向变量设置值 name = &quot;jisoo&quot;;&#125; 向值栈放对象1 定义对象变量 2 生成变量的get方法 3 在执行的方法里面向对象中设置值 1234567891011121314151617181920212223242526package com.demo.action;import com.demo.entity.User;import com.opensymphony.xwork2.ActionSupport;public class ObjectDemoAction extends ActionSupport &#123; // 1 定义对象变量 private User user = new User(); // 2 生成变量的get方法 public User getUser() &#123; return user; &#125; @Override public String execute() throws Exception &#123; // 3 在执行的方法里面向对象中设置值 user.setUsername(&quot;aaa&quot;); user.setPassword(&quot;aaa&quot;); user.setAddress(&quot;aaa&quot;); return &quot;success&quot;; &#125;&#125; 向值栈放list集合1 定义list集合变量 2 生成变量的get方法 3 在执行的方法里面向list集合设置值 1234567891011121314151617181920212223242526272829303132333435363738package com.demo.action;import com.demo.entity.User;import com.opensymphony.xwork2.ActionSupport;import java.util.ArrayList;import java.util.List;public class ListDemoAction extends ActionSupport &#123; // 1 定义list集合变量 private List&lt;User&gt; list = new ArrayList&lt;&gt;(); // 2 生成变量的get方法 public List&lt;User&gt; getList() &#123; return list; &#125; @Override public String execute() throws Exception &#123; // 3 在执行的方法里面向list集合设置值 User user1 = new User(); user1.setUsername(&quot;111&quot;); user1.setPassword(&quot;111&quot;); user1.setAddress(&quot;111&quot;); User user2 = new User(); user2.setUsername(&quot;222&quot;); user2.setPassword(&quot;222&quot;); user2.setAddress(&quot;222&quot;); list.add(user1); list.add(user2); return &quot;success&quot;; &#125;&#125; 从值栈获取数据1 使用struts2的标签+ognl表达式获取值栈数据 1）&lt;s:property value=”ognl表达式”/&gt; 获取字符串1 向值栈放字符串 1234567891011121314151617181920package com.demo.valuestack;import com.opensymphony.xwork2.ActionSupport;public class ValueStackAction extends ActionSupport &#123; private String username; public String getUsername() &#123; return username; &#125; @Override public String execute() throws Exception &#123; username = &quot;hahahaha&quot;; return &quot;success&quot;; &#125;&#125; 2 在jsp使用struts2标签+ognl表达式获取 12&lt;%--获取字符串值--%&gt;&lt;s:property value=&quot;username&quot;/&gt; 获取对象1 向值栈放对象 123456789101112private User user &#x3D; new User();public User getUser() &#123; return user;&#125;@Overridepublic String execute() throws Exception &#123; user.setUsername(&quot;aaa&quot;); user.setPassword(&quot;aaa&quot;); user.setAddress(&quot;aaa&quot;); return &quot;success&quot;;&#125; 2 在页面中获取值 1234&lt;%--获取对象的值--%&gt;&lt;s:property value=&quot;user.username&quot;/&gt;&lt;br&gt;&lt;s:property value=&quot;user.password&quot;/&gt;&lt;br&gt;&lt;s:property value=&quot;user.address&quot;/&gt;&lt;br&gt; 获取list集合第一种方式： 123456789&lt;%--获取list的值--%&gt;&lt;%--第一种方式--%&gt;&lt;s:property value=&quot;list[0].username&quot;/&gt;&lt;s:property value=&quot;list[0].password&quot;/&gt;&lt;s:property value=&quot;list[0].address&quot;/&gt;&lt;br&gt;&lt;s:property value=&quot;list[1].username&quot;/&gt;&lt;s:property value=&quot;list[1].password&quot;/&gt;&lt;s:property value=&quot;list[1].address&quot;/&gt; 第二种方式： 12345678&lt;%--第二种方式--%&gt;&lt;s:iterator value=&quot;list&quot;&gt; &lt;%-- 遍历list，得到list里面每个user对象 --%&gt; &lt;s:property value=&quot;username&quot;/&gt; &lt;s:property value=&quot;password&quot;/&gt; &lt;s:property value=&quot;address&quot;/&gt; &lt;br&gt;&lt;/s:iterator&gt; 第三种方式： 123456789101112&lt;%--第三种方式--%&gt;&lt;s:iterator value=&quot;list&quot; var=&quot;user&quot;&gt; &lt;%-- 遍历值栈list集合，得到每个user对象 机制：把每次遍历出来的user对象放到context里面 获取context里面数据特点：写ognl表达式，使用特殊符号# --%&gt; &lt;s:property value=&quot;#user.username&quot;/&gt; &lt;s:property value=&quot;#user.password&quot;/&gt; &lt;s:property value=&quot;#user.address&quot;/&gt; &lt;br&gt;&lt;/s:iterator&gt; 其他操作1 使用set方法向值栈放数据，获取 12// 2 调用值栈对象里面的 set 方法valueStack.set(&quot;username&quot;,&quot;zoey&quot;); 12&lt;%--获取set方法设置的值 根据名称获取值--%&gt;&lt;s:property value=&quot;username&quot;/&gt; 2 使用push方法向值栈放数据，获取 12// 调用值栈对象里面的 push方法valueStack.push(&quot;aaaA&quot;); 1）使用push方法设置值，没有名称，只有设置的值 2）向值栈放数据，把向值栈放数据存到数组里面，数组名称 top，根据数组获取值 1&lt;s:property value=&quot;[0].top&quot;/&gt; EL表达式获取值栈数据（为什么）1 EL表达式获取域对象值 2 向域对象里面放值使用setAttribute方法，获取值使用getAttribute方法 3 底层增强request对象里面的方法getAttribute方法 1）首先从request域获取值，如果获取到，直接返回 2）如果从request域获取不到值，到值栈中把值获取出来，把值放到域对象里面 OGNL的#、%使用#使用1 使用#获取context里面数据 123456789101112&lt;%--第三种方式--%&gt;&lt;s:iterator value=&quot;list&quot; var=&quot;user&quot;&gt; &lt;%-- 遍历值栈list集合，得到每个user对象 机制：把每次遍历出来的user对象放到context里面 获取context里面数据特点：写ognl表达式，使用特殊符号# --%&gt; &lt;s:property value=&quot;#user.username&quot;/&gt; &lt;s:property value=&quot;#user.password&quot;/&gt; &lt;s:property value=&quot;#user.address&quot;/&gt; &lt;br&gt;&lt;/s:iterator&gt; 2 演示# 操作 1）向request域放值 2）在页面中使用ognl获取 12345&lt;%--获取context里面数据，写ognl时候，首先添加符号#context的key名称.域对象名称--%&gt;&lt;s:property value=&quot;#request.req&quot;/&gt; %使用1 在struts2标签中表单标签 1）在struts2标签里面使用ognl表达式，如果直接在struts2表单标签里面使用ognl表达式不识别，只有%之后才会识别 1&lt;s:textfield name=&quot;username&quot; value=&quot;%&#123;#request.req&#125;&quot;/&gt; 案例-列表功能改造（值栈）1234567891011121314151617181920 // 1 定义list变量，get方法 private List&lt;Customer&gt; list; public List&lt;Customer&gt; getList() &#123; return list; &#125; //客户列表 public String list() &#123; //调用service CustomerService service = new CustomerService(); // 返回数据放到值栈的list里面 list = service.findAll(); //放到域对象里面（明天讲到）// HttpServletRequest request = ServletActionContext.getRequest();// request.setAttribute(&quot;list&quot;, list); return &quot;list&quot;; &#125; 1234567891011121314151617181920212223242526&lt;%-- 使用struts2标签+ognl实现 --%&gt;&lt;s:iterator value=&quot;list&quot; var=&quot;customer&quot;&gt; &lt;TR style=&quot;FONT-WEIGHT: normal; FONT-STYLE: normal; BACKGROUND-COLOR: white; TEXT-DECORATION: none&quot;&gt; &lt;TD&gt; &lt;s:property value=&quot;#customer.custName&quot;/&gt; &lt;/TD&gt; &lt;TD&gt; &lt;s:property value=&quot;#customer.custLevel&quot;/&gt; &lt;/TD&gt; &lt;TD&gt; &lt;s:property value=&quot;#customer.custSource&quot;/&gt; &lt;/TD&gt; &lt;TD&gt; &lt;s:property value=&quot;#customer.custPhone&quot;/&gt; &lt;/TD&gt; &lt;TD&gt; &lt;s:property value=&quot;#customer.custMobile&quot;/&gt; &lt;/TD&gt; &lt;TD&gt; &lt;/TD&gt; &lt;/TR&gt;&lt;/s:iterator&gt; Struts2拦截器概述1 struts2是框架，封装了很多的功能，struts2里面封装的功能都是在拦截器里面 2 struts2里面封装了很多的功能，有很多拦截器，不是每次这些拦截器都执行，每次执行默认的拦截器 3 struts2里面默认拦截器位置 struts2-core-2.3.24.jar struts-default.xml 12345678910111213&lt;!-- Basic stack --&gt;&lt;interceptor-stack name=&quot;basicStack&quot;&gt; &lt;interceptor-ref name=&quot;exception&quot;/&gt; &lt;interceptor-ref name=&quot;servletConfig&quot;/&gt; &lt;interceptor-ref name=&quot;prepare&quot;/&gt; &lt;interceptor-ref name=&quot;checkbox&quot;/&gt; &lt;interceptor-ref name=&quot;datetime&quot;/&gt; &lt;interceptor-ref name=&quot;multiselect&quot;/&gt; &lt;interceptor-ref name=&quot;actionMappingParams&quot;/&gt; &lt;interceptor-ref name=&quot;params&quot;/&gt; &lt;interceptor-ref name=&quot;conversionError&quot;/&gt; &lt;interceptor-ref name=&quot;deprecation&quot;/&gt;&lt;/interceptor-stack&gt; 4 拦截器在什么时候执行？ 1）在action对象创建之后，action的方法执行之前 拦截器底层原理拦截器底层使用两个原理1 aop思想 1）文字描述： Aop是面向切面（方面）编程，有基本功能，扩展功能，不通过修改源代码方式扩展功能 2）画图分析： 2 责任链模式 1）在java中有很多的设计模式，责任链模式是其中的一种 2）责任链模式和过滤链很相似的 责任链模式： 要执行多个操作，有添加、修改、删除三个操作。 首先执行添加操作，添加操作执行之后 做类似于放行操作，执行修改操作，修改操作执行之后做类似于放行操作，执行删除操作 过滤链：一个请求可有多个过滤器进行过滤，每个过滤器只有做放行才能到下一个过滤器 aop思想和责任链模式如何应用到拦截器里面？1 文字描述： 拦截器在action对象创建之后，action的方法执行之前执行 在action方法执行之前执行默认拦截器，执行过程使用aop思想，在action没有直接调用拦截器的方法，使用配置文件方式进行操作 在执行拦截器时候，执行很多的拦截器，这个过程使用责任链模式 假如执行三个拦截器，执行拦截器1，执行拦截器1之后做放行操作，执行拦截器2，执行拦截器2之后做放行，执行拦截器3，执行拦截器3之后放行，执行action的方法 2 画图分析 3 查看源代码 1）执行action 2）创建action对象，使用动态代理方式 3）执行action的方法 4）执行很多的拦截器，遍历执行 类似于放行的操作的方法 重要的概念过滤器和拦截器区别1 过滤器：过滤器理论上可以任意内容，比如html、jsp、servlet、图片路径 2 拦截器：拦截器只可以拦截action Servlet和action区别1 servlet默认第一次访问时候创建，创建一次，单实例对象 2 action每次访问时候创建，创建多次，多实例对象 自定义拦截器1 在struts2里面有很多的拦截器，这些拦截器是struts2封装的功能，但是在实际开发中，struts2里面的拦截器中可以没有要使用的功能，这个时候需要自己写拦截器实现功能 1）查看源代码看拦截器结构 继承类 12public class ModelDrivenInterceptor extends AbstractInterceptor &#123;public abstract class AbstractInterceptor implements Interceptor &#123; 在接口里面有三个方法 12345678public void init() &#123; // 初始化操作&#125;public void destroy() &#123; // 销毁&#125;public abstract String intercept(ActionInvocation var1) throws Exception; // 拦截逻辑的操作 2）开发中，建议使用另外一种方式 写类，继承 MethodFilterInterceptor类实现 让action里面某个的方法不进行拦截 3）让拦截器和action有关系 不是在action调用拦截器的方法，而是通过配置文件方式让建立关系 自定义登录拦截器1 需求：在项目中，有很多的action的超链接，实现只有是登录的状态，才可以点击action的超链接实现功能，如果不是登录状态，点击action超链接返回到登录页面 2 登录的状态：使用session域对象实现 1）登录成功之后，把数据放到session里面 2）判断session是否有值，可以知道是否是登录状态 3 实现登录的基本功能 1）查询数据库判断用户名和密码 12345678910111213141516171819202122232425// 登录 public String login()&#123; // 1 得到request对象 HttpServletRequest request = ServletActionContext.getRequest(); String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); // 2 查询数据库判断用户名和密码是否正确 CustomerService service = new CustomerService(); User user = new User(); user.setUser_name(username); user.setUser_password(password); boolean flag = service.login(user);// System.out.println(flag); if (flag == true)&#123; // 成功 // 向session里面传入值 request.getSession().setAttribute(&quot;username&quot;, username); return &quot;loginsuccess&quot;; &#125;else&#123; // 失败 return &quot;login&quot;; &#125; &#125; 4 添加登录拦截器功能 1）判断是否登录：判断session里面是否有名称是username的值 2）拦截器实现过程 第一步 创建类，继承MethodFilterInterceptor类 第二步 重写MethodFilterInterceptor类里面的方法写拦截器逻辑 12345678910111213141516171819202122package com.demo.interceptor;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.MethodFilterInterceptor;import org.apache.struts2.ServletActionContext;import javax.servlet.http.HttpServletRequest;/** * 拦截器类 */public class LoginInterceptor extends MethodFilterInterceptor &#123; // 这个方法里面写拦截器逻辑 @Override protected String doIntercept(ActionInvocation actionInvocation) throws Exception &#123; return null; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738package com.demo.interceptor;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.MethodFilterInterceptor;import org.apache.struts2.ServletActionContext;import javax.servlet.http.HttpServletRequest;/** * 拦截器类 */public class LoginInterceptor extends MethodFilterInterceptor &#123; // 这个方法里面写拦截器逻辑 @Override protected String doIntercept(ActionInvocation actionInvocation) throws Exception &#123; // 判断session里面是否有名称是username的值 // 得到session HttpServletRequest request = ServletActionContext.getRequest(); Object obj = request.getSession().getAttribute(&quot;username&quot;); // 判断 if (obj != null) &#123; // 登录状态 // 做类似于放行操作，执行action的方法 return actionInvocation.invoke(); &#125; else &#123; // 不是登录状态 // 不到登录，不执行action的方法，返回登录页面 // 到result标签里面找到名称是login的值，到配置路径里面 return &quot;login&quot;; &#125; &#125;&#125; 第三步 配置action和拦截器关系（注册拦截器） 1）在要拦截的action标签所在的package标签里面声明拦截器 1234&lt;!-- 声明拦截器 --&gt;&lt;interceptors&gt; &lt;interceptor name=&quot;loginintercept&quot; class=&quot;com.demo.interceptor.LoginInterceptor&quot;&gt;&lt;/interceptor&gt;&lt;/interceptors&gt; 2）在具体的action标签里面使用声明的拦截器 12&lt;!-- 使用自定义拦截器 --&gt;&lt;interceptor-ref name=&quot;loginintercept&quot;&gt;&lt;/interceptor-ref&gt; 3）struts2里面执行很多的默认拦截器，但是如果在action里面配置自定义拦截器， 问题：默认的拦截器不会执行了 解决：把默认拦截器手动使用一次 12&lt;!-- 把默认拦截器手动使用一次 --&gt;&lt;interceptor-ref name=&quot;defaultStack&quot;&gt;&lt;/interceptor-ref&gt; 5 配置拦截器，对action里面所有的方法都进行拦截 1）在action里面有login的登录的方法，这个方法不需要拦截，如果这个方法都拦截，问题是，永远登录不进去了 2）解决：让login方法不进行拦截 直接通过配置方式让action里面某些方法不进行拦截 12345678&lt;!-- 使用自定义拦截器 --&gt;&lt;interceptor-ref name=&quot;loginintercept&quot;&gt; &lt;!-- 配置action里面某些方法不进行拦截 name属性值：excludeMethods 值：action不拦截的方法名称 --&gt; &lt;param name=&quot;excludeMethods&quot;&gt;login&lt;/param&gt;&lt;/interceptor-ref&gt; 6 如果登录状态，直接到功能页面，如果不是登录显示登陆页面 登录之后出现小问题： 1）设置打开位置，在form标签里面 1target=&quot;_parent&quot; Struts2的标签库0 struts2标签使用jsp页面中 1 s:property： 和ognl表达式在jsp页面中获取值栈数据 2 s:iterator: 获取值栈list集合数据，表示list集合 3 s:debug: 查看值栈结构和数据 Struts2表单标签（会用）1 html表单标签 1）form : action、method、enctype 2）输入项 大部分在input里面封装 type=”值” text：普通输入项 password：密码输入项 radio：单选输入项 checkbox：复选输入项 file：文件上传项 hidden：隐藏项 button：普通按钮 submit：提交按钮 image：图片提交 reset：重置 select：下拉输入项 textarea：文本域 2 在struts2里面对应html表单标签大部分都有 123456789101112131415161718192021222324252627282930313233343536&lt;!-- form标签 --&gt;&lt;s:form&gt; &lt;!-- 1 普通输入项 --&gt; &lt;s:textfield name=&quot;username&quot; label=&quot;username&quot;&gt;&lt;/s:textfield&gt; &lt;!-- 2 密码输入项 --&gt; &lt;s:password name=&quot;password&quot; label=&quot;password&quot;&gt;&lt;/s:password&gt; &lt;!-- 3 单选输入项 --&gt; &lt;!-- value属性值和显示值一样的 --&gt; &lt;s:radio list=&quot;&#123;&#x27;女&#x27;,&#x27;男&#x27;&#125;&quot; name=&quot;sex&quot; label=&quot;性别&quot;&gt;&lt;/s:radio&gt; &lt;!-- value属性值和显示值不一样的 --&gt; &lt;s:radio list=&quot;#&#123;&#x27;nv&#x27;:&#x27;女&#x27;,&#x27;nan&#x27;:&#x27;男&#x27;&#125;&quot; name=&quot;sex1&quot; label=&quot;性别&quot;&gt;&lt;/s:radio&gt; &lt;!-- 4 复习输入项 --&gt; &lt;s:checkboxlist list=&quot;&#123;&#x27;吃饭&#x27;,&#x27;睡觉&#x27;,&#x27;敲代码&#x27;&#125;&quot; name=&quot;love&quot; label=&quot;爱好&quot;&gt;&lt;/s:checkboxlist&gt; &lt;!-- 5 下拉输入框 --&gt; &lt;s:select list=&quot;&#123;&#x27;幼儿园&#x27;,&#x27;博士后&#x27;,&#x27;教授&#x27;&#125;&quot; name=&quot;college&quot; label=&quot;学历&quot;&gt;&lt;/s:select&gt; &lt;!-- 6 文件上传项 --&gt; &lt;s:file name=&quot;file&quot; label=&quot;上传文件&quot;&gt;&lt;/s:file&gt; &lt;!-- 7 隐藏项 --&gt; &lt;s:hidden name=&quot;hid&quot; value=&quot;abcd&quot;&gt;&lt;/s:hidden&gt; &lt;!-- 文本域 --&gt; &lt;s:textarea rows=&quot;10&quot; cols=&quot;3&quot; name=&quot;resume&quot; label=&quot;简历&quot;&gt;&lt;/s:textarea&gt; &lt;!-- 8 提交按钮 --&gt; &lt;s:submit value=&quot;提交&quot;&gt;&lt;/s:submit&gt; &lt;!-- 9 重置 --&gt; &lt;s:reset value=&quot;重置&quot;&gt;&lt;/s:reset&gt;&lt;/s:form&gt; ssh练习中的两个知识点struts2文件上传错误处理机制 inputStruts2总结1 Action 1）action创建（继承ActionSupport类） 2）配置访问action的方法（通配符） 3）action获取表单数据 模型驱动 4）action操作域对象 5）result标签里面type属性 2 值栈 1）值栈结构 2）向值栈放数据 3）从值栈获取数据 3 拦截器 1）拦截器原理 2）自定义拦截器 继承类 写拦截器逻辑 配置拦截器 配置让action某些方法不进行拦截 ERROR#1struts.xml中extends=”struts-default”报错提示：此种解决方法只适用于Intellij IDEA，MyEclipse或者Eclipse还得另寻它法，但估计原因应该是类似的。 在Intellij IDEA 2017使用Struts2框架时，若新建项目时并未导入Struts2框架而是在后期手动新建lib目录导入Struts2框架后，可能出现在配置struts.xml时**extends=”struts-default”**会报错，如下图： 显示的错误为Cannot resolve Struts Package ‘struts-default’. Validates struts.xml files for syntactic and reference errors，原因是引用struts-default错误，解决的方法：依次打开File &gt; Project Structure &gt; Facets &gt; Struts2，点击铅笔进行修改，勾选上Struts2-core-2.3.24.jar即可，struts-default.xml会被自动勾选上，保存设置即可： ERROR#2访问路径问题 发现URL变为：http://localhost:8080/demostruts2_war_exploded/中间多了：_war_exploded/解决方法：打开idea-》run–》edit Configurations-》ApplicationContext: / idea和eclipse的区别 当我们使用 eclipse 开发 web 项目时，项目的路径一般是 localhost:8080/项目名，不同的项目对应的项目名不一样，而在使用 idea 的时候，访问时的路径直接就变成了 localhost:8080，项目名没有了 首先明确一点：idea 中项目的访问路径是可以自定义的，方法如下 Run —&gt; Edit Configurations —&gt; Deployment 在右侧的 Application context 中填入访问时的路径，这个路径是从8080后面开始的，包括斜杠 为什么用 idea 的时候只需要输入 localhost:8080 就可以访问到项目，这是因为 idea 为每个项目都单独配置了 tomcat，而 eclipse 是把多个项目都统一放到一个 tomcat 中。我们都知道，tomcat 在发布项目的时候一般都是把项目放在 webapps 里面，所以如果 webapps 里面有多个项目，那么我们访问不同的项目时就需要以项目名来区分，而只有一个的话就不需要了，所以在访问路径上就出现了差别 struts2动态方法调用 在动态方法调用时，方式之一就是通过在浏览器地址栏中输入 ! 加不同的方法名来访问不同的方法，如果使用的是 idea 编辑器，访问路径就应该是这样的，如 也就是说，在我们配置的访问路径之后加上配置文件中配置的相应的值 特别注意：不管是不是用了动态方法调用，在路径的最后都别再加斜杠了，自己曾经因为这个被坑得很惨，特此提醒一下 ERROR#3自定义页面404 Project Structure -&gt; Project Settings -&gt; Artifacts -&gt; 把里面的删除重新添加一下 Add -&gt; Web Application:Exploded -&gt; From Modules… -&gt; select -&gt; ok","categories":[{"name":"java","slug":"java","permalink":"https://supertramp7.github.io/categories/java/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"https://supertramp7.github.io/tags/ssh/"},{"name":"java","slug":"java","permalink":"https://supertramp7.github.io/tags/java/"},{"name":"struts2","slug":"struts2","permalink":"https://supertramp7.github.io/tags/struts2/"},{"name":"框架","slug":"框架","permalink":"https://supertramp7.github.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"Spring知识点","slug":"spring","date":"2022-03-08T00:54:30.000Z","updated":"2022-04-06T12:19:38.736Z","comments":true,"path":"spring/","link":"","permalink":"https://supertramp7.github.io/spring/","excerpt":"","text":"Spring 概念 1 spring是开源的轻量级框架 2 spring核心主要两部分： 1）ioc：控制反转，比如有一个类，在类里面有方法（不是静态方法），创建类的对象，使用对象调用方法，创建类对象的过程，需要new出来对象 把对象的创建不是通过new方式实现，而是交给spring配置创建类对象 2）aop：面向切面编程，扩展功能不是修改源代码实现 3 spring是一站式框架 1）spring 在 javaee三层结构中，每一层都提供不同的解决技术 web：springMVC service：spring的ioc dao：spring的jdbcTemplate 4 spring版本 hibernate5.x spring4.x Spring的ioc操作 1 把对象的创建交给spring进行管理 2 ioc操作两部分： 1）ioc的配置文件方式 2）ioc的注解方式 ioc底层原理1 ioc底层原理使用技术 1）xml配置文件 2）dom4j解决xml 3）工厂设计模式 4）反射 2 图解 ioc过程1： ioc过程2： ioc入门案例第一步 导入jar包 第二步 创建类，在类里面创建方法 12345678910111213public class User &#123; public void add() &#123; System.out.println(&quot;add&quot;); &#125; public static void main(String[] args) &#123;// 原始方法 User user = new User(); user.add(); &#125;&#125; 第三步 创建spring配置文件，配置创建类 1）spring核心配置文件名称和位置不是固定的，建议放在src下面，官方建议applicationContext.xml 2）引入schema约束 1234567891011121314&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd&quot; &lt;/beans&gt; 3）配置对象创建 12&lt;!-- ioc入门 --&gt; &lt;bean id=&quot;user&quot; class=&quot;com.z.ioc.User&quot;&gt;&lt;/bean&gt; 第四步 写代码测试对象创建 123456789@Testpublic void testUser() &#123; // 1. 加载spring配置文件，根据创建对象 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;); // 2. 得到配置创建的对象 User user = (User)context.getBean(&quot;user&quot;); System.out.println(user); user.add();&#125; 配置文件没有提示问题spring引入schema约束，把约束文件引入到eclipse中 1）复制约束路径 1http://www.springframework.org/schema/beans/spring-beans-3.2.xsd 2）引入到eclipse中 Spring的bean管理（xml配置文件） 1 bean实例化三种方式 2 bean标签常用属性 3 属性注入方式介绍 4 spring注入属性（有参构造和set方法） 5 spring注入对象类型属性（重点） 6 p名称空间注入 7 spring注入复杂数据 bean实例化三种方式 在spring里面通过配置文件创建对象 第一种 使用类的无参构造创建（重点） 12&lt;!-- ioc入门 --&gt; &lt;bean id=&quot;user&quot; class=&quot;com.z.ioc.User&quot;&gt;&lt;/bean&gt; 类里面没有无参构造，出现异常 第二种 使用静态工厂创建 1）创建静态的方法，返回类对象 12&lt;!-- 使用静态工厂创建对象 --&gt;&lt;bean id=&quot;bean2&quot; class=&quot;com.z.bean.Bean2Factory&quot; factory-method=&quot;getBean2&quot;&gt;&lt;/bean&gt; 第三种 使用实例工厂创建 1）创建不是静态的方法，返回类对象 12345&lt;!-- 使用实例工厂创建对象 --&gt;&lt;!-- 1、创建工厂对象 --&gt;&lt;bean id=&quot;bean3Factory&quot; class=&quot;com.z.bean3.Bean3Factory&quot;&gt;&lt;/bean&gt;&lt;!-- 2、创建对象 --&gt;&lt;bean id=&quot;bean3&quot; factory-bean=&quot;bean3Factory&quot; factory-method=&quot;getBean3&quot;&gt;&lt;/bean&gt; bean标签常用属性1）id属性 - 起名称，id属性值名称任意命名 id属性值，不能包含特殊符号 根据id值得到配置对象 2）class属性 - 创建对象所在类的全路径 3）name属性 - 功能和id属性一样，但是name属性值里可以包含特殊符号 4）scope属性 -singleton：默认值，单例 -prototype：多例 -request：创建对象把对象放到request域里面 -session：创建对象把对象放到session域里面 -globalSession：创建对象把对象放到globalSession域里面 属性注入方式介绍 创建对象时，向类的属性里面设置值 在Java中： 1）使用有参构造注入 2）使用set()注入 3）使用接口注入 Spring注入属性（有参构造和set方法）在Spring框架里面，支持前两种方式 1）有参构造注入 12345&lt;!-- 使用有参构造注入属性 --&gt;&lt;bean id=&quot;demo1&quot; class=&quot;com.z.property.PropertyDemo1&quot;&gt; &lt;!-- 使用有参构造注入 --&gt; &lt;constructor-arg name=&quot;username&quot; value=&quot;lili&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 2）set()注入（重点） 12345678&lt;!-- 使用set方法注入属性 --&gt; &lt;bean id=&quot;book&quot; class=&quot;com.z.property.Book&quot;&gt; &lt;!-- 注入属性值 name属性值：类里面定义的属性名称 value属性：设置具体的值 --&gt; &lt;property name=&quot;bookname&quot; value=&quot;被讨厌的勇气&quot;&gt;&lt;/property&gt; &lt;/bean&gt; Spring注入对象类型属性（重点） 创建service类和dao类 在service得到dao对象 具体实现过程 1）在service里面把dao作为类型属性 12345678// 1 定义dao类型属性private UserDao userDao;// 2 生成set方法public void setUserDao(UserDao userDao) &#123; this.userDao = userDao;&#125; 2）生成dao类型属性的set方法 1234567891011&lt;!-- 注入对象类型属性 --&gt; &lt;!-- 1 配置service和dao对象 --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.z.ioc.UserDao&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.z.ioc.UserService&quot;&gt; &lt;!-- 2 注入dao对象 name属性值：service类里面属性名称 现在是对象，不写value属性 写ref属性：dao配置bean标签中id值 --&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; P名称空间注入1）添加beans属性 1xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot; 2）P名称空间注入 12&lt;!-- P名称空间注入 --&gt;&lt;bean id=&quot;person&quot; class=&quot;com.z.property.Person&quot; p:pname=&quot;jennie&quot;&gt;&lt;/bean&gt; Spring注入复杂数据 1 数组类型 2 List集合 3 map集合 4 properties类型 12345678910111213141516171819202122232425262728293031323334&lt;!-- 注入复杂数据 --&gt;&lt;bean id=&quot;person&quot; class=&quot;com.z.property.Person&quot;&gt; &lt;!-- 数组 --&gt; &lt;property name=&quot;arrs&quot;&gt; &lt;list&gt; &lt;value&gt;lili&lt;/value&gt; &lt;value&gt;rose&lt;/value&gt; &lt;value&gt;jisoo&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- list --&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;lili2&lt;/value&gt; &lt;value&gt;rose2&lt;/value&gt; &lt;value&gt;jisoo2&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- map --&gt; &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;11&quot; value=&quot;111&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;22&quot; value=&quot;222&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;33&quot; value=&quot;333&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- properties --&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;driverclass&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; IOC和DI区别1）IOC：控制反转，把对象创建交给spring进行配置 2）DI：依赖注入，向类里面的属性中设置值 3）关系：依赖注入不能单独存在，需要在ioc的基础之上操作 Spring整合web项目原理1 加载spring核心配置文件 1ApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;); 1）new对象，功能可以实现，效率很低 2 实现思想：把加载配置文件和创建对象过程，在服务器启动时候完成 3 实现原理 1）ServletContext对象 2）监听器 3）具体使用： -在服务器启动时，为每个项目创建一个ServletContext对象 -在ServletContext对象创建时，使用监听器可以具体到ServletContext对象在什么时候创建 -使用监听器监听到ServletContext对象创建时候， ​ –加载spring配置文件，把配置文件配置对象创建 ​ –把创建出来的对象放到ServletContext域对象里面（setAttribute方法） -获取对象时，到ServletContext域得到（getAttribute方法） Spring的bean管理（注解） 注解介绍 1 代码里面特殊标记，使用注解可以完成功能 2 注解写法 @注解名称(属性名称=属性值) 3 注解使用在类上面，方法上面和属性上面 Spring注解开发准备1 导入jar包 1）导入基本的jar包 2）导入aop的jar包 2 创建类，创建方法 3 创建spring配置文件，引入约束 1）做ioc基本功能，引入约束 2）做spring的ioc注解开发，引入新的约束 1http://www.springframework.org/schema/context/spring-context-3.2.xsd 4 开启注解扫描 1234567&lt;!-- 开启注解扫描(jdk1.8不支持) 1）到包里面扫描类、方法、属性上面是否有注解 --&gt; &lt;context:component-scan base-package=&quot;com.z&quot;&gt;&lt;/context:component-scan&gt; &lt;!-- 扫描属性上面的注解（不常用） --&gt; &lt;!-- &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt; --&gt; 使用注解创建对象1 在创建对象的类上面使用注解实现 12345678@Component(value=&quot;user&quot;) // &lt;bean id=&quot;user&quot; class=&quot;com.z.anno.User&quot;&gt;&lt;/bean&gt;public class User &#123; public void add() &#123; // TODO Auto-generated method stub System.out.println(&quot;add....&quot;); &#125;&#125; 2 创建对象有四个注解 1）@Component 2）@Controller 3）@Service 4）@Repository 目前这四个注解功能是一样的，都创建对象 3 创建对象单实例还是多实例,@Scope 123456789@Component(value=&quot;user&quot;)@Scope(value=&quot;propertype&quot;)public class User &#123; public void add() &#123; // TODO Auto-generated method stub System.out.println(&quot;add....&quot;); &#125;&#125; 使用注解注入属性 需求：创建service类，创建dao类，在service得到dao对象 1）创建dao和service对象 2）在service类里面定义dao类型属性 第一个：属性注解@Autowired - 自动注入 12345678910111213141516171819202122232425UserDao.java@Component(value=&quot;userDao&quot;)public class UserDao &#123; public void add()&#123; System.out.println(&quot;....UserDao...&quot;); &#125;&#125;UserService.java@Service(value=&quot;userService&quot;)public class UserService &#123; //首先定义dao类型属性，然后使用注解完成对象注入 @Autowired private UserDao userDao; // 使用注解方式不需要set方法 public void UserService()&#123; System.out.println(&quot;......userService.....&quot;); userDao.add(); &#125;&#125; 第二个：属性注解@Resource - 准确指定描述对象 123456789101112131415161718UserService.java@Service(value=&quot;userService&quot;)public class UserService &#123; //首先定义dao类型属性，然后使用注解完成对象注入 //@Autowired //private UserDao userDao; // 使用注解方式不需要set方法 // name是dao里面@Component(value=&quot;userDao&quot;) @Resource(name=&quot;userDao&quot;) private UserDao userDao; public void UserService()&#123; System.out.println(&quot;......userService.....&quot;); userDao.add(); &#125;&#125; xml和注解方式混合使用1 创建对象操作使用配置文件方式实现 123456&lt;!-- 开启注解式扫描，检测包里面扫描类，方法，属性是否有注解 --&gt; &lt;context:component-scan base-package=&quot;com.neuedu&quot;&gt;&lt;/context:component-scan&gt; &lt;!-- 创建对象 --&gt; &lt;bean id=&quot;bookDao&quot; class=&quot;com.neuedu.user2.BookDao&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;orderDao&quot; class=&quot;com.neuedu.user2.OrderDao&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.neuedu.user2.BookService&quot;&gt;&lt;/bean&gt; 2 注入属性的操作使用注解方式实现 123456789101112131415public class BookService &#123; @Resource(name=&quot;bookDao&quot;) private BookDao bookDao; @Resource(name=&quot;orderDao&quot;) private OrderDao orderDao; public void BookService()&#123; System.out.println(&quot;.....BookService....&quot;); bookDao.BookDao(); orderDao.OrederDao(); &#125;&#125; AOP 1 aop概述 2 aop底层原理 3 aop操作相关术语 AOP概念1 AOP：面向切面（方面）编程，扩展功能不修改源代码实现2 AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码3 AOP底层使用动态代理实现 （1）第一种情况，有接口情况，使用动态代理创建接口实现类代理对象 （2）第二种情况，没有接口情况，使用动态代理创建类的子类代理对象 AOP原理1）纵向继承机制解决 2）横向抽取机制 AOP操作术语Joinpoint(连接点): 类里面可以被增强的方法，这些方法称为连接点 ***Pointcut(切入点):**所谓切入点是指我们要对哪些Joinpoint进行拦截的定义 ***Advice(通知/增强):**所谓通知是指拦截到Joinpoint之后所要做的事情就是通知.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能) ***Aspect(切面):**是切入点和通知（引介）的结合 **Introduction(引介):**引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field **Target(目标对象):**代理的目标对象(要增强的类) **Weaving(织入):**是把增强应用到目标的过程 ​ 把advice 应用到 target的过程 **Proxy(代理):**一个类被AOP织入增强后，就产生一个结果代表类 Spirng的AOP操作（基于aspectj的xml方式） *1 在spring里面进行aop操作，使用 aspectj实现* 1）aspectj不是spring一部分，和spring一起使用进行aop操作 2）Spring2.0以后新增了对AspectJ支持 2 使用aspectj实现aop有两种方式 1）基于aspectj的xml配置 2）基于aspectj的注解方式 AOP操作准备1 导入aop相关jar包 2 创建spring核心配置文件，导入aop约束 1http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd 使用表达式配置切入点1 切入点：实际增强的方法 2 常用的表达式 execution(&lt;访问修饰符&gt;?&lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;) 1）execution(* cn.itcast.aop.Book.add(..)) 含义：任意修饰符,在cn.itcast.aop包下Book类中add方法(),有参数也包含 2）execution(* cn.itcast.aop.Book.*(..)) 含义：任意修饰符,在cn.itcast.aop包下Book类中所有方法(),有参数也包含 3）execution(* /./(..)) 含义：任意修饰符,在所有类下所有方法,有参数也包含 4） 匹配所有save开头的方法 execution(* save*(..)) 含义：任意修饰符，以save开头的任意方法都增强,有参数也包含 AspectJ的aop操作 123456789101112131415161718&lt;!-- 1.配置对象 --&gt;&lt;bean id=&quot;book&quot; class=&quot;com.neuedu.aop.Book&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;myBook&quot; class=&quot;com.neuedu.aop.MyBook&quot;&gt;&lt;/bean&gt;&lt;!-- 2.配置Aop操作 --&gt;&lt;aop:config&gt; &lt;!-- 2.1配置切入点 --&gt; &lt;aop:pointcut expression=&quot;execution(* com.neuedu.aop.Book.*(..))&quot; id=&quot;qieru&quot;/&gt; &lt;!-- 2.2配置切面，把增强用到方法上面 --&gt; &lt;aop:aspect ref=&quot;myBook&quot;&gt; &lt;!-- 2.3配置增强类型method：增强类里面使用哪个方法作为前置--&gt; &lt;aop:before method=&quot;before1&quot; pointcut-ref=&quot;qieru&quot;/&gt; &lt;!-- 后置增强 --&gt; &lt;aop:after-returning method=&quot;after1&quot; pointcut-ref=&quot;qieru&quot;/&gt; &lt;!-- 环绕通知 --&gt; &lt;aop:around method=&quot;around1&quot; pointcut-ref=&quot;qieru&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 3 AspectJ支持5种类型的通知注解: @Before:前置通知，在方法执行之前返回 @After:后置通知，在方法执行后执行 @AfterRunning:返回通知，在方法返回结果之后执行 @AfterThrowing:异常通知，在方法抛出异常之后 @Around:环绕通知，围绕着方法执行 log4j介绍1 通过log4j可以看到程序运行过程中更详细的信息 1）经常使用log4j查看日志 2 使用 1）导入jar包 2）复制log4j配置文件到src下面 3 设置日志级别 1log4j.rootLogger=info,debug 1）info：看到基本信息 2）debug：看到更详细信息 Spring整合web项目演示1 演示问题 1）action调用service，service调用dao 每次访问action时候，都会加载spring配置文件 2 解决方案 1）在服务器启动时候，创建对象加载配置文件 2）底层使用监听器、ServletContext对象 3 在spring里面不需要我们自己写代码实现，帮封装 1）封装了一个监听器，只需要配置监听器就可以了 2）配置监听器之前做事情：导入spring整合web项目jar包 spring-web-3.2.0.RELEASE.jar 1234&lt;!-- 配置监听器 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 3）指定加载spring配置文件位置 12345&lt;!-- 指定spring配置文件位置--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:bean1.xml&lt;/param-value&gt;&lt;/context-param&gt; Spirng的AOP操作（基于aspectj的注解aop）使用注解方式实现aop操作1）创建对象 123&lt;!-- 创建对象--&gt;&lt;bean id=&quot;book&quot; class=&quot;com.demo.aop.Book&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;myBook&quot; class=&quot;com.demo.aop.MyBook&quot;&gt;&lt;/bean&gt; 2）在spring核心配置文件中，开启aop操作 12&lt;!-- 开启aop操作 --&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 3） 在增强类上面使用注解完成aop操作 12345678910111213141516package com.demo.aop;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class MyBook &#123;// 在方法上面使用注解完成增强配置 @Before(value=&quot;execution(* com.demo.aop.Book.*(..))&quot;) public void before1()&#123; System.out.println(&quot;before......&quot;); &#125;&#125; Spring的jdbcTemplate操作1 Spring框架一站式框架 1）针对javaee三层，每一层都有解决技术 2）在dao层，使用 jdbcTemplate 2 Spring对不同的持久化层技术都进行封装 1）jdbcTemplate对jdbc进行封装 3 jdbcTemplate使用和dbutils使用很相似，都数据库进行crud操作 增加1 导入jdbcTemplate使用的jar包 还有数据库驱动jar包 mysql-connector-java-5.0.4-bin.jar 2 创建对象，设置数据库信息 3 创建jdbcTemplate对象，设置数据源 4 调用jdbcTemplate对象里面的方法实现操作 12345678910111213141516171819202122232425262728package com.demo.jdbc;import org.junit.Test;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DriverManagerDataSource;public class JdbcTemplateDemo1 &#123; // 1 添加操作 @Test public void add() &#123; // 2 创建对象，设置数据库信息 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql:///spring_jdbc&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;&quot;); // 3 创建jdbcTemplate对象，设置数据源 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // 4 调用jdbcTemplate对象里面的方法实现操作// 创建sql语句 String sql = &quot;insert into user values(?,?)&quot;; int rows = jdbcTemplate.update(sql, &quot;jack&quot;, &quot;123&quot;); System.out.println(rows); &#125;&#125; 修改123456789101112131415161718192021 // 2 修改操作 @Test public void update()&#123; // 2 创建对象，设置数据库信息 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql:///spring_jdbc&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;&quot;); // 3 创建jdbcTemplate对象，设置数据源 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // 4 调用jdbcTemplate对象里面的方法实现操作// 创建sql语句 String sql = &quot;update user set password=? where username=?&quot;; int rows = jdbcTemplate.update(sql, &quot;jack&quot;, &quot;jack&quot;); System.out.println(rows); &#125; 删除123456789101112131415161718192021// 3 删除操作 @Test public void delete()&#123; // 2 创建对象，设置数据库信息 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql:///spring_jdbc&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;&quot;); // 3 创建jdbcTemplate对象，设置数据源 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // 4 调用jdbcTemplate对象里面的方法实现操作// 创建sql语句 String sql = &quot;delete from user where username=?&quot;; int rows = jdbcTemplate.update(sql, &quot;jack&quot;); System.out.println(rows); &#125; 查询1 使用jdbcTemplate实现查询操作 jdbcTemplate实现查询，有接口RowMapper, jdbcTemplate针对这个接口没有提供实现类，得到不同的类型数据需要自己进行数据封装 2 查询具体实现 第一个 查询返回某一个值 1）第一个参数是sql语句 2）第二个参数 返回类型的class 123456789101112131415161718192021// 1 查询表中有多少条记录 @Test public void selectCount() &#123; // 2 创建对象，设置数据库信息 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql:///spring_jdbc&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;&quot;); // 3 创建jdbcTemplate对象，设置数据源 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // 4 调用jdbcTemplate对象里面的方法实现操作// 创建sql语句 String sql = &quot;select count(*) from user&quot;;// 调用jdbcTemplate对象里面的方法实现操作 int count = jdbcTemplate.queryForObject(sql, Integer.class); System.out.println(count); &#125; 第二个 查询返回对象 jdbc原始实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 2 jdbc实现代码 @Test public void testJDBC() &#123; Connection conn = null; PreparedStatement psmt = null; ResultSet rs = null; // 1 加载驱动 try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 2 创建链接 conn = DriverManager.getConnection(&quot;jdbc:mysql:///spring_jdbc&quot;, &quot;root&quot;, &quot;&quot;); // 3 编写sql语句 String sql = &quot;select * from user where username=?&quot;; // 4 预编译sql psmt = conn.prepareStatement(sql); // 5 设置参数值 psmt.setString(1, &quot;jisoo&quot;); // 6 执行sql rs = psmt.executeQuery(); // 7 遍历结果集 while (rs.next()) &#123; // 8 得到返回结果值 String username = rs.getString(&quot;username&quot;); String password = rs.getString(&quot;password&quot;); // 9 放到user对象里面 User user = new User(); user.setUsername(username); user.setPassword(password); System.out.println(user); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 10 关闭链接 try &#123; rs.close(); psmt.close(); conn.close(); &#125; catch (Exception throwables) &#123; throwables.printStackTrace(); &#125; &#125; &#125; 使用jdbcTemplate实现： 1）第一个参数是sql语句 2）第二个参数是 RowMapper，是接口，类似于dbutils里面接口 3）第三个参数是 可变参数 12345678910111213141516171819202122232425262728293031323334353637 // 3 查询返回对象 @Test public void selectObject() &#123; // 2 创建对象，设置数据库信息 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql:///spring_jdbc&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;&quot;); // 3 创建jdbcTemplate对象，设置数据源 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // 4 调用jdbcTemplate对象里面的方法实现操作// 创建sql语句, 根据username查询 String sql = &quot;select * from user where username=?&quot;; // 第二个参数是接口RowMapper，需要自己写类实现接口，自己做数据封装 User user = jdbcTemplate.queryForObject(sql, new MyRowMapper(), &quot;lisa&quot;); System.out.println(user); &#125;class MyRowMapper implements RowMapper&lt;User&gt; &#123; @Override public User mapRow(ResultSet resultSet, int i) throws SQLException &#123; // 1 从结果集里面把数据得到 String username = resultSet.getString(&quot;username&quot;); String password = resultSet.getString(&quot;password&quot;); // 2 把得到数据封装到对象里面去 User user = new User(); user.setUsername(username); user.setPassword(password); return user; &#125;&#125; 第三个 查询返回list集合 1）sql语句 2）RowMapper接口，自己写类实现数据封装 3）可变参数 123456789101112131415161718192021222324252627282930313233343536 // 4 查询返回list集合 @Test public void selectList() &#123; // 2 创建对象，设置数据库信息 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql:///spring_jdbc&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;&quot;); // 3 创建jdbcTemplate对象，设置数据源 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // 4 调用jdbcTemplate对象里面的方法实现操作// 创建sql语句, 根据username查询 String sql = &quot;select * from user&quot;; List&lt;User&gt; list = jdbcTemplate.query(sql,new MyRowMapper()); System.out.println(list); &#125;class MyRowMapper implements RowMapper&lt;User&gt; &#123; @Override public User mapRow(ResultSet resultSet, int i) throws SQLException &#123; // 1 从结果集里面把数据得到 String username = resultSet.getString(&quot;username&quot;); String password = resultSet.getString(&quot;password&quot;); // 2 把得到数据封装到对象里面去 User user = new User(); user.setUsername(username); user.setPassword(password); return user; &#125;&#125; Spring配置连接池和dao使用jdbcTemplatespring配置c3p0连接池第一步 导入jar包 c3p0-0.9.1.jar mchange-commons-java-0.2.3.4.jar 第二步 创建spring配置文件，配置连接池 123456// 原始方式配置c3p0连接池ComboPooledDataSource dataSource = new ComboPooledDataSource();dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);dataSource.setJdbcUrl(&quot;jdbc:mysql:///spring_jdbc&quot;);dataSource.setUser(&quot;root&quot;);dataSource.setPassword(&quot;&quot;); 1）把代码在配置文件中进行配置 12345678&lt;!-- 配置c3p0连接池--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!-- 注入属性值--&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///spring_jdbc&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;&quot;&gt;&lt;/property&gt;&lt;/bean&gt; dao使用jdbcTemplate1 创建service和dao，配置service和dao对象，在service注入dao对象 2 创建jdbcTemplate对象，把模板对象注入到dao里面 3 在jdbcTemplate对象里面注入dataSource 123456789101112131415161718192021222324 &lt;!-- 配置c3p0连接池--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!-- 注入属性值--&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///spring_jdbc&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 创建对象--&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.demo.c3p0.UserDao&quot;&gt; &lt;!-- 注入dbcTemplate对象--&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.demo.c3p0.UserService&quot;&gt;&lt;!-- 注入dao对象--&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 创建jdbcTemplate对象--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;&lt;!-- 把dataSource传入jdbcTemplate对象里面去--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; Spring的事务管理事务概念1 什么事务 事务是一个由有限操作集合组成的逻辑单元 2 事务特性 原子性、一致性、隔离性、持久性 3 不考虑隔离性产生读问题 脏读，一个事务处理过程里读取了另一个未提交的事务中的数据 幻读也叫虚读，一个事务执行两次查询，第二次结果集包含第一次中没有或某些行已经被删除的数据，造成两次结果不一致，是另一个事务在这两次查询中间插入或删除了数据造成的。幻读是事务非独立执行时发生的一种现象 不可重复读，一个事务两次读取同一行的数据，结果得到不同状态的结果，中间正好另一个事务更新了该数据，两次结果相异，不可被信任 4 解决读问题 1）设置隔离级别 Spring事务管理api1 spring事务管理两种方式 第一种 编程式事务管理（不用） 第二种 声明式事务管理 （1） 基于xml配置文件实现 （2） 基于注解实现 2 spring事务管理的api介绍 1）spring针对不同的dao层框架，提供接口不同的实现类 2）首先 配置事务管理器 搭建转账环境1 创建数据库表，添加数据 2 创建service和dao类，完成注入关系 12345678910&lt;!-- 创建对象并注入--&gt; &lt;bean id=&quot;ordersDao&quot; class=&quot;com.demo.tx.dao.OrdersDao&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;ordersService&quot; class=&quot;com.demo.tx.service.OrdersService&quot;&gt; &lt;property name=&quot;ordersDao&quot; ref=&quot;ordersDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 1）service层又叫业务逻辑层 1234567891011121314151617181920212223package com.demo.tx.service;import com.demo.tx.dao.OrdersDao;public class OrdersService &#123; private OrdersDao ordersDao; public void setOrdersDao(OrdersDao ordersDao) &#123; this.ordersDao = ordersDao; &#125; // 调用dao的方法 // 业务逻辑层，写转账业务 public void accountMoney()&#123; // lili少1000 ordersDao.lessMoney(); // jiji多1000 ordersDao.moreMoney(); &#125;&#125; 2）dao层，单纯对数据库操作层，在dao层不添加业务 123456789101112131415161718192021222324252627package com.demo.tx.dao;import org.springframework.jdbc.core.JdbcTemplate;public class OrdersDao &#123; // 注入jdbcTemplate对象 private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; // 对数据库的操作 // lili少钱的方法 public void lessMoney()&#123; String sql = &quot;update account set salary=salary-? where username=?&quot;; jdbcTemplate.update(sql, 1000, &quot;lili&quot;); &#125; // jiji多钱的方法 public void moreMoney()&#123; String sql = &quot;update account set salary=salary+? where username=?&quot;; jdbcTemplate.update(sql, 1000, &quot;jiji&quot;); &#125;&#125; 3）需求：小王 转账 1000 给 小马 小王少1000 小马多1000 3 产生问题 1）如果小王少了1000之后，出现异常，小马不会多1000，钱丢失了 4 解决 1）添加事务解决，出现异常进行回滚操作 声明式事务管理（xml配置）配置文件方式使用aop思想配置 第一步 配置事务管理器 1234&lt;!-- 1 配置事务管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 第二步 配置事务增强 12345678&lt;!-- 2 配置事务增强--&gt; &lt;tx:advice id=&quot;txadvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;&lt;!-- 做事务操作--&gt; &lt;tx:attributes&gt;&lt;!-- 设置进行事务操作的方法匹配规则--&gt; &lt;tx:method name=&quot;account*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 第三步 配置切面 1234567&lt;!-- 3 配置切面--&gt; &lt;aop:config&gt;&lt;!-- 切入点--&gt; &lt;aop:pointcut id=&quot;pointcut1&quot; expression=&quot;execution(* com.demo.tx.service.OrdersService.*(..))&quot;/&gt;&lt;!-- 切面--&gt; &lt;aop:advisor advice-ref=&quot;txadvice&quot; pointcut-ref=&quot;pointcut1&quot;&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt; 第四步 测试 123456789101112// 调用dao的方法// 业务逻辑层，写转账业务public void accountMoney()&#123; // lili少1000 ordersDao.lessMoney(); // 出现异常 int i = 10/0; // jiji多1000 ordersDao.moreMoney();&#125; 声明式事务管理（注解）第一步 配置事务管理器 1234&lt;!-- 1 配置事务管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 第二步 开启事务注解 12&lt;!-- 2 开启事务注解--&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt; 第三步 在要使用事务的方法所在类上面添加注解 12@Transactionalpublic class OrdersService &#123;","categories":[{"name":"java","slug":"java","permalink":"https://supertramp7.github.io/categories/java/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"https://supertramp7.github.io/tags/ssh/"},{"name":"java","slug":"java","permalink":"https://supertramp7.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://supertramp7.github.io/tags/spring/"},{"name":"框架","slug":"框架","permalink":"https://supertramp7.github.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"学习mybatis的一些坑","slug":"mybatis","date":"2021-02-19T08:27:31.000Z","updated":"2022-04-06T11:48:36.057Z","comments":true,"path":"mybatis/","link":"","permalink":"https://supertramp7.github.io/mybatis/","excerpt":"","text":"mybatis 知识点day1–mybatis 基础1. mybatis 的使用步骤 1、根据xml配置文件（全局配置文件）创建一个SqlSessionFactory对象:有数据源一些运行环境信息 2、sql 映射文件：配置了每一个sql，以及sql的封装规则等； 3、将sql映射文件注册在全局配置文件中 4、写代码 1）根据全局配置文件得到SqlSessionFactory 2）使用SqlSessionFactory获取到session对象，使用他来执行增删改查，session用完关闭 3）方法一：使用sql的唯一标识来告诉mybatis执行那个 sql ，sql都是保存在sql映射文件中的 方法二：（接口式编程）使用接口获取mapper对象，再用mapper调用接口中的方法（和hibernate相似） 2. mybatis 的全局配置文件 mybatis-config.xml （属性的顺序不能改变） properties 属性：引入外部 properties 配置文件的内容 ​ resource: 引入类路径下的资源 ​ url: 引入网络路径或者磁盘路径下的资源 settings 属性：包含很多重要的设置项 ​ setting:用来设置每一个设置项 ​ name: 设置项名 ​ value: 设置项取值 typeAliases 属性: 别名处理器，可以为 Java 类型起别名，别名不区分大小写 ​ typeAlias: 为某个 Java 类型起别名 ​ type: 指定要起别名的类型全类名，默认别名就是类名小写；employee ​ alias: 指定新的别名 ​ package: 为某个包下的所有类批量起别名 ​ name: 指定包名（为当前包以及下面所有的后代包的每一个类都起一个默认别名（类名小写） ​ 批量起别名的情况下，使用@Alias 注解为某个类型指定新的别名 environments:环境，mybatis 可以配置多种环境，default 指定使用某种环境，可以达到快速切换环境 ​ environment：配置一个具体的环境信息；id 代表当前环境的唯一标识；必须有两个标签： ​ transactionManager：事务管理器； ​ type : 事务管理器的类型；JDBC|MANAGED ​ 自定义事务管理器：实现 TransactionFactory 接口，type 指定为全类名 ​ dataSource：数据源；​ type : UNPOOLED|POOLED|JNDI ​ 自定义数据源：实现 DataSourceFactory 接口，type 指定为全类名 databaseIdProvider:支持多数据库厂商的；type=”DB_VENDOR”：VendorDatabaseIdProvider，作用就是得到数据库厂商的标识，mybatis 就能根据数据库厂商标识来执行不同的 sql；MySQL,Oracle,SQL Server,xxxx mappers:将 sql 映射注册到全局配置中 mapper：注册一个 sql 映射 注册配置文件 resource:引用类路径下的 sql 映射文件url:引用网络路径或者磁盘路径下的 sql 映射文件 注册接口 class:引用（注册）接口 1、有 sql 映射文件，映射文件名必须和接口同名，并且放在与接口同一目录下； 2、 没有 sql 映射文件，所有的 sql 都是利用注解写在接口上; 推荐： 比较重要的、复杂的 Dao 接口我们来写 sql 映射文件 不重要的、简单的 Dao 接口，为了快速开发可以使用注解 package：批量注册; 注：必须要求映射文件和接口放在同一目录下，为了看起来方便，将 conf 下的映射文件的包名改为和 src 下的接口的包名一样（编译的时候是在一个同一个包下） 3. mybatis 映射文件 EmployeeMapper.xml1、增删改查 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!-- namespace：名称空间 id:唯一标识 resultType:返回值类型 #&#123;id&#125;: 从传递过来的参数中取出id值 --&gt; &lt;select id=&quot;getEmpById&quot; resultType=&quot;com.zwb.mybatis.bean.Employee&quot; databaseId=&quot;mysql&quot;&gt; select * from tbl_employee where id=#&#123;id&#125; &lt;/select&gt; &lt;!-- public void addEmp(Employee employee); --&gt; &lt;!-- parameterType：参数类型，可以省略； 获取自增主键的值： mysql支持自增主键，自增主键值的获取，mybatis也是利用statement.getGeneratedKeys(); useGeneratedKeys=&quot;true&quot;: 使用自增主键获取主键值策略 keyProperty：指定对应的主键属性，也就是mybatis获取到主键值以后，将这个值封装给JavaBean的哪个属性 --&gt; &lt;insert id=&quot;addEmp&quot; parameterType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; insert into tbl_employee(last_name,email,gender) values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;) &lt;/insert&gt; &lt;!-- public void updateEmp(Employee employee); --&gt; &lt;update id=&quot;updateEmp&quot;&gt; update tbl_employee set last_name=#&#123;lastName&#125;,email=#&#123;email&#125;,gender=#&#123;gender&#125; where id=#&#123;id&#125; &lt;/update&gt; &lt;!-- public void deleteEmpById(Integer id); --&gt; &lt;delete id=&quot;deleteEmpById&quot;&gt; delete from tbl_employee where id=#&#123;id&#125; &lt;/delete&gt; /** * 测试增删改 * 1. mybatis 允许增删改直接定义以下类型返回值 * Integer、Long、Boolean * 2. 手动提交数据 * sqlSessionFactory.openSession(); ===&gt; 手动提交 * sqlSessionFactory.openSession(true); ===&gt; 自动提交 * @throws IOException */ 2、mybatis 参数处理 单个参数：mybatis 不会做特殊处理。 ​ #{参数名(实际上可以任意写，因为参数就一个)}:取出参数值。 多个参数：mybatis 会做特殊处理。 ​ 多个参数会被封装成一个 map ​ key:param1…paramN，或者参数的索引 ​ value:传入的参数值 ​ #{}就是从 map 中获取指定的 key 的值； ​ 异常： ​ org.apache.ibatis.binding.BindingException: ​ Parameter &#39;id&#39; not found. ​ Available parameters are [arg1, arg0, param1, param2] ​ 操作： ​ 方法：public Employee getEmpByIdAndLastName(Integer id,String lastName); ​ 取值：#{id},#{lastName} 命名参数：明确指定封装参数时 map 的 key。 ​ 多个参数会被封装成一个 map, ​ key:使用@Param()注解指定的值 ​ value:传入的参数值 ​ #{指定的 key}取出对应的参数值 POJO: ​ 如果多个参数正好是业务逻辑的数据模型，可以直接传入 pojo ​ #{属性名}:取出掺入的 pojo 的属性值 Map: ​ 如果多个参数不是业务逻辑的数据模型，可以传入 map ​ #{key}:取出 map 中对应的值 TO: ​ 如果多个参数不是业务逻辑的数据模型，但经常使用，推荐来编写一个 TO(Transfer Object)数据传输对象 ​ Page&#123; ​ int index; ​ int size; ​ &#125; ====================思考========================= public Employee getEmp(@Param(“id”)Integer id,String lastName); 取值：id=#{id/parma1} last_name=#{param2} public Employee getEmp(Integer id,@Param(“e”)Employee employee); 取值：id=#{parma1} last_name=#{param2.lastName/e.lastName} // 特别注意：如果是Collection(List、Set)类型或者是数组，也会特殊处理。也是把传入的list或者数组封装在map中 key:Collection(collection),如果是List还可以使用这个key(list) 数组(array)public Employee getEmpById(List ids); 取值：取出第一个id的值：id=#{list[0]} ===================结合源码，mybatis怎么处理参数========================== ===================参数值的获取==========================select * from tbl_employee where id=${id} and last_name=#{lastName}select * from tbl_employee where id=1 and last_name=?#{}：可以获取map中的值或者pojo对象属性的值${}：可以获取map中的值或者pojo对象属性的值 区别： #{}：是以预编译的形式，将参数设置到sql语句中；PreparedStatement；防止sql注入 ${}：取出的值直接拼装在sql语句中；会有安全问题 大多情况下，我们取参数的值都应该去使用#{}； 某些情况下(原生jdbc不支持占位符的地方)，比如分表、排序..：按照年份分表拆分 select * from ${year}_salary where xxx; select * from tbl_employee order by ${f_name} ${order} #{}:更丰富的用法： 规定参数的一些规则： javaType、jdbcType、mode（存储过程）、numericScale、 resultMap、typeHandler、jdbcTypeName、expression（未来准备支持的功能） javaType通常需要在某种特定的条件下被设置： 在我们数据为null的时候，有些数据库可能不能识别mybatis对null的默认处理。比如Oracle（报错）； javaType OTHER：无效的类型；因为mybatis对所有的null都映射的是原生Jdbc的OTHER类型，oracle不认识； 由于全局配置中：javaTypeForNull=OTHER；oracle不支持；两种办法1、#{email,javaType=OTHER};2、全局设置javaTypeForNull=NULL 3、select 返回 List ​ esultType：如果返回的是一个集合，要写集合中元素的类型 4、select 记录封装 ​ 一条记录封装一个 map： ​ Map&lt;Integer,Employee&gt;：key 这条记录的主键，value 是这条记录 ​ 使用注解@MapKey(“id”)，告诉 mybatis 封装 map 时使用哪个属性作为 map 的 key 5、select resultMap 1）resultMap 自定义映射规则 12345678910111213141516171819&lt;!-- 自定义某个JavaBean的封装规则:type:自定义规则的Java类型; id:唯一id方便引用 --&gt; &lt;!-- 此时，全局配置文件里的驼峰命名规则可以去除掉了 --&gt; &lt;resultMap type=&quot;com.zwb.mybatis.bean.Employee&quot; id=&quot;MyEmp&quot;&gt; &lt;!-- 指定主键列的封装规则:column:指定哪一列； property:指定对应的javabean属性 --&gt; &lt;!-- result定义主键也可以，但是，id定义主键会底层有优化 --&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;!-- 指定非主键列的封装规则: --&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot;/&gt; &lt;!-- 其他不指定的列会自动封装，但是通常在resultMap里把全部的规则都写上 --&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot;/&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt; &lt;/resultMap&gt; &lt;!-- resuleMap:自定义结果集映射规则；和 resultType 不能同时出现 --&gt; &lt;!-- public Employee getEmpById(Integer id); --&gt; &lt;select id=&quot;getEmpById&quot; resultMap=&quot;MyEmp&quot;&gt; select * from tbl_employee where id=#&#123;id&#125; &lt;/select&gt; 2）resultMap 关联查询 1 - 级联属性封装结果集 1234567891011121314151617181920&lt;!-- 场景一： 查询Employee的同时，查出所在部门 ;id lastName email gender dept --&gt; &lt;!-- 联合查询：级联属性封装结果集 --&gt; &lt;resultMap type=&quot;com.zwb.mybatis.bean.Employee&quot; id=&quot;MyEmp2&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;lastName&quot; property=&quot;lastName&quot; /&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot; /&gt; &lt;result column=&quot;d_id&quot; property=&quot;dept.id&quot; /&gt; &lt;result column=&quot;d_name&quot; property=&quot;dept.departmentName&quot; /&gt; &lt;/resultMap&gt; &lt;!-- public Employee getEmpAndDept(Integer id); --&gt; &lt;select id=&quot;getEmpAndDept&quot; resultMap=&quot;MyEmp2&quot;&gt; SELECT e.id id,e.last_name lastName,e.email email,e.gender gender,d.id d_id,d.dept_name d_name from tbl_employee e,tbl_dept d WHERE e.d_id=d.id AND e.id=#&#123;id&#125; &lt;/select&gt; 2 - association 定义关联的单个对象的封装规则 12345678910111213&lt;!-- 使用association定义关联的单个对象的封装规则 --&gt; &lt;resultMap type=&quot;com.zwb.mybatis.bean.Employee&quot; id=&quot;MyEmp3&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;lastName&quot; property=&quot;lastName&quot; /&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot; /&gt; &lt;!-- association可以指定联合的javabean对象：property：指定哪个属性是联合的对象；javaType：指定这个属性对象的类型【不能省略】 --&gt; &lt;association property=&quot;dept&quot; javaType=&quot;com.zwb.mybatis.bean.Department&quot;&gt; &lt;id column=&quot;d_id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;d_name&quot; property=&quot;departmentName&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; 3 - association 分步查询 1234567891011121314151617181920&lt;!-- 使用association进行分步查询:step1:先按照员工id查询员工信息；step2：根据查询员工信息中的d_id值去部门表中查部门信息；step3：部门设置到员工中 --&gt; &lt;resultMap type=&quot;com.zwb.mybatis.bean.Employee&quot; id=&quot;MyEmpByStep&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot; /&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot; /&gt; &lt;!-- association定义关联对象的封装规则：select:表明当前属性是调用select指定的方法查出的结果；column：指定将哪一列的值传给这个方法 --&gt; &lt;!-- 流程：使用select指定的方法（传入column指定的这列参数的值）查出对象，并封装给property指定的属性 --&gt; &lt;association property=&quot;dept&quot; select=&quot;com.zwb.mybatis.dao.DepartmentMapper.getDeptById&quot; column=&quot;d_id&quot;&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!-- public Employee getEmpByIdStep(Integer id); --&gt; &lt;select id=&quot;getEmpByIdStep&quot; resultMap=&quot;MyEmpByStep&quot;&gt; SELECT * from tbl_employee where id=#&#123;id&#125; &lt;/select&gt; 4 - 延迟加载(懒加载) （按需加载）：部门信息在我们使用的时候再去查询，在分段查询的基础之上加上两个配置 123&lt;!-- 延迟加载 --&gt;&lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;&lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; 5 - collection 定义关联集合类型封装规则（一对多的情况） 123456789101112131415161718192021222324&lt;!-- collection嵌套结果集的方式，定义关联的集合类型元素的封装规则 --&gt; &lt;resultMap type=&quot;com.zwb.mybatis.bean.Department&quot; id=&quot;MyDept&quot;&gt; &lt;id column=&quot;did&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;dept_name&quot; property=&quot;departmentName&quot;/&gt; &lt;!-- collection定义关联的集合类型的属性的封装规则;ofType:指定集合里面元素的类型 --&gt; &lt;collection property=&quot;emps&quot; ofType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; &lt;!-- 定义这个集合中元素的封装规则 --&gt; &lt;id column=&quot;eid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot;/&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot;/&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- public Department getDeptByIdPlus(Integer id); --&gt; &lt;select id=&quot;getDeptByIdPlus&quot; resultMap=&quot;MyDept&quot;&gt; SELECT d.id did,d.dept_name dept_name,e.id eid,e.last_name last_name,e.email email,e.gender gender FROM tbl_dept d LEFT JOIN tbl_employee e ON d.id=e.d_id WHERE d.id=#&#123;id&#125; &lt;/select&gt; 6 - collection 的分布查询和延迟加载[和 association 一样] 1234567891011&lt;resultMap type=&quot;com.zwb.mybatis.bean.Department&quot; id=&quot;MyDeptStep&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;dept_name&quot; property=&quot;departmentName&quot;/&gt; &lt;collection property=&quot;emps&quot; select=&quot;com.zwb.mybatis.dao.EmployeeMapperPlus.getEmpsByDid&quot; column=&quot;id&quot;&gt;&lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- public Department getDeptByIdStep(Integer id); --&gt; &lt;select id=&quot;getDeptByIdStep&quot; resultMap=&quot;MyDeptStep&quot;&gt; SELECT id,dept_name from tbl_dept WHERE id=#&#123;id&#125; &lt;/select&gt; 7 - 分步查询传递多列值和 fetchType 扩展：多列值传递过去：将多列的值封装 map 传递：column=&quot;&#123;key1=column1,key2=column2&#125;&quot; ​ fetchType=”lazy”:表示使用延迟加载：lazy[延迟加载]|eager[立即加载] 8 - discriminator 鉴别器 123456789101112131415161718192021222324&lt;!-- discriminator鉴别器：mybatis可以使用discriminator判断某列的值，然后根据某列的值改变封装行为 --&gt; &lt;!-- 封装Employee：如果查出的是女生，就把部门信息查询出来，否则不查询；如果是男生，把last_name赋值给email --&gt; &lt;resultMap type=&quot;com.zwb.mybatis.bean.Employee&quot; id=&quot;MyEmpDis&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot; /&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot; /&gt; &lt;!-- column:指定要判断的列名；javaType:列值对应的java类型 --&gt; &lt;discriminator javaType=&quot;string&quot; column=&quot;gender&quot;&gt; &lt;!-- resultType:指定封装结果类型 ;[resultType|resultMap]选其一 --&gt; &lt;case value=&quot;0&quot; resultType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; &lt;association property=&quot;dept&quot; select=&quot;com.zwb.mybatis.dao.DepartmentMapper.getDeptById&quot; column=&quot;d_id&quot;&gt; &lt;/association&gt; &lt;/case&gt; &lt;case value=&quot;1&quot; resultType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot; /&gt; &lt;result column=&quot;last_name&quot; property=&quot;email&quot; /&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot; /&gt; &lt;/case&gt; &lt;/discriminator&gt; &lt;/resultMap&gt; day2–动态 sql动态 sql1、if 判断 123456789101112131415161718192021&lt;!-- 查询员工，要求：携带了哪个字段，查询条件就带上这个字段的值 --&gt;&lt;!-- public List&lt;Employee&gt; getEmpsByConditionIf(Employee employee); --&gt;&lt;select id=&quot;getEmpsByConditionIf&quot; resultType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; select * from tbl_employee where &lt;!-- test:判断表达式 --&gt; &lt;if test=&quot;id!=null&quot;&gt; id=#&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;lastName!=null and lastName!=&#x27;&#x27;&quot;&gt; and last_name like #&#123;lastName&#125; &lt;/if&gt; &lt;if test=&quot;email!=null and email.trim()!=&#x27;&#x27;&quot;&gt; and email=#&#123;email&#125; &lt;/if&gt; &lt;!-- ognl 会进行字符串与数字的转换判断 --&gt; &lt;if test=&quot;gender==0 or gender==1&quot;&gt; and gender=#&#123;gender&#125; &lt;/if&gt;&lt;/select&gt; 2、where 查询 查询的时候，如果某些条件没带可能 sql 拼装会有问题： 解决：1）给 where 后面加上 1=1 ，以后的条件都 and xxx； ​ 2）mybatis 使用 where 标签来将所有的查询条件包括在内,mybatis 就会将 where 标签中拼装的 sql，多出来的 and 或者 or 去掉（and 在后面的话不行） 12345678910111213141516&lt;where&gt; &lt;!-- test:判断表达式 --&gt; &lt;if test=&quot;id!=null&quot;&gt; id=#&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;lastName!=null and lastName!=&#x27;&#x27;&quot;&gt; and last_name like #&#123;lastName&#125; &lt;/if&gt; &lt;if test=&quot;email!=null and email.trim()!=&#x27;&#x27;&quot;&gt; and email=#&#123;email&#125; &lt;/if&gt; &lt;!-- ognl 会进行字符串与数字的转换判断 --&gt; &lt;if test=&quot;gender==0 or gender==1&quot;&gt; and gender=#&#123;gender&#125; &lt;/if&gt;&lt;/where&gt; 3、trim 自定义字符串截取 12345678910111213141516171819202122232425&lt;select id=&quot;getEmpsByConditionTrim&quot; resultType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; select * from tbl_employee &lt;!-- 后面多出的 and 或者 or where 标签不能解决 --&gt; &lt;!-- prefix:前缀：trim标签体中是整个字符串拼串后的结果，prefix给拼串后的整个字符串加一个前缀； suffix: 后缀，suffix给拼串后的整个字符串加一个后缀； prefixOverrides: 前缀覆盖：去掉整个字符串前面多余的字符； suffixOverrides: 后缀覆盖：去掉整个字符串后面多余的字符 --&gt; &lt;!-- 自定义字符串的截取规则 --&gt; &lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;and&quot;&gt; &lt;if test=&quot;id!=null&quot;&gt; id=#&#123;id&#125; and &lt;/if&gt; &lt;if test=&quot;lastName!=null and lastName!=&#x27;&#x27;&quot;&gt; last_name like #&#123;lastName&#125; and &lt;/if&gt; &lt;if test=&quot;email!=null and email.trim()!=&#x27;&#x27;&quot;&gt; email=#&#123;email&#125; and &lt;/if&gt; &lt;if test=&quot;gender==0 or gender==1&quot;&gt; gender=#&#123;gender&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; 4、choose 分支选择：带了 break 的 switch-case，如果带了 id 就用 id 查，只会进入其中一个 1234567891011121314&lt;select id=&quot;getEmpsByConditionChoose&quot; resultType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; select * from tbl_employee &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;id!=null&quot;&gt;id=#&#123;id&#125;&lt;/when&gt; &lt;when test=&quot;lastName!=null and lastName!=&#x27;&#x27;&quot;&gt;last_name like #&#123;lastName&#125;&lt;/when&gt; &lt;when test=&quot;email!=null and email.trim()!=&#x27;&#x27;&quot;&gt;email=#&#123;email&#125;&lt;/when&gt; &lt;otherwise&gt; gender =0 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; 5、set 与 if 结合的动态更新 123456789&lt;update id=&quot;updateEmp&quot;&gt; update tbl_employee &lt;set&gt; &lt;if test=&quot;lastName!=null&quot;&gt;last_name=#&#123;lastName&#125;,&lt;/if&gt; &lt;if test=&quot;email!=null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt; &lt;if test=&quot;gender!=null&quot;&gt;gender=#&#123;gender&#125;&lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125; &lt;/update&gt; 123456789Trim:&lt;update id=&quot;updateEmp&quot;&gt; update tbl_employee &lt;trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;lastName!=null&quot;&gt;last_name=#&#123;lastName&#125;,&lt;/if&gt; &lt;if test=&quot;email!=null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt; &lt;if test=&quot;gender!=null&quot;&gt;gender=#&#123;gender&#125;&lt;/if&gt; &lt;/trim&gt; where id=#&#123;id&#125; &lt;/update&gt; 6、foreach 遍历集合 12345678910111213&lt;select id=&quot;getEmpsByConditionForEach&quot; resultType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; select * from tbl_employee &lt;!-- collection:指定要遍历的集合：list类型的参数会特殊处理封装在map中，map的key就叫list； item：将遍历出的元素赋值给指定的变量 separator:每个元素之间的分隔符 open:遍历出所有结果拼接一个开始的字符 close:遍历出所有结果拼接一个结束的字符 index:索引。遍历list的时候index是索引，item是值；遍历map时，index就是map的key，item是map的值 #&#123;变量名&#125;就能取出变量得值也就是当前遍历出的元素--&gt; &lt;foreach collection=&quot;ids&quot; item=&quot;item_id&quot; separator=&quot;,&quot; open=&quot;where id in(&quot; close=&quot;)&quot;&gt; #&#123;item_id&#125; &lt;/foreach&gt;&lt;/select&gt; 7、foreach 批量保存（MySQL 数据库）（推荐方法一） 方法一：foreach 遍历 values(),(),() 123456&lt;insert id=&quot;addEmps&quot;&gt; INSERT INTO tbl_employee(last_name,email,gender,d_id) VALUES &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;,&quot;&gt; (#&#123;emp.lastName&#125;,#&#123;emp.email&#125;,#&#123;emp.gender&#125;,#&#123;emp.dept.id&#125;) &lt;/foreach&gt;&lt;/insert&gt; 方法二：将数据库连接属性添加 allowMultiQueries=true ，这种分号分隔多个 sql 可以用于其他的批量操作（删除，修改） dbconfig.properties 里 jdbc.url=jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true 123456&lt;insert id&#x3D;&quot;addEmps&quot;&gt; &lt;foreach collection&#x3D;&quot;emps&quot; item&#x3D;&quot;emp&quot; separator&#x3D;&quot;;&quot;&gt; INSERT INTO tbl_employee(last_name,email,gender,d_id) VALUES (#&#123;emp.lastName&#125;,#&#123;emp.email&#125;,#&#123;emp.gender&#125;,#&#123;emp.dept.id&#125;) &lt;&#x2F;foreach&gt; &lt;&#x2F;insert&gt; 8、两个内置参数 _parameter&amp; _databaseId :不只是方法传递过来的参数可以被用来判断，取值，mybatis 默认还有两个内置参数： 1）_parameter:代表整个参数 单个参数：_parameter就是这个参数 多个参数：参数会被封装为一个 map，_parameter就是代表这个 map2）_databaseId:如果配置了 databaseIdProvider 标签，_databaseId就是代表当前数据库的别名 123456789101112&lt;select id=&quot;getEmpsTestInnerParameter&quot; resultType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; &lt;if test=&quot;_databaseId==&#x27;mysql&#x27;&quot;&gt; select * from tbl_employee &lt;if test=&quot;_parameter!=null&quot;&gt; where last_name = #&#123;lastName&#125; &lt;/if&gt; &lt;/if&gt; &lt;!-- 假装有oracle数据库 --&gt; &lt;if test=&quot;_databaseId==&#x27;oracle&#x27;&quot;&gt; select * from employee &lt;/if&gt; &lt;/select&gt; 9、bind 绑定：可以将 OGNL 表达式的值绑定一个变量中，方便后来引用这个变量得值 1234567891011121314&lt;select id=&quot;getEmpsTestInnerParameter&quot; resultType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; &lt;!-- bind：可以将OGNL表达式的值绑定一个变量中，方便后来引用这个变量得值 --&gt; &lt;bind name=&quot;_lastName&quot; value=&quot;&#x27;_&#x27;+lastName+&#x27;%&#x27;&quot;/&gt; &lt;if test=&quot;_databaseId==&#x27;mysql&#x27;&quot;&gt; select * from tbl_employee &lt;if test=&quot;_parameter!=null&quot;&gt; where last_name like #&#123;_lastName&#125; &lt;/if&gt; &lt;/if&gt; &lt;!-- 假装有oracle数据库 --&gt; &lt;if test=&quot;_databaseId==&#x27;oracle&#x27;&quot;&gt; select * from employee &lt;/if&gt; &lt;/select&gt; 10、sql 标签：抽取可重用的 sql 片段，方便后面引用 1）sql 抽取：经常将要查询的列名，或者插入用的列名抽取出来方便使用2）include 来引用已经抽取的 sql3）include 还可以自定义一些 property，sql 标签内部就能使用自定义的属性 property 取值的正确方式${prop},不能使用这种#{prop} 定义： 12345&lt;sql id=&quot;insertColumn&quot;&gt; &lt;if test=&quot;_databaseId==&#x27;mysql&#x27;&quot;&gt; last_name,email,gender,d_id,$&#123;自定义属性名&#125; &lt;/if&gt;&lt;/sql&gt; 引用： 1234&lt;!-- 引用外部定义的sql --&gt;&lt;include refid=&quot;insertColumn&quot;&gt; &lt;property name=&quot;自定义属性名&quot; value=&quot;自定义属性值&quot;/&gt;&lt;/include&gt; day3–mybatis 缓存mybatis 缓存两级缓存： 1、一级缓存（本地缓存）：sqlSession 级别的缓存，一级缓存是一直开启的； 在数据库同一次会话期间查询到的数据，会放在本地缓存中。以后如果需要获取相同的数据，直接从缓存中去拿，没必要再去查询数据库； 一级缓存的失效情况（没用到当前一级缓存的情况，效果就是,还需要再向数据库发出查询）： sqlSession 不同。 sqlSession 相同，查询条件不同。（当前一级缓存中还没有这个数据） sqlSession 相同，两次查询之间执行了增删改操作。 sqlSession 相同，手动清除了一级缓存（缓存清空） 2、二级缓存（全局缓存）：基于 namespace 级别的缓存，一个 namespace 对应一个二级缓存 1）工作机制： 一个会话，查询一条数据，这个数据就会被放在当前会话的一级缓存中； 如果会话关闭；一级缓存中的数据会被保存到二级缓存中；新的会话查询信息，就可以参照二级缓存中的内容； 不同的 namespace 查出的数据会放在自己对应的缓存（map）中。 sqlSession===EmployeeMapper==&gt;Employee DepartmentMapper==&gt;Department 2）效果：数据会从二级缓存中获取 查出的数据都会被默认先放在一级缓存中。只有会话提交或者关闭后，一级缓存中的数据才会转移到二级缓存中 3）使用步骤： 开启全局二级缓存配置：&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 去 mapper.xml 中配置使用二级缓存： 12345678910111213141516171819&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; readOnly=&quot;false&quot; size=&quot;1024&quot;&gt;&lt;/cache&gt; &lt;!-- eviction:缓存的回收策略： • LRU -- 最近最少使用的：移除最长时间不被使用的对象。 • FIFO -- 先进先出：按对象进入缓存的顺序来移除它们。 • SOFT -- 软引用：移除基于垃圾回收器状态和软引用规则的对象。 • WEAK -- 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。 • 默认的是 LRU。 flushInterval：缓存刷新间隔 缓存多长时间清空一次，默认不清空，设置一个毫秒值 readOnly:是否只读： true：只读；mybatis认为所有从缓存中获取数据的操作都是只读操作，不会修改数据。 mybatis为了加快获取速度，直接就会将数据在缓存中的引用交给用户。不安全，速度快 false：非只读：mybatis觉得获取的数据可能会被修改。 mybatis会利用序列化&amp;反序列的技术克隆一份新的数据给你。安全，速度慢 size：缓存存放多少元素； type：指定自定义缓存的全类名； 实现Cache接口即可； --&gt; 4）我们的 POJO 需要实现序列化接口 3、和缓存有关的设置/属性： 1）&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; false:关闭缓存（二级缓存关闭，一级缓存一直可用） 2）每个 select 标签都有 useCache=”true” false：不使用缓存（一级缓存依然使用，二级缓存不使用） 3）每个增删改标签 flushCache=”true” 增删改执行完成后就会清除缓存（一级缓存、二级缓存都会被清空）；查询标签里也有 flushCache，默认值为 false，如果改为 true,每次查询之后都会清空缓存； 4）session.clearCache(); 只是清除当前 session 的一级缓存 5）localCacheScope: 本地缓存作用域（一级缓存 SESSION）;当前会话的所有数据保存在会话缓存中； ​ STATEMENT:可以禁用一级缓存； 4、第三方 ehcache 整合 1）导入第三方缓存包即可； 2）导入与第三方缓存整合的适配包； 3）mapper.xml 中使用自定义缓存。 123&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;&gt;&lt;/cache&gt;&lt;!-- 引用缓存：namespace指定和哪个名称空间下的缓存一样 --&gt;&lt;cache-ref namespace=&quot;com.zwb.mybatis.dao.EmployeeMapper&quot;/&gt; day4–逆向工程逆向工程 Generator1、导入包 mybatis-generator-core-1.4.0.jar 2、在工程下创建 mbg.xml 文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt; &lt;generatorConfiguration&gt; &lt;!-- targetRuntime=&quot;MyBatis3Simple&quot;:生成简单版的CRUD MyBatis3：豪华版 --&gt; &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;!-- jdbcConnection:指定如何连接到目标数据库 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true&quot; userId=&quot;root&quot; password=&quot;&quot;&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- javaModelGenerator:指定javaBean的生成策略 targetPackage:目标报名 targetProject:目标工程 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.zwb.mybatis.bean&quot; targetProject=&quot;.\\src&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- sqlMapGenerator:sql映射生成策略 --&gt; &lt;sqlMapGenerator targetPackage=&quot;com.zwb.mybatis.dao&quot; targetProject=&quot;.\\conf&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- javaClientGenerator:指定mapper接口所在的位置 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.zwb.mybatis.dao&quot; targetProject=&quot;.\\src&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定要逆向分析哪些表，根据表要创建javabean --&gt; &lt;table tableName=&quot;tbl_dept&quot; domainObjectName=&quot;Department&quot;&gt;&lt;/table&gt; &lt;table tableName=&quot;tbl_employee&quot; domainObjectName=&quot;Employee&quot;&gt;&lt;/table&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt; 3、运行 Generator 123456789101112@Testpublic void testMbg() throws Exception&#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(&quot;mbg.xml&quot;); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null);&#125; 4、测试查询 12345678910111213141516171819202122232425262728293031323334@Testpublic void testMyBatis3() throws IOException &#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); SqlSession session = sqlSessionFactory.openSession(); try &#123; EmployeeMapper mapper = session.getMapper(EmployeeMapper.class); Employee employee = mapper.selectByPrimaryKey(1); System.out.println(employee); // xxxExample就是封装查询条件的 // 1. 查询所有 List&lt;Employee&gt; list = mapper.selectByExample(null); // 2. 查询员工名字中有e字母的，和员工性别是1的 // 封装员工查询条件的example EmployeeExample example = new EmployeeExample(); // 创建一个criteria拼装查询条件 Criteria criteria = example.createCriteria(); criteria.andLastNameLike(&quot;%e%&quot;); criteria.andGenderEqualTo(&quot;1&quot;); Criteria criteria2 = example.createCriteria(); criteria2.andEmailLike(&quot;%e%&quot;); example.or(criteria2); List&lt;Employee&gt; list2 = mapper.selectByExample(example); for (Employee e : list2) &#123; System.out.println(e); &#125; &#125; finally &#123; session.close(); &#125;&#125; day5–mybatis 工作原理MyBatis 工作原理1、mybatis 运行流程 1）获取 sqlSessionFactory 对象 ​ 解析文件的每一个信息保存在 Configuration 中，返回包含 Configuration 的 DefaultSqlSession； ​ 【注意：】[MappedStatement]：代表一个增删改查的详细信息 2）获取 sqlSession 对象 ​ 返回一个 DefaultSQlSession 对象，包含 Executor 和 Configuration; ​ 这一步会创建Executor对象； 3）获取接口的代理对象（MapperProxy） ​ getMapper，使用 MapperProxyFactory 创建一个 MapperProxy 的代理对象 ​ 代理对象里面包含了，DefaultSqlSession（Executor） 4）执行增删改查方法 2、总结 1）根据配置文件（全局，sql 映射）初始化出 Configuration 对象 2）创建一个 DefaultSqlSession 对象，他里面包含 Configuration 以及 Executor（根据全局配置文件中的 defaultExecutorType 创建出对应的 Executor） 3）DefaultSqlSession.getMapper()：拿到 Mapper 接口对应的 MapperProxy； 4）MapperProxy 里面有（DefaultSqlSession）； 5）执行增删改查方法： 调用 DefaultSqlSession 的增删改查（Executor）； 会创建一个 StatementHandler 对象。（同时也会创建出 ParameterHandler 和 ResultSetHandler） 调用 StatementHandler 预编译参数以及设置参数值;使用 ParameterHandler 来给 sql 设置参数 调用 StatementHandler 的增删改查方法； ResultSetHandler 封装结果 6）注意：四大对象每个创建的时候都有一个 interceptorChain.pluginAll(parameterHandler); day6–mybatis 插件1. MyBatis 插件原理在四大对象创建的时候 1、每个创建出来的对象不是直接返回的，而是 interceptorChain.pluginAll(parameterHandler); 2、获取到所有的 Interceptor（拦截器）（插件需要实现的接口）；调用 interceptor.plugin(target);返回 target 包装后的对象 3、插件机制，我们可以使用插件为目标对象创建一个代理对象；AOP(面向切面) ​ 我们的插件可以为四大对象创建出代理对象；代理对象就可以拦截到四大对象的每一个执行； 2. 插件编写：1、编写 interceptor 的实现类——MyFirstPlugin.java 2、使用@Intercepts 注解完成插件签名 123@Intercepts(&#123;@Signature(type=StatementHandler.class,method=&quot;parameterize&quot;,args=java.sql.Statement.class)&#125;) 3、将写好的插件注册到全局配置文件中 1234567&lt;!-- plugins:注册插件 --&gt;&lt;plugins&gt; &lt;plugin interceptor=&quot;com.zwb.mybatis.dao.MyFirstPlugin&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;&quot;/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 4、测试插件 3. 多个插件的运行流程创建动态代理的时候，是按照插件配置顺序创建层层代理对象。 执行目标方法的之后，按照逆向顺序执行。 4. PageHelper 分页插件1、导入 jar 包——pagehelper-5.1.9.jar jsqlparser-3.1.jar 2、在mybatis-config.xml中配置插件【注意标签的顺序】 123456&lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;!-- config params as the following --&gt; &lt;property name=&quot;param1&quot; value=&quot;value1&quot; /&gt; &lt;/plugin&gt;&lt;/plugins&gt; 3、使用分页插件 123456789101112131415161718192021222324252627282930313233@Test public void test2() throws IOException &#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); SqlSession session = sqlSessionFactory.openSession(); try &#123; EmployeeMapper mapper = session.getMapper(EmployeeMapper.class); Page&lt;Object&gt; page = PageHelper.startPage(5, 1); List&lt;Employee&gt; list = mapper.getAllEmps();// PageInfo&lt;Employee&gt; pageInfo = new PageInfo&lt;&gt;(list);// 传入要连续显示多少页 PageInfo&lt;Employee&gt; pageInfo = new PageInfo&lt;&gt;(list,5); for (Employee employee : list) &#123; System.out.println(employee); &#125; /*System.out.println(&quot;当前页码:&quot;+page.getPageNum()+&quot;，每页的记录数：&quot;+page.getPageSize()+&quot;，总记录数：&quot;+page.getTotal()); System.out.println(&quot;总页码：&quot;+page.getPages());*/ System.out.println(&quot;当前页码:&quot;+pageInfo.getPageNum()+&quot;，每页的记录数：&quot;+pageInfo.getPageSize()+&quot;，总记录数：&quot;+pageInfo.getTotal()); System.out.println(&quot;总页码：&quot;+pageInfo.getPages()); System.out.println(&quot;是否第一页&quot;+pageInfo.isIsFirstPage()); System.out.println(&quot;连续打印的页数：&quot;); int[] nums = pageInfo.getNavigatepageNums(); for (int i = 0; i &lt; nums.length; i++) &#123; System.out.println(nums[i]); &#125; &#125; finally &#123; session.close(); &#125; &#125; day7–批量操作批量：预编译 sql:1 次–&gt;设置参数:10000 次–&gt;执行:1 次 非批量：预编译 sql:10000 次–&gt;设置参数:10000 次–&gt;执行:10000 次 学习 mybatis 的一些坑ERROR11234567org.apache.ibatis.exceptions.PersistenceException:### Error building SqlSession.### The error may exist in EmployeeMapper.xml### Cause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: org.apache.ibatis.builder.BuilderException: Error creating document instance. Cause: org.xml.sax.SAXParseException; lineNumber: 14; columnNumber: 9; XML 文档结构必须从头至尾包含在同一个实体内。 原因：EmployeeMapper.xml 文件里的 mapper 标签缺了一个 ‘’&gt;’’ 解决方案：添加“&gt;” ERROR21234567org.apache.ibatis.exceptions.PersistenceException:### Error querying database. Cause: java.lang.UnsupportedOperationException### The error may exist in EmployeeMapper.xml### The error may involve com.zwb.mybatis.dao.EmployeeMapper.getAllEmp### The error occurred while handling results### SQL: select * from tbl_employee### Cause: java.lang.UnsupportedOperationException 原因：getAllEmp()返回类型是 List，在EmployeeMapper.xml 文件中 resultType 属性配置的类型为java.util.List，但是 resultType 属性设置的是 List 里面每一项的类型 解决方案：将EmployeeMapper.xml 文件中 resultType 属性配置的类型为com.zwb.mybatis.bean.Employee","categories":[{"name":"java","slug":"java","permalink":"https://supertramp7.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://supertramp7.github.io/tags/java/"},{"name":"mybatis","slug":"mybatis","permalink":"https://supertramp7.github.io/tags/mybatis/"}]},{"title":"SpringBoot知识点","slug":"springboot","date":"2021-02-18T16:00:00.000Z","updated":"2022-02-19T11:59:32.390Z","comments":true,"path":"springboot/","link":"","permalink":"https://supertramp7.github.io/springboot/","excerpt":"","text":"一、SpringBoot 入门1、 SpringBoot 简介 简化 Spring 应用开发的一个框架； 整个 Spring 技术栈的一个大整合； J2EE 开发的一站式解决方案； 2、微服务2014，martin fowler 微服务：架构风格 一个应用应该是一个小组小型服务；可以通过 HTTP 的方式进行互通； 单体应用：ALL IN ONE; 微服务架构：每一个功能元素最终都是一个可独立替换和独立升级的软件单元 3、环境准备环境约束： -jdk 1.8 -maven 3.x -intellijIDEA 2019 -SpringBoot 4、SpringBoot HelloWorld功能：浏览器发送 hello 请求，服务器接收请求并处理，响应 Hello World 字符串； 1、创建一个 maven 工程（jar）2、导入 spring boot 相关的依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3、编写一个主程序；启动 Spring Boot 应用1234567891011/** *@SpringBootApplication来标注一个主程序类，说明这是一个springboot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class); &#125;&#125; 4、编写相关的 Controller、Service12345678910@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping(&quot;/hello&quot;) public String Hello()&#123; return &quot;Hello World!&quot;; &#125;&#125; 5、运行主程序测试6、简化部署123456789&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包 --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 将这个应用打成 jar 包，直接使用 java -jar 的命令进行执行 5、Hello World 探究1、POM 文件1、父项目1234567891011121314 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;/parent&gt;他的父项目 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt; &lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本； Spring Boot 的版本仲裁中心；以后我们导入依赖默认是不需要写版本；（没有在 dependencies 里面管理的依赖自然需要声明版本号） 2、导入的依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-web: ​ spring-boot-starter：spring-boot 场景启动器；帮我们导入了 web 模块正常运行所依赖的组件； Spring Boot 将所有的功能场景都抽取出来，做成一个个的 starters（启动器），只需要在项目里面引入这些 starter 相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器。 2、主程序类，主入口类12345678910/** * @SpringBootApplication 来标注一个主程序类，说明这是一个springboot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class); &#125;&#125; @SpringBootApplication：spring boot 应用，标注在某个类上，说明这个类是 SpringBoot 的主配置类，SpringBoot 就应该运行这个类的 main 方法，来启动 SpringBoot 应用； 123456789@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration：SpringBoot 的配置类； ​ 标注在某个类上，表示这是一个 SpringBoot 的配置类； ​ @Configuration：配置类上来标注这个注解； ​ 配置类—–配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； ​ 以前我们需要配置的东西，SpringBoot 帮我们自动配置；**@EnableAutoConfiguration**告诉 SpringBoot 开启自动配置功能；这样自动配置才能生效； 123@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; ​ @AutoConfigurationPackage：自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class) ​ Spring 的底层注解@Import，给容器中导入一个组件；导入的组件由 AutoConfigurationPackages.Registrar.class 告诉 将主配置类（@SpringBootApplication 标注的类）的所在包及下面所有子包里面的所有组件扫描到 Spring 容器； ​ @Import(AutoConfigurationImportSelector.class)； ​ 给容器中导入组件? ​ AutoConfigurationImportSelector：导入哪些组件的选择器； ​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； ​ 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）;就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动编写配置、注入功能组件等工作； ​ SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)； Spring Boot 在启动的时候从类路径下的 META-INF/spring.factories 中获取 EnableAutoConfiguration 指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作； 以前我们需要自己配置的东西，自动配置类都帮我们做了； J2EE 的整体整合解决方案和自动配置都在 spring-boot-autoconfigure-1.5.9.RELEASE.jar； 6、使用 Spring Initializer 快速创建 Spring Boot 项目1、IDEA：使用 Spring Initializer 快速创建项目IDE 都支持使用 Spring 的项目创建向导快速创建一个 Spring Boot 项目； 选择我们需要的模块；向导会联网创建 Spring Boot 项目； 默认生成的 Spring Boot 项目； 主程序已经生成好了，我们只需要我们自己的逻辑 resources 文件夹中目录结构 static：保存所有的静态资源； js css images； templates：保存所有的模板页面；（Spring Boot 默认 jar 包使用嵌入式的 Tomcat，默认不支持 JSP 页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot 应用的配置文件；可以修改一些默认设置； 2、STS 使用 Spring Starter Project 快速创建项目二、配置文件1、配置文件SpringBoot 使用一个全局的配置文件，配置文件名是固定的； •application.properties •application.yml 配置文件的作用：修改 SpringBoot 自动配置的默认值；SpringBoot 在底层都给我们自动配置好； YAML（YAML Ain’t Markup Language） ​ YAML A Markup Language：是一个标记语言 ​ YAML isn’t Markup Language：不是一个标记语言； 标记语言： ​ 以前的配置文件；大多都使用的是 xxxx.xml文件； ​ YAML：以数据为中心，比 json、xml 等更适合做配置文件； ​ YAML：配置例子 12server: port: 8081 ​ XML： 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 2、YAML 语法：1、基本语法k:(空格)v：表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感； 2、值的写法字面量：普通的值（数字，字符串，布尔）​ k: v：字面直接来写； ​ 字符串默认不用加上单引号或者双引号； ​ “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 ​ name: “zhangsan \\n lisi”：输出；zhangsan 换行 lisi ​ ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 ​ name: ‘zhangsan \\n lisi’：输出；zhangsan \\n lisi 对象、Map（属性和值）（键值对）：​ k: v：在下一行来写对象的属性和值的关系；注意缩进 ​ 对象还是 k: v 的方式 123friends: lastName: zhangsan age: 20 行内写法： 1friends: &#123; lastName: zhangsan, age: 18 &#125; 数组（List、Set）：用- 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat, dog, pig] 3、配置文件值注入配置文件 123456789101112person: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: &#123; k1: v1, k2: 12 &#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 12 javaBean： 123456789101112131415161718192021/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = &quot;person&quot;：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * */@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 我们可以导入配置文件处理器，以后编写配置就有提示了 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 1、properties 配置文件在 idea 中默认 utf-8 可能会乱码调整 2、@Value 获取值和@ConfigurationProperties 获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303 数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件 yml 还是 properties 他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 如果说，我们专门编写了一个 javaBean 来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 3、配置文件注入值数据校验123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = &quot;person&quot;)@Validatedpublic class Person &#123; /** * &lt;bean class=&quot;Person&quot;&gt; * &lt;property name=&quot;lastName&quot; value=&quot;字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;&quot;&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 @Email //@Value(&quot;$&#123;person.last-name&#125;&quot;) private String lastName; //@Value(&quot;#&#123;11*2&#125;&quot;) private Integer age; //@Value(&quot;true&quot;) private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 4、@PropertySource&amp;@ImportResource&amp;@Bean@PropertySource：加载指定的配置文件； 123456789101112131415161718192021222324252627282930/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = &quot;person&quot;：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = &quot;person&quot;)默认从全局配置文件中获取值； * */@PropertySource(value = &#123;&quot;classpath:person.properties&quot;&#125;)@Component@ConfigurationProperties(prefix = &quot;person&quot;)//@Validatedpublic class Person &#123; /** * &lt;bean class=&quot;Person&quot;&gt; * &lt;property name=&quot;lastName&quot; value=&quot;字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;&quot;&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 // @Email //@Value(&quot;$&#123;person.last-name&#125;&quot;) private String lastName; //@Value(&quot;#&#123;11*2&#125;&quot;) private Integer age; //@Value(&quot;true&quot;) private Boolean boss; @ImportResource：导入 Spring 的配置文件，让配置文件里面的内容生效； Spring Boot 里面没有 Spring 的配置文件，我们自己编写的配置文件，也不能自动识别； 想让 Spring 的配置文件生效，加载进来；@ImportResource标注在一个配置类上 12@ImportResource(locations = &#123;&quot;classpath:beans.xml&quot;&#125;)导入Spring的配置文件让其生效 不来编写 Spring 的配置文件 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;helloService&quot; class=&quot;com.atguigu.springboot.service.HelloService&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; SpringBoot 推荐给容器中添加组件的方式；推荐使用全注解的方式 1、配置类**@Configuration**——&gt;Spring 配置文件 2、使用**@Bean**给容器中添加组件 12345678910111213141516/** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 * */@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02()&#123; System.out.println(&quot;配置类@Bean给容器中添加组件了...&quot;); return new HelloService(); &#125;&#125; 4、配置文件占位符1、随机数123$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125; 2、占位符获取之前配置的值，如果没有可以是用:指定默认值123456789person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 5、Profile1、多 Profile 文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 默认使用 application.properties 的配置； 2、yml 支持多文档块方式1234567891011121314151617server: port: 8081spring: profiles: active: prod---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境 3、激活指定 profile​ 1、在配置文件中指定 spring.profiles.active=dev ​ 2、命令行： ​ java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev； ​ 可以直接在测试的时候，配置传入命令行参数 ​ 3、虚拟机参数； ​ -Dspring.profiles.active=dev 6、配置文件加载位置springboot 启动会扫描以下位置的 application.properties 或者 application.yml 文件作为 Spring boot 的默认配置文件 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot 会从这四个位置全部加载主配置文件；互补配置； 我们还可以通过 spring.config.location 来改变默认的配置文件位置 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置； java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –spring.config.location=G:/application.properties 7、外部配置加载顺序==SpringBoot 也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置== 【自己测试并没有互补配置】 1.命令行参数 所有的配置都可以在命令行上进行指定 java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context-path=/abc 多个配置用空格分开； –配置项=值 2.来自 java:comp/env 的 JNDI 属性 3.Java 系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource 配置的 random.*属性值 ==由 jar 包外向 jar 包内进行寻找；== ==优先加载带 profile== 6.jar 包外部的 application-{profile}.properties 或 application.yml(带 spring.profile)配置文件 7.jar 包内部的 application-{profile}.properties 或 application.yml(带 spring.profile)配置文件 ==再来加载不带 profile== 8.jar 包外部的 application.properties 或 application.yml(不带 spring.profile)配置文件 9.jar 包内部的 application.properties 或 application.yml(不带 spring.profile)配置文件 10.@Configuration 注解类上的@PropertySource 11.通过 SpringApplication.setDefaultProperties 指定的默认属性 所有支持的配置加载来源； 参考官方文档 8、自动配置原理配置文件到底能写什么？怎么写？自动配置原理； 配置文件能配置的属性参照 1、自动配置原理：1）、SpringBoot 启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration== 2）、@EnableAutoConfiguration 作用： 利用 EnableAutoConfigurationImportSelector 给容器中导入一些组件？ 可以查看 selectImports()方法的内容； List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置 ```javaSpringFactoriesLoader.loadFactoryNames()扫描所有jar包类路径下 META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102**&#x3D;&#x3D;将 类路径下 META-INF&#x2F;spring.factories 里面配置的所有 EnableAutoConfiguration 的值加入到了容器中；&#x3D;&#x3D;**&#96;&#96;&#96;properties# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 每一个这样的 xxxAutoConfiguration 类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 3）、每一个自动配置类进行自动配置功能； 4）、以HttpEncodingAutoConfiguration（Http 编码自动配置）为例解释自动配置原理； 12345678910111213141516171819202122232425262728@Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnProperty(prefix = &quot;spring.http.encoding&quot;, value = &quot;enabled&quot;, matchIfMissing = true) //判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final HttpEncodingProperties properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的 properties 类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 5）、所有在配置文件中能配置的属性都是在 xxxxProperties 类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类 1234@ConfigurationProperties(prefix = &quot;spring.http.encoding&quot;) //从配置文件中获取指定的值和bean的属性进行绑定public class HttpEncodingProperties &#123; public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF-8&quot;); 精髓： ​ 1）、SpringBoot 启动会加载大量的自动配置类 ​ 2）、我们看我们需要的功能有没有 SpringBoot 默认写好的自动配置类； ​ 3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） ​ 4）、给容器中自动配置类添加组件的时候，会从 properties 类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfigurartion：自动配置类； 给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 2、细节1、@Conditional 派生注解（Spring 注解版原生的@Conditional 作用）作用：必须是@Conditional 指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional 扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的 java 版本是否符合要求 @ConditionalOnBean 容器中存在指定 Bean； @ConditionalOnMissingBean 容器中不存在指定 Bean； @ConditionalOnExpression 满足 SpEL 表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的 Bean，或者这个 Bean 是首选 Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是 web 环境 @ConditionalOnNotWebApplication 当前不是 web 环境 @ConditionalOnJndi JNDI 存在指定项 自动配置类必须在一定的条件下才能生效； 我们怎么知道哪些自动配置类生效； **==我们可以通过启用 debug=true 属性；来让控制台打印自动配置报告==**，这样我们就可以很方便的知道哪些自动配置类生效； 123456789101112131415161718192021222324=========================AUTO-CONFIGURATION REPORT=========================Positive matches:（自动配置类启用的）----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class &#x27;org.springframework.web.servlet.DispatcherServlet&#x27;; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition)Negative matches:（没有启动，没有匹配成功的自动配置类）----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes &#x27;javax.jms.ConnectionFactory&#x27;, &#x27;org.apache.activemq.ActiveMQConnectionFactory&#x27; (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes &#x27;org.aspectj.lang.annotation.Aspect&#x27;, &#x27;org.aspectj.lang.reflect.Advice&#x27; (OnClassCondition) 三、日志1、日志框架小张；开发一个大型系统； ​ 1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？ ​ 2、框架来记录系统的一些运行时信息；日志框架 ； zhanglogging.jar； ​ 3、高大上的几个功能？异步模式？自动归档？xxxx？ zhanglogging-good.jar？ ​ 4、将以前框架卸下来？换上新的框架，重新修改之前相关的 API；zhanglogging-prefect.jar； ​ 5、JDBC—数据库驱动； ​ 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar； ​ 给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层； 市面上的日志框架； JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…. 日志门面 （日志的抽象层） 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4j JUL（java.util.logging） Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面： SLF4J； 日志实现：Logback； SpringBoot：底层是 Spring 框架，Spring 框架默认是用 JCL；‘ ​ ==SpringBoot 选用 SLF4j 和 logback；== 2、SLF4j 使用1、如何在系统中使用 SLF4j https://www.slf4j.org以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法； 给系统里面导入 slf4j 的 jar 和 logback 的实现 jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(&quot;Hello World&quot;); &#125;&#125; 图示； 每一个日志的实现框架都有自己的配置文件。使用 slf4j 以后，配置文件还是做成日志实现框架自己本身的配置文件； 2、遗留问题a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用 slf4j 进行输出？ 如何让系统中所有的日志都统一到 slf4j； ==1、将系统中其他日志框架先排除出去；== ==2、用中间包来替换原有的日志框架；== ==3、我们导入 slf4j 其他的实现== 3、SpringBoot 日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot 使用它来做日志功能； 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; 底层依赖关系 总结： ​ 1）、SpringBoot 底层也是使用 slf4j+logback 的方式进行日志记录 ​ 2）、SpringBoot 也把其他的日志都替换成了 slf4j； ​ 3）、中间替换包？ 123456@SuppressWarnings(&quot;rawtypes&quot;)public abstract class LogFactory &#123; static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = &quot;http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j&quot;; static LogFactory logFactory = new SLF4JLogFactory(); ​ 4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？ ​ Spring 框架用的是 commons-logging； 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; ==SpringBoot 能自动适配所有的日志，而且底层使用 slf4j+logback 的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；== 4、日志使用；1、默认配置SpringBoot 默认帮我们配置好了日志； 123456789101112131415161718//记录器Logger logger = LoggerFactory.getLogger(getClass());@Testpublic void contextLoads() &#123; //System.out.println(); //日志的级别； //由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace(&quot;这是trace日志...&quot;); logger.debug(&quot;这是debug日志...&quot;); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别 logger.info(&quot;这是info日志...&quot;); logger.warn(&quot;这是warn日志...&quot;); logger.error(&quot;这是error日志...&quot;);&#125; 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n SpringBoot 修改日志的默认配置 123456789101112131415logging.level.com.atguigu=trace#logging.path=# 不指定路径在当前项目下生成springboot.log日志# 可以指定完整的路径；#logging.file=G:/springboot.log# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件logging.path=/spring/log# 在控制台输出的日志的格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n# 指定文件中日志输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n logging.file logging.path Example Description (none) (none) 只在控制台输出 指定文件名 (none) my.log 输出日志到 my.log 文件 (none) 指定目录 /var/log 输出到指定目录的 spring.log 文件中 2、指定配置给类路径下放上每个日志框架自己的配置文件即可；SpringBoot 就不使用他默认配置的了 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由 SpringBoot 解析日志配置，可以使用 SpringBoot 的高级 Profile 功能 12345&lt;springProfile name=&quot;staging&quot;&gt; &lt;!-- configuration to be enabled when the &quot;staging&quot; profile is active --&gt; 可以指定某段配置只在某个环境下生效&lt;/springProfile&gt; 如： 12345678910111213141516171819&lt;appender name=&quot;stdout&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt; &lt;springProfile name=&quot;dev&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=&quot;!dev&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; &lt;/appender&gt; 如果使用 logback.xml 作为日志配置文件，还要使用 profile 功能，会有以下错误 no applicable action for [springProfile] 5、切换日志框架可以按照 slf4j 的日志适配图，进行相关的切换； slf4j+log4j 的方式； 1234567891011121314151617181920&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 切换为 log4j2 123456789101112131415 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; 四、Web 开发1、简介使用 SpringBoot； 1）、创建 SpringBoot 应用，选中我们需要的模块； 2）、SpringBoot 已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 3）、自己编写业务代码； 自动配置原理？ 这个场景 SpringBoot 帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx 123xxxxAutoConfiguration：帮我们给容器中自动配置组件；xxxxProperties:配置类来封装配置文件的内容； 2、SpringBoot 对静态资源的映射规则；123@ConfigurationProperties(prefix = &quot;spring.resources&quot;, ignoreUnknownFields = false)public class ResourceProperties implements ResourceLoaderAware &#123; //可以设置和静态资源有关的参数，缓存时间等 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465WebMvcAuotConfiguration： @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(&quot;Default resource handling disabled&quot;); return; &#125; Integer cachePeriod = this.resourceProperties.getCachePeriod(); if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(&quot;/webjars/**&quot;) .addResourceLocations( &quot;classpath:/META-INF/resources/webjars/&quot;) .setCachePeriod(cachePeriod)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); //静态资源文件夹映射 if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(staticPathPattern) .addResourceLocations( this.resourceProperties.getStaticLocations()) .setCachePeriod(cachePeriod)); &#125; &#125; //配置欢迎页映射 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping( ResourceProperties resourceProperties) &#123; return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); &#125; //配置喜欢的图标 @Configuration @ConditionalOnProperty(value = &quot;spring.mvc.favicon.enabled&quot;, matchIfMissing = true) public static class FaviconConfiguration &#123; private final ResourceProperties resourceProperties; public FaviconConfiguration(ResourceProperties resourceProperties) &#123; this.resourceProperties = resourceProperties; &#125; @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() &#123; SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); //所有 **/favicon.ico mapping.setUrlMap(Collections.singletonMap(&quot;**/favicon.ico&quot;, faviconRequestHandler())); return mapping; &#125; @Bean public ResourceHttpRequestHandler faviconRequestHandler() &#123; ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler .setLocations(this.resourceProperties.getFaviconLocations()); return requestHandler; &#125; &#125; ==1）、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；== ​ webjars：以 jar 包的方式引入静态资源； http://www.webjars.org/ localhost:8080/webjars/jquery/3.3.1/jquery.js 123456&lt;!--引入jquery-webjar--&gt;在访问的时候只需要写webjars下面资源的名称即可 &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; ==2）、”/**“ 访问当前项目的任何资源，都去（静态资源的文件夹）找映射== 12345&quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;&quot;,&quot;classpath:&#x2F;resources&#x2F;&quot;,&quot;classpath:&#x2F;static&#x2F;&quot;,&quot;classpath:&#x2F;public&#x2F;&quot;&quot;&#x2F;&quot;：当前项目的根路径 localhost:8080/abc === 去静态资源文件夹里面找 abc ==3）、欢迎页； 静态资源文件夹下的所有 index.html 页面；被”/**“映射；== ​ localhost:8080/ 找 index 页面 ==4）、所有的 **/favicon.ico 都是在静态资源文件下找；== 3、模板引擎JSP、Velocity、Freemarker、Thymeleaf SpringBoot 推荐的 Thymeleaf； 语法更简单，功能更强大； 1、引入 thymeleaf；123456789101112 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; 2.1.6 &lt;/dependency&gt;切换thymeleaf版本&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; 2、Thymeleaf 使用1234567891011@ConfigurationProperties(prefix = &quot;spring.thymeleaf&quot;)public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = Charset.forName(&quot;UTF-8&quot;); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(&quot;text/html&quot;); public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;; public static final String DEFAULT_SUFFIX = &quot;.html&quot;; // 只要我们把 HTML 页面放在 classpath:/templates/，thymeleaf 就能自动渲染； 使用： 1、导入 thymeleaf 的名称空间 1&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; 2、使用 thymeleaf 语法； 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为 --&gt; &lt;div th:text=&quot;$&#123;hello&#125;&quot;&gt;这是显示欢迎信息&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 3、语法规则1）、th:text；改变当前元素里面的文本内容； ​ th：任意 html 属性；来替换原生属性的值 2）、表达式？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Simple expressions:（表达式语法） Variable Expressions: $&#123;...&#125;：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. $&#123;session.foo&#125; 3）、内置的一些工具对象：#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样； 补充：配合 th:object=&quot;$&#123;session.user&#125;： &lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt; &lt;p&gt;Name: &lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; Message Expressions: #&#123;...&#125;：获取国际化内容 Link URL Expressions: @&#123;...&#125;：定义URL； @&#123;/order/process(execId=$&#123;execId&#125;,execType=&#x27;FAST&#x27;)&#125; Fragment Expressions: ~&#123;...&#125;：片段引用表达式 &lt;div th:insert=&quot;~&#123;commons :: main&#125;&quot;&gt;...&lt;/div&gt;Literals（字面量） Text literals: &#x27;one text&#x27; , &#x27;Another one!&#x27; ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): -Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No-Operation: _ 4、SpringMVC 自动配置https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications 1. Spring MVC auto-configurationSpring Boot 自动配置好了 SpringMVC 以下是 SpringBoot 对 SpringMVC 的默认配置:==（WebMvcAutoConfiguration）== Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了 ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？）） ContentNegotiatingViewResolver：组合所有的视图解析器的； ==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；== Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars Static index.html support. 静态首页访问 Custom Favicon support (see below). favicon.ico 自动注册了 of Converter, GenericConverter, Formatter beans. Converter：转换器； public String hello(User user)：类型转换使用 Converter Formatter 格式化器； 2017.12.17===Date； 12345@Bean@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;date-format&quot;)//在文件中配置日期格式化的规则public Formatter&lt;Date&gt; dateFormatter() &#123; return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件&#125; ​ ==自己添加的格式化器转换器，我们只需要放在容器中即可== Support for HttpMessageConverters (see below). HttpMessageConverter：SpringMVC 用来转换 Http 请求和响应的；User—Json； HttpMessageConverters 是从容器中确定；获取所有的 HttpMessageConverter； ==自己给容器中添加 HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）== Automatic registration of MessageCodesResolver (see below).定义错误代码生成规则 Automatic use of a ConfigurableWebBindingInitializer bean (see below). ==我们可以配置一个 ConfigurableWebBindingInitializer 来替换默认的；（添加到容器）== 12初始化WebDataBinder；请求数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;JavaBean； org.springframework.boot.autoconfigure.web：web 的所有自动场景； If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 2、扩展 SpringMVC1234567&lt;mvc:view-controller path=&quot;/hello&quot; view-name=&quot;success&quot;/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/hello&quot;/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; ==编写一个配置类（@Configuration），是 WebMvcConfigurerAdapter 类型；不能标注@EnableWebMvc==; 既保留了所有的自动配置，也能用我们扩展的配置； 1234567891011//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(&quot;/atguigu&quot;).setViewName(&quot;success&quot;); &#125;&#125; 原理： ​ 1）、WebMvcAutoConfiguration 是 SpringMVC 的自动配置类 ​ 2）、在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class) 123456789101112131415161718 @Configurationpublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration &#123; private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); //从容器中获取所有的WebMvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用； @Override // public void addViewControllers(ViewControllerRegistry registry) &#123; // for (WebMvcConfigurer delegate : this.delegates) &#123; // delegate.addViewControllers(registry); // &#125; &#125; &#125;&#125; ​ 3）、容器中所有的 WebMvcConfigurer 都会一起起作用； ​ 4）、我们的配置类也会被调用； ​ 效果：SpringMVC 的自动配置和我们的扩展配置都会起作用； 3、全面接管 SpringMVC；SpringBoot 对 SpringMVC 的自动配置不需要了，所有都是我们自己配置；所有的 SpringMVC 的自动配置都失效了 我们需要在配置类中添加@EnableWebMvc 即可； 123456789101112//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@EnableWebMvc@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(&quot;/atguigu&quot;).setViewName(&quot;success&quot;); &#125;&#125; 原理： 为什么@EnableWebMvc 自动配置就失效了； 1）@EnableWebMvc 的核心 12@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc &#123; 2）、 12@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; 3）、 12345678910@Configuration@ConditionalOnWebApplication@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class &#125;)//容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123; 4）、@EnableWebMvc 将 WebMvcConfigurationSupport 组件导入进来； 5）、导入的 WebMvcConfigurationSupport 只是 SpringMVC 最基本的功能； 5、如何修改 SpringBoot 的默认配置模式： ​ 1）、SpringBoot 在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来； ​ 2）、在 SpringBoot 中会有非常多的 xxxConfigurer 帮助我们进行扩展配置 ​ 3）、在 SpringBoot 中会有很多的 xxxCustomizer 帮助我们进行定制配置 6、RestfulCRUD1）、默认访问首页1234567891011121314151617181920212223242526//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能//@EnableWebMvc 不要接管SpringMVC@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(&quot;/atguigu&quot;).setViewName(&quot;success&quot;); &#125; //所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;); registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;login&quot;); &#125; &#125;; return adapter; &#125;&#125; 2）、国际化1）、编写国际化配置文件； 2）、使用 ResourceBundleMessageSource 管理国际化资源文件 3）、在页面使用 fmt:message 取出国际化内容 步骤： 1）、编写国际化配置文件，抽取页面需要显示的国际化消息 2）、SpringBoot 自动配置好了管理国际化资源文件的组件； 12345678910111213141516171819202122232425262728@ConfigurationProperties(prefix = &quot;spring.messages&quot;)public class MessageSourceAutoConfiguration &#123; /** * Comma-separated list of basenames (essentially a fully-qualified classpath * location), each following the ResourceBundle convention with relaxed support for * slash based locations. If it doesn&#x27;t contain a package qualifier (such as * &quot;org.mypackage&quot;), it will be resolved from the classpath root. */ private String basename = &quot;messages&quot;; //我们的配置文件可以直接放在类路径下叫messages.properties； @Bean public MessageSource messageSource() &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(this.basename)) &#123; //设置国际化资源文件的基础名（去掉语言国家代码的） messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(this.basename))); &#125; if (this.encoding != null) &#123; messageSource.setDefaultEncoding(this.encoding.name()); &#125; messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale); messageSource.setCacheSeconds(this.cacheSeconds); messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat); return messageSource; &#125; 3）、去页面获取国际化的值； 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot; /&gt; &lt;meta name=&quot;description&quot; content=&quot;&quot; /&gt; &lt;meta name=&quot;author&quot; content=&quot;&quot; /&gt; &lt;title&gt;Signin Template for Bootstrap&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href=&quot;asserts/css/bootstrap.min.css&quot; th:href=&quot;@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;&quot; rel=&quot;stylesheet&quot; /&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href=&quot;asserts/css/signin.css&quot; th:href=&quot;@&#123;/asserts/css/signin.css&#125;&quot; rel=&quot;stylesheet&quot; /&gt; &lt;/head&gt; &lt;body class=&quot;text-center&quot;&gt; &lt;form class=&quot;form-signin&quot; action=&quot;dashboard.html&quot;&gt; &lt;img class=&quot;mb-4&quot; th:src=&quot;@&#123;/asserts/img/bootstrap-solid.svg&#125;&quot; src=&quot;asserts/img/bootstrap-solid.svg&quot; alt=&quot;&quot; width=&quot;72&quot; height=&quot;72&quot; /&gt; &lt;h1 class=&quot;h3 mb-3 font-weight-normal&quot; th:text=&quot;#&#123;login.tip&#125;&quot;&gt;Please sign in&lt;/h1&gt; &lt;label class=&quot;sr-only&quot; th:text=&quot;#&#123;login.username&#125;&quot;&gt;Username&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Username&quot; th:placeholder=&quot;#&#123;login.username&#125;&quot; required=&quot;&quot; autofocus=&quot;&quot; /&gt; &lt;label class=&quot;sr-only&quot; th:text=&quot;#&#123;login.password&#125;&quot;&gt;Password&lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; th:placeholder=&quot;#&#123;login.password&#125;&quot; required=&quot;&quot; /&gt; &lt;div class=&quot;checkbox mb-3&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; value=&quot;remember-me&quot; /&gt; [[#&#123;login.remember&#125;]] &lt;/label&gt; &lt;/div&gt; &lt;button class=&quot;btn btn-lg btn-primary btn-block&quot; type=&quot;submit&quot; th:text=&quot;#&#123;login.btn&#125;&quot;&gt;Sign in&lt;/button&gt; &lt;p class=&quot;mt-5 mb-3 text-muted&quot;&gt;© 2017-2018&lt;/p&gt; &lt;a class=&quot;btn btn-sm&quot;&gt;中文&lt;/a&gt; &lt;a class=&quot;btn btn-sm&quot;&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 效果：根据浏览器语言设置的信息切换了国际化； 原理： ​ 国际化 Locale（区域信息对象）；LocaleResolver（获取区域信息对象）； 12345678910111213 @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;locale&quot;) public LocaleResolver localeResolver() &#123; if (this.mvcProperties .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; &#125;默认的就是根据请求头带来的区域信息获取Locale进行国际化 4）、点击链接切换国际化 123456789101112131415161718192021222324252627282930/** * 可以在连接上携带区域信息 */public class MyLocaleResolver implements LocaleResolver &#123; @Override public Locale resolveLocale(HttpServletRequest request) &#123; String l = request.getParameter(&quot;l&quot;); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(l))&#123; String[] split = l.split(&quot;_&quot;); locale = new Locale(split[0],split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123; &#125;&#125; @Bean public LocaleResolver localeResolver()&#123; return new MyLocaleResolver(); &#125;&#125; 3）、登陆开发期间模板引擎页面修改以后，要实时生效 1）、禁用模板引擎的缓存 12# 禁用缓存spring.thymeleaf.cache&#x3D;false 2）、页面修改完成以后 ctrl+f9：重新编译； 登陆错误消息的显示 1&lt;p style=&quot;color: red&quot; th:text=&quot;$&#123;msg&#125;&quot; th:if=&quot;$&#123;not #strings.isEmpty(msg)&#125;&quot;&gt;&lt;/p&gt; 4）、拦截器进行登陆检查拦截器 12345678910111213141516171819202122232425262728293031/** * 登陆检查， */public class LoginHandlerInterceptor implements HandlerInterceptor &#123; //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object user = request.getSession().getAttribute(&quot;loginUser&quot;); if(user == null)&#123; //未登陆，返回登陆页面 request.setAttribute(&quot;msg&quot;,&quot;没有权限请先登陆&quot;); request.getRequestDispatcher(&quot;/index.html&quot;).forward(request,response); return false; &#125;else&#123; //已登陆，放行请求 return true; &#125; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 注册拦截器 1234567891011121314151617181920212223//所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;); registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;login&quot;); registry.addViewController(&quot;/main.html&quot;).setViewName(&quot;dashboard&quot;); &#125; //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; //super.addInterceptors(registry); //静态资源； *.css , *.js //SpringBoot 2.x 没有静态资源映射 registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(&quot;/**&quot;) .excludePathPatterns(&quot;/index.html&quot;,&quot;/&quot;,&quot;/user/login&quot;,&quot;/webjars/**&quot;,&quot;/asserts/css/**&quot;,&quot;/asserts/js/**&quot;,&quot;/asserts/img/**&quot;); &#125; &#125;; return adapter; &#125; 5）、CRUD-员工列表实验要求： 1）、RestfulCRUD：CRUD 满足 Rest 风格； URI： /资源名称/资源标识 HTTP 请求方式区分对资源 CRUD 操作 普通 CRUD（uri 来区分操作） RestfulCRUD 查询 getEmp emp—GET 添加 addEmp?xxx emp—POST 修改 updateEmp?id=xxx&amp;xxx=xx emp/{id}—PUT 删除 deleteEmp?id=1 emp/{id}—DELETE 2）、实验的请求架构; 实验功能 请求 URI 请求方式 查询所有员工 emps GET 查询某个员工(来到修改页面) emp/1 GET 来到添加页面 emp GET 添加员工 emp POST 来到修改页面（查出员工进行信息回显） emp/1 GET 修改员工 emp PUT 删除员工 emp/1 DELETE 3）、员工列表： thymeleaf 公共页面元素抽取12345671、抽取公共片段&lt;div th:fragment=&quot;copy&quot;&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;2、引入公共片段&lt;div th:insert=&quot;~&#123;footer :: copy&#125;&quot;&gt;&lt;/div&gt;~&#123;templatename::selector&#125;：模板名::选择器 ~&#123;templatename::fragmentname&#125;:模板名::片段名 3、默认效果： insert的公共片段在div标签中 如果使用th:insert等属性进行引入，可以不用写~&#123;&#125;：行内写法可以加上：[[~&#123;&#125;]];[(~&#123;&#125;)]； 三种引入公共片段的 th 属性： th:insert：将公共片段整个插入到声明引入的元素中 th:replace：将声明引入的元素替换为公共片段 th:include：将被引入的片段的内容包含进这个标签中 123456789101112131415&lt;footer th:fragment=&quot;copy&quot;&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;引入方式&lt;div th:insert=&quot;footer :: copy&quot;&gt;&lt;/div&gt;&lt;div th:replace=&quot;footer :: copy&quot;&gt;&lt;/div&gt;&lt;div th:include=&quot;footer :: copy&quot;&gt;&lt;/div&gt;效果&lt;div&gt; &lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;/div&gt;&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 引入片段的时候传入参数： 1234567891011121314151617181920212223242526272829&lt;nav class=&quot;col-md-2 d-none d-md-block bg-light sidebar&quot; id=&quot;sidebar&quot;&gt; &lt;div class=&quot;sidebar-sticky&quot;&gt; &lt;ul class=&quot;nav flex-column&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link active&quot; th:class=&quot;$&#123;activeUri==&#x27;main.html&#x27;?&#x27;nav-link active&#x27;:&#x27;nav-link&#x27;&#125;&quot; href=&quot;#&quot; th:href=&quot;@&#123;/main.html&#125;&quot;&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;feather feather-home&quot; &gt; &lt;path d=&quot;M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z&quot;&gt;&lt;/path&gt; &lt;polyline points=&quot;9 22 9 12 15 12 15 22&quot;&gt;&lt;/polyline&gt; &lt;/svg&gt; Dashboard &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;!--引入侧边栏;传入参数--&gt; &lt;div th:replace=&quot;commons/bar::#sidebar(activeUri=&#x27;emps&#x27;)&quot;&gt;&lt;/div&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/nav&gt; 6）、CRUD-员工添加添加页面 123456789101112131415161718192021222324252627282930313233343536&lt;form&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input type=&quot;email&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan@atguigu.com&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br /&gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; /&gt; &lt;label class=&quot;form-check-label&quot;&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; /&gt; &lt;label class=&quot;form-check-label&quot;&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;department&lt;/label&gt; &lt;select class=&quot;form-control&quot;&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot; /&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;添加&lt;/button&gt;&lt;/form&gt; 提交的数据格式不对：生日：日期； 2017-12-12；2017/12/12；2017.12.12； 日期的格式化；SpringMVC 将页面提交的值需要转换为指定的类型; 2017-12-12—Date； 类型转换，格式化; 默认日期是按照/的方式； 7）、CRUD-员工修改修改添加二合一表单 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--需要区分是员工修改还是添加；--&gt;&lt;form th:action=&quot;@&#123;/emp&#125;&quot; method=&quot;post&quot;&gt; &lt;!--发送put请求修改员工数据--&gt; &lt;!--1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）2、页面创建一个post表单3、创建一个input项，name=&quot;_method&quot;;值就是我们指定的请求方式--&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot; th:if=&quot;$&#123;emp!=null&#125;&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; th:if=&quot;$&#123;emp!=null&#125;&quot; th:value=&quot;$&#123;emp.id&#125;&quot; /&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name=&quot;lastName&quot; type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot; th:value=&quot;$&#123;emp!=null&#125;?$&#123;emp.lastName&#125;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name=&quot;email&quot; type=&quot;email&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan@atguigu.com&quot; th:value=&quot;$&#123;emp!=null&#125;?$&#123;emp.email&#125;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br /&gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; th:checked=&quot;$&#123;emp!=null&#125;?$&#123;emp.gender==1&#125;&quot; /&gt; &lt;label class=&quot;form-check-label&quot;&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; th:checked=&quot;$&#123;emp!=null&#125;?$&#123;emp.gender==0&#125;&quot; /&gt; &lt;label class=&quot;form-check-label&quot;&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;department&lt;/label&gt; &lt;!--提交的是部门的id--&gt; &lt;select class=&quot;form-control&quot; name=&quot;department.id&quot;&gt; &lt;option th:selected=&quot;$&#123;emp!=null&#125;?$&#123;dept.id == emp.department.id&#125;&quot; th:value=&quot;$&#123;dept.id&#125;&quot; th:each=&quot;dept:$&#123;depts&#125;&quot; th:text=&quot;$&#123;dept.departmentName&#125;&quot;&gt;1&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input name=&quot;birth&quot; type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot; th:value=&quot;$&#123;emp!=null&#125;?$&#123;#dates.format(emp.birth, &#x27;yyyy-MM-dd HH:mm&#x27;)&#125;&quot; /&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot; th:text=&quot;$&#123;emp!=null&#125;?&#x27;修改&#x27;:&#x27;添加&#x27;&quot;&gt;添加&lt;/button&gt;&lt;/form&gt; 8）、CRUD-员工删除123456789101112131415161718192021&lt;tr th:each=&quot;emp:$&#123;emps&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;emp.id&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt;[[$&#123;emp.lastName&#125;]]&lt;/td&gt; &lt;td th:text=&quot;$&#123;emp.email&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;emp.gender&#125;==0?&#x27;女&#x27;:&#x27;男&#x27;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;emp.department.departmentName&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;#dates.format(emp.birth, &#x27;yyyy-MM-dd HH:mm&#x27;)&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;a class=&quot;btn btn-sm btn-primary&quot; th:href=&quot;@&#123;/emp/&#125;+$&#123;emp.id&#125;&quot;&gt;编辑&lt;/a&gt; &lt;button th:attr=&quot;del_uri=@&#123;/emp/&#125;+$&#123;emp.id&#125;&quot; class=&quot;btn btn-sm btn-danger deleteBtn&quot;&gt;删除&lt;/button&gt; &lt;/td&gt;&lt;/tr&gt;&lt;script&gt; $(&#x27;.deleteBtn&#x27;).click(function () &#123; //删除当前员工的 $(&#x27;#deleteEmpForm&#x27;).attr(&#x27;action&#x27;, $(this).attr(&#x27;del_uri&#x27;)).submit(); return false; &#125;);&lt;/script&gt;最新版本的spring boot 默认不开启 restful 分割api 123456会报错：Resolved [org.springframework.web.HttpRequestMethodNotSupportedException: Request method &#39;DELETE&#39; not supported]原因：最新版本的spring boot 默认不开启 restful 分割api开启办法:# 启用hiddenMethod过滤器spring.mvc.hiddenmethod.filter.enabled&#x3D;true 7、错误处理机制1）、SpringBoot 默认的错误处理机制默认效果： ​ 1）、浏览器，返回一个默认的错误页面 浏览器发送请求的请求头： ​ 2）、如果是其他客户端，默认响应一个 json 数据 ​ 原理： ​ 可以参照 ErrorMvcAutoConfiguration；错误处理的自动配置； 给容器中添加了以下组件 ​ 1、DefaultErrorAttributes： 1234567891011帮我们在页面共享信息；@Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;(); errorAttributes.put(&quot;timestamp&quot;, new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes; &#125; ​ 2、BasicErrorController：处理默认/error 请求 12345678910111213141516171819202122232425@Controller@RequestMapping(&quot;$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;&quot;)public class BasicErrorController extends AbstractErrorController &#123; @RequestMapping(produces = &quot;text/html&quot;)//产生html类型的数据；浏览器发送的请求来到这个方法处理 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView(&quot;error&quot;, model) : modelAndView); &#125; @RequestMapping @ResponseBody //产生json数据，其他客户端来到这个方法处理； public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); &#125; ​ 3、ErrorPageCustomizer： 12@Value(&quot;$&#123;error.path:/error&#125;&quot;)private String path = &quot;/error&quot;; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则） ​ 4、DefaultErrorViewResolver： 123456789101112131415161718192021222324@Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView; &#125; private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; //默认SpringBoot可以去找到一个页面？ error/404 String errorViewName = &quot;error/&quot; + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); &#125; //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model); &#125; ​ 步骤： ​ 一但系统出现 4xx 或者 5xx 之类的错误；ErrorPageCustomizer 就会生效（定制错误的响应规则）；就会来到/error 请求；就会被BasicErrorController处理； ​ 1）响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的； 1234567891011protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) &#123; //所有的ErrorViewResolver得到ModelAndView for (ErrorViewResolver resolver : this.errorViewResolvers) &#123; ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) &#123; return modelAndView; &#125; &#125; return null;&#125; 2）、如果定制错误响应：1）、如何定制错误的页面；​ 1）、有模板引擎的情况下；error/状态码; 【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的 error 文件夹下】，发生此状态码的错误就会来到 对应的页面； ​ 我们可以使用 4xx 和 5xx 作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）； ​ 页面能获取的信息； ​ timestamp：时间戳 ​ status：状态码 ​ error：错误提示 ​ exception：异常对象 ​ message：异常消息 ​ errors：JSR303 数据校验的错误都在这里 ​ 2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找； ​ 3）、以上都没有错误页面，就是默认来到 SpringBoot 默认的错误提示页面； 2）、如何定制错误的 json 数据；​ 1）、自定义异常处理&amp;返回定制 json 数据； 12345678910111213@ControllerAdvicepublic class MyExceptionHandler &#123; @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String,Object&gt; handleException(Exception e)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;code&quot;,&quot;user.notexist&quot;); map.put(&quot;message&quot;,e.getMessage()); return map; &#125;&#125;//没有自适应效果... ​ 2）、转发到/error 进行自适应响应效果处理 1234567891011121314@ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 /** * Integer statusCode = (Integer) request .getAttribute(&quot;javax.servlet.error.status_code&quot;); */ request.setAttribute(&quot;javax.servlet.error.status_code&quot;,500); map.put(&quot;code&quot;,&quot;user.notexist&quot;); map.put(&quot;message&quot;,e.getMessage()); //转发到/error return &quot;forward:/error&quot;; &#125; 3）、将我们的定制数据携带出去；出现错误以后，会来到/error 请求，会被 BasicErrorController 处理，响应出去可以获取的数据是由 getErrorAttributes 得到的（是 AbstractErrorController（ErrorController）规定的方法）； ​ 1、完全来编写一个 ErrorController 的实现类【或者是编写 AbstractErrorController 的子类】，放在容器中； ​ 2、页面上能用的数据，或者是 json 返回能用的数据都是通过 errorAttributes.getErrorAttributes 得到； ​ 容器中 DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的； 自定义 ErrorAttributes 1234567891011//给容器中加入我们自己定义的ErrorAttributes@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace); map.put(&quot;company&quot;,&quot;atguigu&quot;); return map; &#125;&#125; 最终的效果：响应是自适应的，可以通过定制 ErrorAttributes 改变需要返回的内容， 8、配置嵌入式 Servlet 容器SpringBoot 默认使用 Tomcat 作为嵌入式的 Servlet 容器； 问题？ 1）、如何定制和修改 Servlet 容器的相关配置；1、修改和 server 有关的配置 123456789server.port=8081server.context-path=/crudserver.tomcat.uri-encoding=UTF-8//通用的Servlet容器设置server.xxx//Tomcat的设置server.tomcat.xxx 2、编写一个WebServerFactoryCustomizer：嵌入式的 Servlet 容器的定制器；来修改 Servlet 容器的配置 1234567891011@Bean public WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt; webServerFactoryCustomizer()&#123; return new WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt;() &#123; // 定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableWebServerFactory factory) &#123; factory.setPort(8081); &#125; &#125;; &#125; 2）、注册 Servlet 三大组件【Servlet、Filter、Listener】由于 SpringBoot 默认是以 jar 包的方式启动嵌入式的 Servlet 容器来启动 SpringBoot 的 web 应用，没有 web.xml 文件。 注册三大组件用以下方式 ServletRegistrationBean 1234567//注册三大组件@Beanpublic ServletRegistrationBean myServlet()&#123; ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),&quot;/myServlet&quot;); return registrationBean;&#125; FilterRegistrationBean 1234567@Beanpublic FilterRegistrationBean myFilter()&#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList(&quot;/hello&quot;,&quot;/myServlet&quot;)); return registrationBean;&#125; ServletListenerRegistrationBean 12345@Beanpublic ServletListenerRegistrationBean myListener()&#123; ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener()); return registrationBean;&#125; SpringBoot 帮我们自动 SpringMVC 的时候，自动的注册 SpringMVC 的前端控制器；DIspatcherServlet； DispatcherServletAutoConfiguration 中： 123456789101112131415161718@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)public ServletRegistrationBean dispatcherServletRegistration( DispatcherServlet dispatcherServlet) &#123; ServletRegistrationBean registration = new ServletRegistrationBean( dispatcherServlet, this.serverProperties.getServletMapping()); //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径 registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); registration.setLoadOnStartup( this.webMvcProperties.getServlet().getLoadOnStartup()); if (this.multipartConfig != null) &#123; registration.setMultipartConfig(this.multipartConfig); &#125; return registration;&#125; 2）、SpringBoot 能不能支持其他的 Servlet 容器； 3）、替换为其他嵌入式 Servlet 容器 默认支持： Tomcat（默认使用） 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; 引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；&lt;/dependency&gt; Jetty 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; Undertow 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; 4）、嵌入式 Servlet 容器自动配置原理；EmbeddedServletContainerAutoConfiguration：嵌入式的 Servlet 容器自动配置？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Configuration@ConditionalOnWebApplication@Import(BeanPostProcessorsRegistrar.class)//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：//后置处理器：bean初始化前后（创建完对象，还没属性赋值）执行初始化工作public class EmbeddedServletContainerAutoConfiguration &#123; @Configuration @ConditionalOnClass(&#123; Servlet.class, Tomcat.class &#125;)//判断当前是否引入了Tomcat依赖； @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器 public static class EmbeddedTomcat &#123; @Bean public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() &#123; return new TomcatEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Jetty is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Server.class, Loader.class, WebAppContext.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedJetty &#123; @Bean public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() &#123; return new JettyEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Undertow is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedUndertow &#123; @Bean public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() &#123; return new UndertowEmbeddedServletContainerFactory(); &#125; &#125; 1）、EmbeddedServletContainerFactory（嵌入式 Servlet 容器工厂） 1234567public interface EmbeddedServletContainerFactory &#123; //获取嵌入式的Servlet容器 EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers);&#125; 2）、EmbeddedServletContainer：（嵌入式的 Servlet 容器） 3）、以TomcatEmbeddedServletContainerFactory为例 123456789101112131415161718192021222324@Overridepublic EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers) &#123; //创建一个Tomcat Tomcat tomcat = new Tomcat(); //配置Tomcat的基本环节 File baseDir = (this.baseDirectory != null ? this.baseDirectory : createTempDir(&quot;tomcat&quot;)); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) &#123; tomcat.getService().addConnector(additionalConnector); &#125; prepareContext(tomcat.getHost(), initializers); //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器 return getTomcatEmbeddedServletContainer(tomcat);&#125; 4）、我们对嵌入式容器的配置修改是怎么生效？ 1ServerProperties、EmbeddedServletContainerCustomizer EmbeddedServletContainerCustomizer：定制器帮我们修改了 Servlet 容器的配置？ 怎么修改的原理？ 5）、容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor 12345678910111213141516171819202122232425262728293031323334353637//初始化之前@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件 if (bean instanceof ConfigurableEmbeddedServletContainer) &#123; // postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean); &#125; return bean;&#125;private void postProcessBeforeInitialization( ConfigurableEmbeddedServletContainer bean) &#123; //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值； for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123; customizer.customize(bean); &#125;&#125;private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() &#123; if (this.customizers == null) &#123; // Look up does not include the parent context this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;( this.beanFactory //从容器中获取所有这个类型的组件：EmbeddedServletContainerCustomizer //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件 .getBeansOfType(EmbeddedServletContainerCustomizer.class, false, false) .values()); Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); &#125; return this.customizers;&#125;ServerProperties也是定制器 步骤： 1）、SpringBoot 根据导入的依赖情况，给容器中添加相应的 EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】 2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor； 只要是嵌入式的 Servlet 容器工厂，后置处理器就工作； 3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法 ###5）、嵌入式 Servlet 容器启动原理； 什么时候创建嵌入式的 Servlet 容器工厂？什么时候获取嵌入式的 Servlet 容器并启动 Tomcat； 获取嵌入式的 Servlet 容器工厂： 1）、SpringBoot 应用启动运行 run 方法 2）、refreshContext(context);SpringBoot 刷新 IOC 容器【创建 IOC 容器对象，并初始化容器，创建容器中的每一个组件】；如果是 web 应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：AnnotationConfigApplicationContext 3）、refresh(context);刷新刚才创建好的 ioc 容器； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(&quot;Exception encountered during context initialization - &quot; + &quot;cancelling refresh attempt: &quot; + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset &#x27;active&#x27; flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring&#x27;s core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 4）、 onRefresh(); web 的 ioc 容器重写了 onRefresh 方法 5）、webioc 容器会创建嵌入式的 Servlet 容器；createEmbeddedServletContainer(); 6）、获取嵌入式的 Servlet 容器工厂： EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory(); ​ 从 ioc 容器中获取 EmbeddedServletContainerFactory 组件；TomcatEmbeddedServletContainerFactory创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制 Servlet 容器的相关配置； 7）、使用容器工厂获取嵌入式的 Servlet 容器：this.embeddedServletContainer = containerFactory .getEmbeddedServletContainer(getSelfInitializer()); 8）、嵌入式的 Servlet 容器创建对象并启动 Servlet 容器； 先启动嵌入式的 Servlet 容器，再将 ioc 容器中剩下没有创建出的对象获取出来； ==IOC 容器启动创建嵌入式的 Servlet 容器== 9、使用外置的 Servlet 容器嵌入式 Servlet 容器：应用打成可执行的 jar ​ 优点：简单、便携； ​ 缺点：默认不支持 JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义 EmbeddedServletContainerCustomizer】，自己编写嵌入式 Servlet 容器的创建工厂【EmbeddedServletContainerFactory】）； 外置的 Servlet 容器：外面安装 Tomcat—应用 war 包的方式打包； 步骤1）、必须创建一个 war 项目；（利用 idea 创建好目录结构） 2）、将嵌入式的 Tomcat 指定为 provided； 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 3）、必须编写一个SpringBootServletInitializer的子类，并调用 configure 方法 123456789public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; //传入SpringBoot应用的主程序 return application.sources(SpringBoot04WebJspApplication.class); &#125;&#125; 4）、启动服务器就可以使用； 原理jar 包：执行 SpringBoot 主类的 main 方法，启动 ioc 容器，创建嵌入式的 Servlet 容器； war 包：启动服务器，服务器启动 SpringBoot 应用【SpringBootServletInitializer】，启动 ioc 容器； servlet3.0（Spring 注解版）： 8.2.4 Shared libraries / runtimes pluggability： 规则： ​ 1）、服务器启动（web 应用启动）会创建当前 web 应用里面每一个 jar 包里面 ServletContainerInitializer 实例： ​ 2）、ServletContainerInitializer 的实现放在 jar 包的 META-INF/services 文件夹下，有一个名为 javax.servlet.ServletContainerInitializer 的文件，内容就是 ServletContainerInitializer 的实现类的全类名 ​ 3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类； 流程： 1）、启动 Tomcat 2）、org\\springframework\\spring-web\\4.3.14.RELEASE\\spring-web-4.3.14.RELEASE.jar!\\META-INF\\services\\javax.servlet.ServletContainerInitializer： Spring 的 web 模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer 3）、SpringServletContainerInitializer 将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到 onStartup 方法的 Set&lt;Class&lt;?&gt;&gt;；为这些 WebApplicationInitializer 类型的类创建实例； 4）、每一个 WebApplicationInitializer 都调用自己的 onStartup； 5）、相当于我们的 SpringBootServletInitializer 的类会被创建对象，并执行 onStartup 方法 6）、SpringBootServletInitializer 实例执行 onStartup 的时候会 createRootApplicationContext；创建容器 1234567891011121314151617181920212223242526272829303132333435363738protected WebApplicationContext createRootApplicationContext( ServletContext servletContext) &#123; //1、创建SpringApplicationBuilder SpringApplicationBuilder builder = createSpringApplicationBuilder(); StandardServletEnvironment environment = new StandardServletEnvironment(); environment.initPropertySources(servletContext, null); builder.environment(environment); builder.main(getClass()); ApplicationContext parent = getExistingRootWebApplicationContext(servletContext); if (parent != null) &#123; this.logger.info(&quot;Root context already created (using as parent).&quot;); servletContext.setAttribute( WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null); builder.initializers(new ParentContextApplicationContextInitializer(parent)); &#125; builder.initializers( new ServletContextApplicationContextInitializer(servletContext)); builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class); //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来 builder = configure(builder); //使用builder创建一个Spring应用 SpringApplication application = builder.build(); if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils .findAnnotation(getClass(), Configuration.class) != null) &#123; application.getSources().add(getClass()); &#125; Assert.state(!application.getSources().isEmpty(), &quot;No SpringApplication sources have been defined. Either override the &quot; + &quot;configure method or add an @Configuration annotation&quot;); // Ensure error pages are registered if (this.registerErrorPageFilter) &#123; application.getSources().add(ErrorPageFilterConfiguration.class); &#125; //启动Spring应用 return run(application);&#125; 7）、Spring 的应用就启动并且创建 IOC 容器 1234567891011121314151617181920212223242526272829303132333435public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try &#123; ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); Banner printedBanner = printBanner(environment); context = createApplicationContext(); analyzers = new FailureAnalyzers(context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新IOC容器 refreshContext(context); afterRefresh(context, applicationArguments); listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; ==启动 Servlet 容器，再启动 SpringBoot 应用== 五、Docker1、简介Docker是一个开源的应用容器引擎；是一个轻量级容器技术； Docker 支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像； 运行中的这个镜像称为容器，容器启动是非常快速的。 2、核心概念docker 主机(Host)：安装了 Docker 程序的机器（Docker 直接安装在操作系统之上）； docker 客户端(Client)：连接 docker 主机进行操作； docker 仓库(Registry)：用来保存各种打包好的软件镜像； docker 镜像(Images)：软件打包好的镜像；放在 docker 仓库中； docker 容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用 使用 Docker 的步骤： 1）、安装 Docker 2）、去 Docker 仓库找到这个软件对应的镜像； 3）、使用 Docker 运行这个镜像，这个镜像就会生成一个 Docker 容器； 4）、对容器的启动停止就是对软件的启动停止； 3、安装 Docker1）、安装 linux 虚拟机​ 1）、VMWare、VirtualBox（安装）； ​ 2）、导入虚拟机文件 centos7-atguigu.ova； ​ 3）、双击启动 linux 虚拟机;使用 root/ 123456 登陆 ​ 4）、使用客户端连接 linux 服务器进行命令操作； ​ 5）、设置虚拟机网络； ​ 桥接网络===选好网卡====接入网线； ​ 6）、设置好网络以后使用命令重启虚拟机的网络 1service network restart ​ 7）、查看 linux 的 ip 地址 1ip addr ​ 8）、使用客户端连接 linux； 2）、在 linux 虚拟机上安装 docker步骤： 12345678910111213141、检查内核版本，必须是3.10及以上uname -r2、安装dockeryum install docker3、输入y确认安装4、启动docker[root@localhost ~]# systemctl start docker[root@localhost ~]# docker -vDocker version 1.12.6, build 3e8e77d/1.12.65、开机启动docker[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.6、停止dockersystemctl stop docker 4、Docker 常用命令&amp;操作1）、镜像操作 操作 命令 说明 检索 docker search 关键字 eg：docker search redis 我们经常去 docker hub 上检索镜像的详细信息，如镜像的 TAG。 拉取 docker pull 镜像名:tag :tag 是可选的，tag 表示标签，多为软件的版本，默认是 latest 列表 docker images 查看所有本地镜像 删除 docker rmi image-id 删除指定的本地镜像 https://hub.docker.com/ 2）、容器操作软件镜像（QQ 安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的 QQ）； 步骤： 123456789101112131415161718192021222324252627282930311、搜索镜像[root@localhost ~]# docker search tomcat2、拉取镜像[root@localhost ~]# docker pull tomcat3、根据镜像启动容器docker run --name mytomcat -d tomcat:latest4、docker ps查看运行中的容器5、 停止运行中的容器docker stop 容器的id6、查看所有的容器docker ps -a7、启动容器docker start 容器id8、删除一个容器 docker rm 容器id9、启动一个做了端口映射的tomcat[root@localhost ~]# docker run -d -p 8888:8080 tomcat-d：后台运行-p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口10、为了演示简单关闭了linux的防火墙service firewalld status ；查看防火墙状态service firewalld stop：关闭防火墙11、查看容器的日志docker logs container-name/container-id更多命令参看https://docs.docker.com/engine/reference/commandline/docker/可以参考每一个镜像的文档 3）、安装 MySQL 示例1docker pull mysql 错误的启动 1234567891011121314151617[root@localhost ~]# docker run --name mysql01 -d mysql42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846mysql退出了[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES42f09819908b mysql &quot;docker-entrypoint.sh&quot; 34 seconds ago Exited (1) 33 seconds ago mysql01538bde63e500 tomcat &quot;catalina.sh run&quot; About an hour ago Exited (143) About an hour ago compassionate_goldstinec4f1ac60b3fc tomcat &quot;catalina.sh run&quot; About an hour ago Exited (143) About an hour ago lonely_fermi81ec743a5271 tomcat &quot;catalina.sh run&quot; About an hour ago Exited (143) About an hour ago sick_ramanujan//错误日志[root@localhost ~]# docker logs 42f09819908berror: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个 正确的启动 12345[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb874c56bec49 mysql &quot;docker-entrypoint.sh&quot; 4 seconds ago Up 3 seconds 3306/tcp mysql01 做了端口映射 12345[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESad10e4bc5c6a mysql &quot;docker-entrypoint.sh&quot; 4 seconds ago Up 2 seconds 0.0.0.0:3306-&gt;3306/tcp mysql02 几个其他的高级操作 123456docker run --name mysql03 -v &#x2F;conf&#x2F;mysql:&#x2F;etc&#x2F;mysql&#x2F;conf.d -e MYSQL_ROOT_PASSWORD&#x3D;my-secret-pw -d mysql:tag把主机的&#x2F;conf&#x2F;mysql文件夹挂载到 mysqldocker容器的&#x2F;etc&#x2F;mysql&#x2F;conf.d文件夹里面改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（&#x2F;conf&#x2F;mysql）docker run --name some-mysql -e MYSQL_ROOT_PASSWORD&#x3D;my-secret-pw -d mysql:tag --character-set-server&#x3D;utf8mb4 --collation-server&#x3D;utf8mb4_unicode_ci指定mysql的一些配置参数 六、SpringBoot 与数据访问1、JDBC123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 123456spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.15.22:3306/jdbc driver-class-name: com.mysql.jdbc.Driver 效果： ​ 默认是用 org.apache.tomcat.jdbc.pool.DataSource 作为数据源； ​ 数据源的相关配置都在 DataSourceProperties 里面； 自动配置原理： org.springframework.boot.autoconfigure.jdbc： 1、参考 DataSourceConfiguration，根据配置创建数据源，默认使用 Tomcat 连接池；可以使用 spring.datasource.type 指定自定义的数据源类型； 2、SpringBoot 默认可以支持； 1org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、 3、自定义数据源类型 1234567891011121314/** * Generic DataSource configuration. */@ConditionalOnMissingBean(DataSource.class)@ConditionalOnProperty(name = &quot;spring.datasource.type&quot;)static class Generic &#123; @Bean public DataSource dataSource(DataSourceProperties properties) &#123; //使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性 return properties.initializeDataSourceBuilder().build(); &#125;&#125; 4、DataSourceInitializer：ApplicationListener； ​ 作用： ​ 1）、runSchemaScripts();运行建表语句； ​ 2）、runDataScripts();运行插入数据的 sql 语句； 默认只需要将文件命名为： 123456schema-*.sql、data-*.sql默认规则：schema.sql，schema-all.sql；可以使用 schema: - classpath:department.sql 指定位置 5、操作数据库：自动配置了 JdbcTemplate 操作数据库 2、整合 Druid 数据源1234567891011121314151617181920212223242526272829303132333435363738394041424344导入druid数据源@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) @Bean public DataSource druid()&#123; return new DruidDataSource(); &#125; //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(&quot;loginUsername&quot;,&quot;admin&quot;); initParams.put(&quot;loginPassword&quot;,&quot;123456&quot;); initParams.put(&quot;allow&quot;,&quot;&quot;);//默认就是允许所有访问 initParams.put(&quot;deny&quot;,&quot;192.168.15.21&quot;); bean.setInitParameters(initParams); return bean; &#125; //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;)); return bean; &#125;&#125; 3、整合 MyBatis12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; 步骤： ​ 1）、配置数据源相关属性（见上一节 Druid） ​ 2）、给数据库建表 ​ 3）、创建 JavaBean 4）、注解版1234567891011121314151617//指定这是一个操作数据库的mapper@Mapperpublic interface DepartmentMapper &#123; @Select(&quot;select * from department where id=#&#123;id&#125;&quot;) public Department getDeptById(Integer id); @Delete(&quot;delete from department where id=#&#123;id&#125;&quot;) public int deleteDeptById(Integer id); @Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;) @Insert(&quot;insert into department(departmentName) values(#&#123;departmentName&#125;)&quot;) public int insertDept(Department department); @Update(&quot;update department set departmentName=#&#123;departmentName&#125; where id=#&#123;id&#125;&quot;) public int updateDept(Department department);&#125; 问题： 自定义 MyBatis 的配置规则；给容器中添加一个 ConfigurationCustomizer； 1234567891011121314@org.springframework.context.annotation.Configurationpublic class MyBatisConfig &#123; @Bean public ConfigurationCustomizer configurationCustomizer()&#123; return new ConfigurationCustomizer()&#123; @Override public void customize(Configuration configuration) &#123; configuration.setMapUnderscoreToCamelCase(true); &#125; &#125;; &#125;&#125; 123456789使用MapperScan批量扫描所有的Mapper接口；@MapperScan(value = &quot;com.atguigu.springboot.mapper&quot;)@SpringBootApplicationpublic class SpringBoot06DataMybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot06DataMybatisApplication.class, args); &#125;&#125; 5）、配置文件版123mybatis: config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置 mapper-locations: classpath:mybatis/mapper/*.xml 指定sql映射文件的位置 更多使用参照 http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/ 4、整合 SpringData JPA1）、SpringData 简介 2）、整合 SpringData JPAJPA:ORM（Object Relational Mapping）； 1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系； 12345678910111213//使用JPA注解配置映射关系@Entity //告诉JPA这是一个实体类（和数据表映射的类）@Table(name = &quot;tbl_user&quot;) //@Table来指定和哪个数据表对应;如果省略默认表名就是user；public class User &#123; @Id //这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键 private Integer id; @Column(name = &quot;last_name&quot;,length = 50) //这是和数据表对应的一个列 private String lastName; @Column //省略默认列名就是属性名 private String email; 2）、编写一个 Dao 接口来操作实体类对应的数据表（Repository） 1234//继承JpaRepository来完成对数据库的操作public interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;&#125; 3）、基本的配置 JpaProperties 1234567spring: jpa: hibernate: # 更新或者创建数据表结构 ddl-auto: update # 控制台显示SQL show-sql: true 七、启动配置原理几个重要的事件回调机制 配置在 META-INF/spring.factories ApplicationContextInitializer SpringApplicationRunListener 只需要放在 ioc 容器中 ApplicationRunner CommandLineRunner 启动流程： 1、创建 SpringApplication 对象12345678910111213141516initialize(sources);private void initialize(Object[] sources) &#123; //保存主配置类 if (sources != null &amp;&amp; sources.length &gt; 0) &#123; this.sources.addAll(Arrays.asList(sources)); &#125; //判断当前是否一个web应用 this.webEnvironment = deduceWebEnvironment(); //从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来 setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); //从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //从多个配置类中找到有main方法的主配置类 this.mainApplicationClass = deduceMainApplicationClass();&#125; 2、运行 run 方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); //获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories SpringApplicationRunListeners listeners = getRunListeners(args); //回调所有的获取SpringApplicationRunListener.starting()方法 listeners.starting(); try &#123; //封装命令行参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); //准备环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); //创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成 Banner printedBanner = printBanner(environment); //创建ApplicationContext；决定创建web的ioc还是普通的ioc context = createApplicationContext(); analyzers = new FailureAnalyzers(context); //准备上下文环境;将environment保存到ioc中；而且applyInitializers()； //applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法 //回调所有的SpringApplicationRunListener的contextPrepared()； // prepareContext(context, environment, listeners, applicationArguments, printedBanner); //prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）； //s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版 //扫描，创建，加载所有组件的地方；（配置类，组件，自动配置） refreshContext(context); //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调 //ApplicationRunner先回调，CommandLineRunner再回调 afterRefresh(context, applicationArguments); //所有的SpringApplicationRunListener回调finished方法 listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; //整个SpringBoot应用启动完成以后返回启动的ioc容器； return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; 3、事件监听机制配置在 META-INF/spring.factories ApplicationContextInitializer 1234567public class HelloApplicationContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; &#123; @Override public void initialize(ConfigurableApplicationContext applicationContext) &#123; System.out.println(&quot;ApplicationContextInitializer...initialize...&quot;+applicationContext); &#125;&#125; SpringApplicationRunListener 12345678910111213141516171819202122232425262728293031323334public class HelloSpringApplicationRunListener implements SpringApplicationRunListener &#123; //必须有的构造器 public HelloSpringApplicationRunListener(SpringApplication application, String[] args)&#123; &#125; @Override public void starting() &#123; System.out.println(&quot;SpringApplicationRunListener...starting...&quot;); &#125; @Override public void environmentPrepared(ConfigurableEnvironment environment) &#123; Object o = environment.getSystemProperties().get(&quot;os.name&quot;); System.out.println(&quot;SpringApplicationRunListener...environmentPrepared..&quot;+o); &#125; @Override public void contextPrepared(ConfigurableApplicationContext context) &#123; System.out.println(&quot;SpringApplicationRunListener...contextPrepared...&quot;); &#125; @Override public void contextLoaded(ConfigurableApplicationContext context) &#123; System.out.println(&quot;SpringApplicationRunListener...contextLoaded...&quot;); &#125; @Override public void finished(ConfigurableApplicationContext context, Throwable exception) &#123; System.out.println(&quot;SpringApplicationRunListener...finished...&quot;); &#125;&#125; 配置（META-INF/spring.factories） 12345org.springframework.context.ApplicationContextInitializer=\\com.atguigu.springboot.listener.HelloApplicationContextInitializerorg.springframework.boot.SpringApplicationRunListener=\\com.atguigu.springboot.listener.HelloSpringApplicationRunListener 只需要放在 ioc 容器中 ApplicationRunner 1234567@Componentpublic class HelloApplicationRunner implements ApplicationRunner &#123; @Override public void run(ApplicationArguments args) throws Exception &#123; System.out.println(&quot;ApplicationRunner...run....&quot;); &#125;&#125; CommandLineRunner 1234567@Componentpublic class HelloCommandLineRunner implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println(&quot;CommandLineRunner...run...&quot;+ Arrays.asList(args)); &#125;&#125; 八、自定义 starterstarter： ​ 1、这个场景需要使用到的依赖是什么？ ​ 2、如何编写自动配置 12345678910111213@Configuration //指定这个类是一个配置类@ConditionalOnXXX //在指定条件成立的情况下自动配置类生效@AutoConfigureAfter //指定自动配置类的顺序@Bean //给容器中添加组件@ConfigurationPropertie结合相关xxxProperties类来绑定相关的配置@EnableConfigurationProperties //让xxxProperties生效加入到容器中自动配置类要能加载将需要启动就加载的自动配置类，配置在META-INF/spring.factoriesorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\ ​ 3、模式： 启动器只用来做依赖导入； 专门来写一个自动配置模块； 启动器依赖自动配置；别人只需要引入启动器（starter） mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter 步骤： 1）、启动器模块 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--启动器--&gt; &lt;dependencies&gt; &lt;!--引入自动配置模块--&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2）、自动配置模块 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--引入spring-boot-starter；所有starter的基本配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 123456789101112131415161718192021222324252627package com.atguigu.starter;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(prefix = &quot;atguigu.hello&quot;)public class HelloProperties &#123; private String prefix; private String suffix; public String getPrefix() &#123; return prefix; &#125; public void setPrefix(String prefix) &#123; this.prefix = prefix; &#125; public String getSuffix() &#123; return suffix; &#125; public void setSuffix(String suffix) &#123; this.suffix = suffix; &#125;&#125; 12345678910111213141516171819package com.atguigu.starter;public class HelloService &#123; HelloProperties helloProperties; public HelloProperties getHelloProperties() &#123; return helloProperties; &#125; public void setHelloProperties(HelloProperties helloProperties) &#123; this.helloProperties = helloProperties; &#125; public String sayHellAtguigu(String name)&#123; return helloProperties.getPrefix()+&quot;-&quot; +name + helloProperties.getSuffix(); &#125;&#125; 1234567891011121314151617181920212223package com.atguigu.starter;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@ConditionalOnWebApplication //web应用才生效@EnableConfigurationProperties(HelloProperties.class)public class HelloServiceAutoConfiguration &#123; @Autowired HelloProperties helloProperties; @Bean public HelloService helloService()&#123; HelloService service = new HelloService(); service.setHelloProperties(helloProperties); return service; &#125;&#125; 更多 SpringBoot 整合示例https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples","categories":[{"name":"java","slug":"java","permalink":"https://supertramp7.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://supertramp7.github.io/tags/java/"},{"name":"mybatis","slug":"mybatis","permalink":"https://supertramp7.github.io/tags/mybatis/"},{"name":"springboot","slug":"springboot","permalink":"https://supertramp7.github.io/tags/springboot/"},{"name":"intellij IDEA","slug":"intellij-IDEA","permalink":"https://supertramp7.github.io/tags/intellij-IDEA/"},{"name":"maven","slug":"maven","permalink":"https://supertramp7.github.io/tags/maven/"},{"name":"jdk","slug":"jdk","permalink":"https://supertramp7.github.io/tags/jdk/"}]},{"title":"如何搭建一个自己的博客","slug":"personal_blog","date":"2021-02-16T16:00:00.000Z","updated":"2022-02-19T10:24:59.433Z","comments":true,"path":"personal_blog/","link":"","permalink":"https://supertramp7.github.io/personal_blog/","excerpt":"","text":"引言为什么要搭建自己的个人博客工作和学习过程中，我们经常遇到一些这样或那样的问题，此时我们可能会在网上找到相应的解决方法。但是过了一段时间之后，当我们再次碰到类似的问题时，早已忘记以前是怎么解决的了，于是又要到网上去搜，浪费大量的时间和精力。面对这些重复的问题，我们为什么不能把它们记录下来呢？ 在我看来，搭建自己的个人博客主要有以下好处： 有助于养成归纳总结的习惯，帮助记忆，把别人的知识变成自己的知识。 通过记录自己工作和生活，锻炼自己的写作的能力。 培养开放（开源）意识，与大家一起学习交流，共同进步。 搭建个人博客的多种选择目前，主流的博客主要分静态博客和动态博客两类： 所谓动态，就是指有前端有后端，可以登录到后台进行管理。静态博客是纯前端的展示，没有后端。 1. 动态博客搭建 1）直接在简书、CSDN（最近吐槽的比较多）、知乎、博客园等动态博客公共平台上写。 优点：简单 缺点：别人家的东西限制多 2）使用 WordPress 等成熟框架搭建动态博客 + 服务器部署 优点：相对简单 缺点：笨重 3）使用 Java、PHP、Python 等语言开发属于自己的动态博客 + 服务器部署 优点：功能强大 缺点：麻烦、不易上手 2. 静态博客搭建 1）使用 Hexo、Hugo、jekyll 等主流博客框架搭建静态博客 + 托管在 GitHub、码云等公共平台。 优点：轻量级、易上手、不花钱 缺点：访问速度慢 2）使用 Hexo、Hugo、jekyll 等主流博客框架搭建静态博客 + 云端服务器部署。 优点：有独立的域名、访问速度快、自主可控 缺点：要花钱买域名和云服务器 (我用的就是“Hexo+GitHub”这种方法，接下来详细地给大家介绍一下采用该方法搭建个人博客的原理和步骤。) 什么是 HexoHexo 可以理解为是基于 node.js 制作的一个博客工具。它是一个静态页面生成和上传的工具。 为什么选择 HexoHexo 在本地安装，不需要部署到我们的服务器上。我们只需要在本地通过 markdown 编写文章，然后让 Hexo 帮我们生成静态的 html 页面，并通过 Hexo 将生成的 html 文件上传到我们的服务器。 为什么选择托管在 GitHub 上托管在 github 上方便、不花钱 一、工作原理使用 Hexo 搭建个人博客并托管在 GitHub 的原理：简单来说就是在本地计算机搭建 Hexo 环境，Hexo 通过 generate 命令将*.md 文件渲染成静态的 html 页面，然后 Hexo 通过 deploy 命令触发 git 用户通过公钥免密登陆服务器，进而将静态页面推送到服务器的 git 仓库（repository）中。 二、搭建步骤在本地计算机安装 Hexo 环境1. 安装 Node.js去 Node.js 官网[2]下载 Windows (x64)长期支持版 Long Term Support (LTS) schedule。按提示逐步安装即可，安装完成后打开 cmd 查看版本号验证是否安装成功。 12C:\\Users\\11617&gt;node -vv12.14.1 Node.js 中自带了 npm 包管理工具，在 cmd 中查看 npm 版本。 12C:\\Users\\11617&gt;npm -v6.13.4 2. 安装 Gitgit 是一个版本控制工具，国外镜像下载巨慢，建议前往淘宝 Git for Windows 镜像下载 git 安装包。按提示逐步安装即可，安装完成后右键菜单中出现 Git Bash 和 Git GUI 菜单表明安装成功，如下图所示。 注：git 和 github 是两个东西。github 是基于 git 二次开发的，git 是 github 的核心，git 负责与 github 相关的所有本地工作。 3. 安装 Hexo在 F 盘新建 blog 文件夹用来存放个人博客，进入该文件夹，右键打开 Git Bash，使用 npm 安装 Hexo。 1$ npm install -g hexo-cli Hexo 安装完成后，在 blog 文件夹下新建 myblog 项目，并对其进行初始化。 12$ hexo init myblogl$ cd myblog 此时，会在 blog 文件夹下新建 myblog 文件夹，并在其内部生成相应的项目文件。如下图所示： 在 myblog 文件夹下启动 hexo 服务。 1$ hexo s 此时在本地打开浏览器，通过 http://localhost:4000/ 便可访问基于 Hexo 的个人博客主页了。如下图所示： 4. 我的第一篇文章在 myblog 文件夹下，右键打开 Git Bash，新建第一篇文章。 1$ hexo n &quot;我的第一篇博客文章&quot; 运行结果如下： 进入到 myblog/source/_posts/文件夹下。 123$ cd source&#x2F;_posts$ lshello-world.md 我的第一篇博客文章.md 打开“我的第一篇博客文章.md”并编辑保存。 重新退回到 myblog 文件夹下，清除缓存文件 db.json 和已生成的静态文件 public ，生成网站静态文件到默认设置的 public 文件夹，并重新启动 hexo。 1234$ cd ../..$ hexo clean$ hexo g$ hexo s 三、部署 GitHub将博客部署到 GitHub 上1. 登录 GitHub2. 新建仓库 —&gt; new repository 点击 Create repository，进入下一步。 3. 安装 git 插件1$ cnpm install --save hexo-deployer-git 4. 配置_config.yml 文件在 myblog 文件夹下打开_config.yml 文件并编辑保存。 1$ vim _config.yml 编辑如下： 保存退出后重新部署： 1$ hexo d 输入 github 账号、密码后刷新 GitHub 就可以看到博客。 5. 访问博客我的博客 四、更换主题yilila 主题1. 下载主题在 myblog 文件夹下，右键打开 Git Bash，下载主题到 themes 下的 yilia 文件夹下。 1$ git clone https://github.com/litten/hexo-theme-yilia.git themes yilia 2. 配置主题打开_config.yml 修改主题并保存。 3. 成功使用1234$ hexo clean$ hexo g$ hexo s$ hexo d 4. 优化Hexo yilia 主题一揽子优化方案 butterfly 主题1. 下载主题1git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly 2. 配置主题_config.yml 中 1theme：butterfly 3. 安装插件如果没有 pug 以及 stylus 的渲染器，请下载安装： 1npm install hexo-renderer-pug hexo-renderer-stylus --save ERROR1执行命令：git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 出现错误：fatal: unable to access &#39;https://github.com/litten/hexo-theme-yilia.git/&#39;: OpenSSL SSL_read: Connection was reset, errno 10054 原因：因为 git 在拉取或者提交项目时，中间会有 git 的 http 和 https 代理，但是我们本地环境本身就有 SSL 协议了，所以取消 git 的 https 代理即可，不行再取消 http 的代理。 解决方案：取消 git 本身的 https 代理，使用自己本机的代理，如果没有的话，其实默认还是用 git 的。 12345// 取消http代理git config --global --unset http.proxy// 取消https代理git config --global --unset https.proxy ERROR2执行代码：hexo d 出现错误：Logon failed, use ctrl+c to cancel basic credential prompt.remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead. 原因：自从 21 年 8 月 13 后不再支持用户名密码的方式验证了，需要创建个人访问令牌(personal access token)。 解决方案： 1.生成令牌 1）登录 GitHub 官网，点击 Settings 2）点击左侧 Developer settings 3）点击左侧 Personal access tokens 4）点击 Generate new token 5）填写 token 信息 6）点击 Generate token，生成令牌 2.应用令牌 首次推送提示 输入的的 2 次用户名密码，第一次是输入github的登陆用户名和密码；第二次是输入上面截图操作步骤最终填写的 Note（用户名） 和生成的 tokens（密码） ERROR3出现错误：hexo 博客在 yilia 主题下不显示作者名字解决方案：yilia 需要在主题下的_config.yml 加入 author: ,不在 menu:下","categories":[{"name":"博客","slug":"博客","permalink":"https://supertramp7.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://supertramp7.github.io/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"https://supertramp7.github.io/tags/blog/"},{"name":"github","slug":"github","permalink":"https://supertramp7.github.io/tags/github/"},{"name":"butterfly","slug":"butterfly","permalink":"https://supertramp7.github.io/tags/butterfly/"},{"name":"yilia","slug":"yilia","permalink":"https://supertramp7.github.io/tags/yilia/"}]}],"categories":[{"name":"java","slug":"java","permalink":"https://supertramp7.github.io/categories/java/"},{"name":"博客","slug":"博客","permalink":"https://supertramp7.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"-java -javabean -vo -hibernate","slug":"java-javabean-vo-hibernate","permalink":"https://supertramp7.github.io/tags/java-javabean-vo-hibernate/"},{"name":"ssh","slug":"ssh","permalink":"https://supertramp7.github.io/tags/ssh/"},{"name":"java","slug":"java","permalink":"https://supertramp7.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://supertramp7.github.io/tags/spring/"},{"name":"hibernate","slug":"hibernate","permalink":"https://supertramp7.github.io/tags/hibernate/"},{"name":"struts2","slug":"struts2","permalink":"https://supertramp7.github.io/tags/struts2/"},{"name":"框架","slug":"框架","permalink":"https://supertramp7.github.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"mybatis","slug":"mybatis","permalink":"https://supertramp7.github.io/tags/mybatis/"},{"name":"springboot","slug":"springboot","permalink":"https://supertramp7.github.io/tags/springboot/"},{"name":"intellij IDEA","slug":"intellij-IDEA","permalink":"https://supertramp7.github.io/tags/intellij-IDEA/"},{"name":"maven","slug":"maven","permalink":"https://supertramp7.github.io/tags/maven/"},{"name":"jdk","slug":"jdk","permalink":"https://supertramp7.github.io/tags/jdk/"},{"name":"hexo","slug":"hexo","permalink":"https://supertramp7.github.io/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"https://supertramp7.github.io/tags/blog/"},{"name":"github","slug":"github","permalink":"https://supertramp7.github.io/tags/github/"},{"name":"butterfly","slug":"butterfly","permalink":"https://supertramp7.github.io/tags/butterfly/"},{"name":"yilia","slug":"yilia","permalink":"https://supertramp7.github.io/tags/yilia/"}]}