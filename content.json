{"meta":{"title":"Supertramp","subtitle":"You are being watched.","description":"You're being watched.","author":"supertramp","url":"https://supertramp7.github.io","root":"/"},"pages":[{"title":"DAILY","date":"2022-02-19T08:22:38.000Z","updated":"2022-02-19T08:23:16.643Z","comments":true,"path":"daily/index.html","permalink":"https://supertramp7.github.io/daily/index.html","excerpt":"","text":""},{"title":"CATEGORIES","date":"2022-02-19T08:24:58.000Z","updated":"2022-02-19T08:25:23.975Z","comments":true,"path":"categories/index.html","permalink":"https://supertramp7.github.io/categories/index.html","excerpt":"","text":""},{"title":"TAGS","date":"2022-02-19T08:21:52.000Z","updated":"2022-02-19T08:23:21.829Z","comments":true,"path":"tags/index.html","permalink":"https://supertramp7.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"学习mybatis的一些坑","slug":"mybatis","date":"2022-02-19T08:27:31.000Z","updated":"2022-02-19T10:03:47.498Z","comments":true,"path":"mybatis/","link":"","permalink":"https://supertramp7.github.io/mybatis/","excerpt":"","text":"mybatis 知识点day1–mybatis 基础1. mybatis 的使用步骤 1、根据xml配置文件（全局配置文件）创建一个SqlSessionFactory对象:有数据源一些运行环境信息 2、sql 映射文件：配置了每一个sql，以及sql的封装规则等； 3、将sql映射文件注册在全局配置文件中 4、写代码 1）根据全局配置文件得到SqlSessionFactory 2）使用SqlSessionFactory获取到session对象，使用他来执行增删改查，session用完关闭 3）方法一：使用sql的唯一标识来告诉mybatis执行那个 sql ，sql都是保存在sql映射文件中的 方法二：（接口式编程）使用接口获取mapper对象，再用mapper调用接口中的方法（和hibernate相似） 2. mybatis 的全局配置文件 mybatis-config.xml （属性的顺序不能改变） properties 属性：引入外部 properties 配置文件的内容 ​ resource: 引入类路径下的资源 ​ url: 引入网络路径或者磁盘路径下的资源 settings 属性：包含很多重要的设置项 ​ setting:用来设置每一个设置项 ​ name: 设置项名 ​ value: 设置项取值 typeAliases 属性: 别名处理器，可以为 Java 类型起别名，别名不区分大小写 ​ typeAlias: 为某个 Java 类型起别名 ​ type: 指定要起别名的类型全类名，默认别名就是类名小写；employee ​ alias: 指定新的别名 ​ package: 为某个包下的所有类批量起别名 ​ name: 指定包名（为当前包以及下面所有的后代包的每一个类都起一个默认别名（类名小写） ​ 批量起别名的情况下，使用@Alias 注解为某个类型指定新的别名 environments:环境，mybatis 可以配置多种环境，default 指定使用某种环境，可以达到快速切换环境 ​ environment：配置一个具体的环境信息；id 代表当前环境的唯一标识；必须有两个标签： ​ transactionManager：事务管理器； ​ type : 事务管理器的类型；JDBC|MANAGED ​ 自定义事务管理器：实现 TransactionFactory 接口，type 指定为全类名 ​ dataSource：数据源；​ type : UNPOOLED|POOLED|JNDI ​ 自定义数据源：实现 DataSourceFactory 接口，type 指定为全类名 databaseIdProvider:支持多数据库厂商的；type=”DB_VENDOR”：VendorDatabaseIdProvider，作用就是得到数据库厂商的标识，mybatis 就能根据数据库厂商标识来执行不同的 sql；MySQL,Oracle,SQL Server,xxxx mappers:将 sql 映射注册到全局配置中 mapper：注册一个 sql 映射 注册配置文件 resource:引用类路径下的 sql 映射文件url:引用网络路径或者磁盘路径下的 sql 映射文件 注册接口 class:引用（注册）接口 1、有 sql 映射文件，映射文件名必须和接口同名，并且放在与接口同一目录下； 2、 没有 sql 映射文件，所有的 sql 都是利用注解写在接口上; 推荐： 比较重要的、复杂的 Dao 接口我们来写 sql 映射文件 不重要的、简单的 Dao 接口，为了快速开发可以使用注解 package：批量注册; 注：必须要求映射文件和接口放在同一目录下，为了看起来方便，将 conf 下的映射文件的包名改为和 src 下的接口的包名一样（编译的时候是在一个同一个包下） 3. mybatis 映射文件 EmployeeMapper.xml1、增删改查 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!-- namespace：名称空间 id:唯一标识 resultType:返回值类型 #&#123;id&#125;: 从传递过来的参数中取出id值 --&gt; &lt;select id=&quot;getEmpById&quot; resultType=&quot;com.zwb.mybatis.bean.Employee&quot; databaseId=&quot;mysql&quot;&gt; select * from tbl_employee where id=#&#123;id&#125; &lt;/select&gt; &lt;!-- public void addEmp(Employee employee); --&gt; &lt;!-- parameterType：参数类型，可以省略； 获取自增主键的值： mysql支持自增主键，自增主键值的获取，mybatis也是利用statement.getGeneratedKeys(); useGeneratedKeys=&quot;true&quot;: 使用自增主键获取主键值策略 keyProperty：指定对应的主键属性，也就是mybatis获取到主键值以后，将这个值封装给JavaBean的哪个属性 --&gt; &lt;insert id=&quot;addEmp&quot; parameterType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; insert into tbl_employee(last_name,email,gender) values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;) &lt;/insert&gt; &lt;!-- public void updateEmp(Employee employee); --&gt; &lt;update id=&quot;updateEmp&quot;&gt; update tbl_employee set last_name=#&#123;lastName&#125;,email=#&#123;email&#125;,gender=#&#123;gender&#125; where id=#&#123;id&#125; &lt;/update&gt; &lt;!-- public void deleteEmpById(Integer id); --&gt; &lt;delete id=&quot;deleteEmpById&quot;&gt; delete from tbl_employee where id=#&#123;id&#125; &lt;/delete&gt; /** * 测试增删改 * 1. mybatis 允许增删改直接定义以下类型返回值 * Integer、Long、Boolean * 2. 手动提交数据 * sqlSessionFactory.openSession(); ===&gt; 手动提交 * sqlSessionFactory.openSession(true); ===&gt; 自动提交 * @throws IOException */ 2、mybatis 参数处理 单个参数：mybatis 不会做特殊处理。 ​ #{参数名(实际上可以任意写，因为参数就一个)}:取出参数值。 多个参数：mybatis 会做特殊处理。 ​ 多个参数会被封装成一个 map ​ key:param1…paramN，或者参数的索引 ​ value:传入的参数值 ​ #{}就是从 map 中获取指定的 key 的值； ​ 异常： ​ org.apache.ibatis.binding.BindingException: ​ Parameter &#39;id&#39; not found. ​ Available parameters are [arg1, arg0, param1, param2] ​ 操作： ​ 方法：public Employee getEmpByIdAndLastName(Integer id,String lastName); ​ 取值：#{id},#{lastName} 命名参数：明确指定封装参数时 map 的 key。 ​ 多个参数会被封装成一个 map, ​ key:使用@Param()注解指定的值 ​ value:传入的参数值 ​ #{指定的 key}取出对应的参数值 POJO: ​ 如果多个参数正好是业务逻辑的数据模型，可以直接传入 pojo ​ #{属性名}:取出掺入的 pojo 的属性值 Map: ​ 如果多个参数不是业务逻辑的数据模型，可以传入 map ​ #{key}:取出 map 中对应的值 TO: ​ 如果多个参数不是业务逻辑的数据模型，但经常使用，推荐来编写一个 TO(Transfer Object)数据传输对象 ​ Page&#123; ​ int index; ​ int size; ​ &#125; ====================思考========================= public Employee getEmp(@Param(“id”)Integer id,String lastName); 取值：id=#{id/parma1} last_name=#{param2} public Employee getEmp(Integer id,@Param(“e”)Employee employee); 取值：id=#{parma1} last_name=#{param2.lastName/e.lastName} // 特别注意：如果是Collection(List、Set)类型或者是数组，也会特殊处理。也是把传入的list或者数组封装在map中 key:Collection(collection),如果是List还可以使用这个key(list) 数组(array)public Employee getEmpById(List ids); 取值：取出第一个id的值：id=#{list[0]} ===================结合源码，mybatis怎么处理参数========================== ===================参数值的获取==========================select * from tbl_employee where id=${id} and last_name=#{lastName}select * from tbl_employee where id=1 and last_name=?#{}：可以获取map中的值或者pojo对象属性的值${}：可以获取map中的值或者pojo对象属性的值 区别： #{}：是以预编译的形式，将参数设置到sql语句中；PreparedStatement；防止sql注入 ${}：取出的值直接拼装在sql语句中；会有安全问题 大多情况下，我们取参数的值都应该去使用#{}； 某些情况下(原生jdbc不支持占位符的地方)，比如分表、排序..：按照年份分表拆分 select * from ${year}_salary where xxx; select * from tbl_employee order by ${f_name} ${order} #{}:更丰富的用法： 规定参数的一些规则： javaType、jdbcType、mode（存储过程）、numericScale、 resultMap、typeHandler、jdbcTypeName、expression（未来准备支持的功能） javaType通常需要在某种特定的条件下被设置： 在我们数据为null的时候，有些数据库可能不能识别mybatis对null的默认处理。比如Oracle（报错）； javaType OTHER：无效的类型；因为mybatis对所有的null都映射的是原生Jdbc的OTHER类型，oracle不认识； 由于全局配置中：javaTypeForNull=OTHER；oracle不支持；两种办法1、#{email,javaType=OTHER};2、全局设置javaTypeForNull=NULL 3、select 返回 List ​ esultType：如果返回的是一个集合，要写集合中元素的类型 4、select 记录封装 ​ 一条记录封装一个 map： ​ Map&lt;Integer,Employee&gt;：key 这条记录的主键，value 是这条记录 ​ 使用注解@MapKey(“id”)，告诉 mybatis 封装 map 时使用哪个属性作为 map 的 key 5、select resultMap 1）resultMap 自定义映射规则 12345678910111213141516171819&lt;!-- 自定义某个JavaBean的封装规则:type:自定义规则的Java类型; id:唯一id方便引用 --&gt; &lt;!-- 此时，全局配置文件里的驼峰命名规则可以去除掉了 --&gt; &lt;resultMap type=&quot;com.zwb.mybatis.bean.Employee&quot; id=&quot;MyEmp&quot;&gt; &lt;!-- 指定主键列的封装规则:column:指定哪一列； property:指定对应的javabean属性 --&gt; &lt;!-- result定义主键也可以，但是，id定义主键会底层有优化 --&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;!-- 指定非主键列的封装规则: --&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot;/&gt; &lt;!-- 其他不指定的列会自动封装，但是通常在resultMap里把全部的规则都写上 --&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot;/&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt; &lt;/resultMap&gt; &lt;!-- resuleMap:自定义结果集映射规则；和 resultType 不能同时出现 --&gt; &lt;!-- public Employee getEmpById(Integer id); --&gt; &lt;select id=&quot;getEmpById&quot; resultMap=&quot;MyEmp&quot;&gt; select * from tbl_employee where id=#&#123;id&#125; &lt;/select&gt; 2）resultMap 关联查询 1 - 级联属性封装结果集 1234567891011121314151617181920&lt;!-- 场景一： 查询Employee的同时，查出所在部门 ;id lastName email gender dept --&gt; &lt;!-- 联合查询：级联属性封装结果集 --&gt; &lt;resultMap type=&quot;com.zwb.mybatis.bean.Employee&quot; id=&quot;MyEmp2&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;lastName&quot; property=&quot;lastName&quot; /&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot; /&gt; &lt;result column=&quot;d_id&quot; property=&quot;dept.id&quot; /&gt; &lt;result column=&quot;d_name&quot; property=&quot;dept.departmentName&quot; /&gt; &lt;/resultMap&gt; &lt;!-- public Employee getEmpAndDept(Integer id); --&gt; &lt;select id=&quot;getEmpAndDept&quot; resultMap=&quot;MyEmp2&quot;&gt; SELECT e.id id,e.last_name lastName,e.email email,e.gender gender,d.id d_id,d.dept_name d_name from tbl_employee e,tbl_dept d WHERE e.d_id=d.id AND e.id=#&#123;id&#125; &lt;/select&gt; 2 - association 定义关联的单个对象的封装规则 12345678910111213&lt;!-- 使用association定义关联的单个对象的封装规则 --&gt; &lt;resultMap type=&quot;com.zwb.mybatis.bean.Employee&quot; id=&quot;MyEmp3&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;lastName&quot; property=&quot;lastName&quot; /&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot; /&gt; &lt;!-- association可以指定联合的javabean对象：property：指定哪个属性是联合的对象；javaType：指定这个属性对象的类型【不能省略】 --&gt; &lt;association property=&quot;dept&quot; javaType=&quot;com.zwb.mybatis.bean.Department&quot;&gt; &lt;id column=&quot;d_id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;d_name&quot; property=&quot;departmentName&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; 3 - association 分步查询 1234567891011121314151617181920&lt;!-- 使用association进行分步查询:step1:先按照员工id查询员工信息；step2：根据查询员工信息中的d_id值去部门表中查部门信息；step3：部门设置到员工中 --&gt; &lt;resultMap type=&quot;com.zwb.mybatis.bean.Employee&quot; id=&quot;MyEmpByStep&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot; /&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot; /&gt; &lt;!-- association定义关联对象的封装规则：select:表明当前属性是调用select指定的方法查出的结果；column：指定将哪一列的值传给这个方法 --&gt; &lt;!-- 流程：使用select指定的方法（传入column指定的这列参数的值）查出对象，并封装给property指定的属性 --&gt; &lt;association property=&quot;dept&quot; select=&quot;com.zwb.mybatis.dao.DepartmentMapper.getDeptById&quot; column=&quot;d_id&quot;&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!-- public Employee getEmpByIdStep(Integer id); --&gt; &lt;select id=&quot;getEmpByIdStep&quot; resultMap=&quot;MyEmpByStep&quot;&gt; SELECT * from tbl_employee where id=#&#123;id&#125; &lt;/select&gt; 4 - 延迟加载(懒加载) （按需加载）：部门信息在我们使用的时候再去查询，在分段查询的基础之上加上两个配置 123&lt;!-- 延迟加载 --&gt;&lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;&lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; 5 - collection 定义关联集合类型封装规则（一对多的情况） 123456789101112131415161718192021222324&lt;!-- collection嵌套结果集的方式，定义关联的集合类型元素的封装规则 --&gt; &lt;resultMap type=&quot;com.zwb.mybatis.bean.Department&quot; id=&quot;MyDept&quot;&gt; &lt;id column=&quot;did&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;dept_name&quot; property=&quot;departmentName&quot;/&gt; &lt;!-- collection定义关联的集合类型的属性的封装规则;ofType:指定集合里面元素的类型 --&gt; &lt;collection property=&quot;emps&quot; ofType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; &lt;!-- 定义这个集合中元素的封装规则 --&gt; &lt;id column=&quot;eid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot;/&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot;/&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- public Department getDeptByIdPlus(Integer id); --&gt; &lt;select id=&quot;getDeptByIdPlus&quot; resultMap=&quot;MyDept&quot;&gt; SELECT d.id did,d.dept_name dept_name,e.id eid,e.last_name last_name,e.email email,e.gender gender FROM tbl_dept d LEFT JOIN tbl_employee e ON d.id=e.d_id WHERE d.id=#&#123;id&#125; &lt;/select&gt; 6 - collection 的分布查询和延迟加载[和 association 一样] 1234567891011&lt;resultMap type=&quot;com.zwb.mybatis.bean.Department&quot; id=&quot;MyDeptStep&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;dept_name&quot; property=&quot;departmentName&quot;/&gt; &lt;collection property=&quot;emps&quot; select=&quot;com.zwb.mybatis.dao.EmployeeMapperPlus.getEmpsByDid&quot; column=&quot;id&quot;&gt;&lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- public Department getDeptByIdStep(Integer id); --&gt; &lt;select id=&quot;getDeptByIdStep&quot; resultMap=&quot;MyDeptStep&quot;&gt; SELECT id,dept_name from tbl_dept WHERE id=#&#123;id&#125; &lt;/select&gt; 7 - 分步查询传递多列值和 fetchType 扩展：多列值传递过去：将多列的值封装 map 传递：column=&quot;&#123;key1=column1,key2=column2&#125;&quot; ​ fetchType=”lazy”:表示使用延迟加载：lazy[延迟加载]|eager[立即加载] 8 - discriminator 鉴别器 123456789101112131415161718192021222324&lt;!-- discriminator鉴别器：mybatis可以使用discriminator判断某列的值，然后根据某列的值改变封装行为 --&gt; &lt;!-- 封装Employee：如果查出的是女生，就把部门信息查询出来，否则不查询；如果是男生，把last_name赋值给email --&gt; &lt;resultMap type=&quot;com.zwb.mybatis.bean.Employee&quot; id=&quot;MyEmpDis&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot; /&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot; /&gt; &lt;!-- column:指定要判断的列名；javaType:列值对应的java类型 --&gt; &lt;discriminator javaType=&quot;string&quot; column=&quot;gender&quot;&gt; &lt;!-- resultType:指定封装结果类型 ;[resultType|resultMap]选其一 --&gt; &lt;case value=&quot;0&quot; resultType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; &lt;association property=&quot;dept&quot; select=&quot;com.zwb.mybatis.dao.DepartmentMapper.getDeptById&quot; column=&quot;d_id&quot;&gt; &lt;/association&gt; &lt;/case&gt; &lt;case value=&quot;1&quot; resultType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot; /&gt; &lt;result column=&quot;last_name&quot; property=&quot;email&quot; /&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot; /&gt; &lt;/case&gt; &lt;/discriminator&gt; &lt;/resultMap&gt; day2–动态 sql动态 sql1、if 判断 123456789101112131415161718192021&lt;!-- 查询员工，要求：携带了哪个字段，查询条件就带上这个字段的值 --&gt;&lt;!-- public List&lt;Employee&gt; getEmpsByConditionIf(Employee employee); --&gt;&lt;select id=&quot;getEmpsByConditionIf&quot; resultType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; select * from tbl_employee where &lt;!-- test:判断表达式 --&gt; &lt;if test=&quot;id!=null&quot;&gt; id=#&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;lastName!=null and lastName!=&#x27;&#x27;&quot;&gt; and last_name like #&#123;lastName&#125; &lt;/if&gt; &lt;if test=&quot;email!=null and email.trim()!=&#x27;&#x27;&quot;&gt; and email=#&#123;email&#125; &lt;/if&gt; &lt;!-- ognl 会进行字符串与数字的转换判断 --&gt; &lt;if test=&quot;gender==0 or gender==1&quot;&gt; and gender=#&#123;gender&#125; &lt;/if&gt;&lt;/select&gt; 2、where 查询 查询的时候，如果某些条件没带可能 sql 拼装会有问题： 解决：1、给 where 后面加上 1=1 ，以后的条件都 and xxx； ​ 2、mybatis 使用 where 标签来将所有的查询条件包括在内,mybatis 就会将 where 标签中拼装的 sql，多出来的 and 或者 or 去掉（and 在后面的话不行） 12345678910111213141516&lt;where&gt; &lt;!-- test:判断表达式 --&gt; &lt;if test=&quot;id!=null&quot;&gt; id=#&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;lastName!=null and lastName!=&#x27;&#x27;&quot;&gt; and last_name like #&#123;lastName&#125; &lt;/if&gt; &lt;if test=&quot;email!=null and email.trim()!=&#x27;&#x27;&quot;&gt; and email=#&#123;email&#125; &lt;/if&gt; &lt;!-- ognl 会进行字符串与数字的转换判断 --&gt; &lt;if test=&quot;gender==0 or gender==1&quot;&gt; and gender=#&#123;gender&#125; &lt;/if&gt;&lt;/where&gt; 3、trim 自定义字符串截取 12345678910111213141516171819202122232425&lt;select id=&quot;getEmpsByConditionTrim&quot; resultType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; select * from tbl_employee &lt;!-- 后面多出的 and 或者 or where 标签不能解决 --&gt; &lt;!-- prefix:前缀：trim标签体中是整个字符串拼串后的结果，prefix给拼串后的整个字符串加一个前缀； suffix: 后缀，suffix给拼串后的整个字符串加一个后缀； prefixOverrides: 前缀覆盖：去掉整个字符串前面多余的字符； suffixOverrides: 后缀覆盖：去掉整个字符串后面多余的字符 --&gt; &lt;!-- 自定义字符串的截取规则 --&gt; &lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;and&quot;&gt; &lt;if test=&quot;id!=null&quot;&gt; id=#&#123;id&#125; and &lt;/if&gt; &lt;if test=&quot;lastName!=null and lastName!=&#x27;&#x27;&quot;&gt; last_name like #&#123;lastName&#125; and &lt;/if&gt; &lt;if test=&quot;email!=null and email.trim()!=&#x27;&#x27;&quot;&gt; email=#&#123;email&#125; and &lt;/if&gt; &lt;if test=&quot;gender==0 or gender==1&quot;&gt; gender=#&#123;gender&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; 4、choose 分支选择：带了 break 的 switch-case，如果带了 id 就用 id 查，只会进入其中一个 1234567891011121314&lt;select id=&quot;getEmpsByConditionChoose&quot; resultType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; select * from tbl_employee &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;id!=null&quot;&gt;id=#&#123;id&#125;&lt;/when&gt; &lt;when test=&quot;lastName!=null and lastName!=&#x27;&#x27;&quot;&gt;last_name like #&#123;lastName&#125;&lt;/when&gt; &lt;when test=&quot;email!=null and email.trim()!=&#x27;&#x27;&quot;&gt;email=#&#123;email&#125;&lt;/when&gt; &lt;otherwise&gt; gender =0 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; 5、set 与 if 结合的动态更新 123456789&lt;update id=&quot;updateEmp&quot;&gt; update tbl_employee &lt;set&gt; &lt;if test=&quot;lastName!=null&quot;&gt;last_name=#&#123;lastName&#125;,&lt;/if&gt; &lt;if test=&quot;email!=null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt; &lt;if test=&quot;gender!=null&quot;&gt;gender=#&#123;gender&#125;&lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125; &lt;/update&gt; 123456789Trim:&lt;update id=&quot;updateEmp&quot;&gt; update tbl_employee &lt;trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;lastName!=null&quot;&gt;last_name=#&#123;lastName&#125;,&lt;/if&gt; &lt;if test=&quot;email!=null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt; &lt;if test=&quot;gender!=null&quot;&gt;gender=#&#123;gender&#125;&lt;/if&gt; &lt;/trim&gt; where id=#&#123;id&#125; &lt;/update&gt; 6、foreach 遍历集合 12345678910111213&lt;select id=&quot;getEmpsByConditionForEach&quot; resultType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; select * from tbl_employee &lt;!-- collection:指定要遍历的集合：list类型的参数会特殊处理封装在map中，map的key就叫list； item：将遍历出的元素赋值给指定的变量 separator:每个元素之间的分隔符 open:遍历出所有结果拼接一个开始的字符 close:遍历出所有结果拼接一个结束的字符 index:索引。遍历list的时候index是索引，item是值；遍历map时，index就是map的key，item是map的值 #&#123;变量名&#125;就能取出变量得值也就是当前遍历出的元素--&gt; &lt;foreach collection=&quot;ids&quot; item=&quot;item_id&quot; separator=&quot;,&quot; open=&quot;where id in(&quot; close=&quot;)&quot;&gt; #&#123;item_id&#125; &lt;/foreach&gt;&lt;/select&gt; 7、foreach 批量保存（MySQL 数据库）（推荐方法一） 方法一：foreach 遍历 values(),(),() 123456&lt;insert id=&quot;addEmps&quot;&gt; INSERT INTO tbl_employee(last_name,email,gender,d_id) VALUES &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;,&quot;&gt; (#&#123;emp.lastName&#125;,#&#123;emp.email&#125;,#&#123;emp.gender&#125;,#&#123;emp.dept.id&#125;) &lt;/foreach&gt;&lt;/insert&gt; 方法二：将数据库连接属性添加 allowMultiQueries=true ，这种分号分隔多个 sql 可以用于其他的批量操作（删除，修改） dbconfig.properties 里 jdbc.url=jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true 123456&lt;insert id&#x3D;&quot;addEmps&quot;&gt; &lt;foreach collection&#x3D;&quot;emps&quot; item&#x3D;&quot;emp&quot; separator&#x3D;&quot;;&quot;&gt; INSERT INTO tbl_employee(last_name,email,gender,d_id) VALUES (#&#123;emp.lastName&#125;,#&#123;emp.email&#125;,#&#123;emp.gender&#125;,#&#123;emp.dept.id&#125;) &lt;&#x2F;foreach&gt; &lt;&#x2F;insert&gt; 8、两个内置参数 _parameter&amp; _databaseId :不只是方法传递过来的参数可以被用来判断，取值，mybatis 默认还有两个内置参数： 1）_parameter:代表整个参数 单个参数：_parameter就是这个参数 多个参数：参数会被封装为一个 map，_parameter就是代表这个 map2）_databaseId:如果配置了 databaseIdProvider 标签，_databaseId就是代表当前数据库的别名 123456789101112&lt;select id=&quot;getEmpsTestInnerParameter&quot; resultType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; &lt;if test=&quot;_databaseId==&#x27;mysql&#x27;&quot;&gt; select * from tbl_employee &lt;if test=&quot;_parameter!=null&quot;&gt; where last_name = #&#123;lastName&#125; &lt;/if&gt; &lt;/if&gt; &lt;!-- 假装有oracle数据库 --&gt; &lt;if test=&quot;_databaseId==&#x27;oracle&#x27;&quot;&gt; select * from employee &lt;/if&gt; &lt;/select&gt; 9、bind 绑定：可以将 OGNL 表达式的值绑定一个变量中，方便后来引用这个变量得值 1234567891011121314&lt;select id=&quot;getEmpsTestInnerParameter&quot; resultType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; &lt;!-- bind：可以将OGNL表达式的值绑定一个变量中，方便后来引用这个变量得值 --&gt; &lt;bind name=&quot;_lastName&quot; value=&quot;&#x27;_&#x27;+lastName+&#x27;%&#x27;&quot;/&gt; &lt;if test=&quot;_databaseId==&#x27;mysql&#x27;&quot;&gt; select * from tbl_employee &lt;if test=&quot;_parameter!=null&quot;&gt; where last_name like #&#123;_lastName&#125; &lt;/if&gt; &lt;/if&gt; &lt;!-- 假装有oracle数据库 --&gt; &lt;if test=&quot;_databaseId==&#x27;oracle&#x27;&quot;&gt; select * from employee &lt;/if&gt; &lt;/select&gt; 10、sql 标签：抽取可重用的 sql 片段，方便后面引用 1）sql 抽取：经常将要查询的列名，或者插入用的列名抽取出来方便使用2）include 来引用已经抽取的 sql3）include 还可以自定义一些 property，sql 标签内部就能使用自定义的属性 property 取值的正确方式${prop},不能使用这种#{prop} 定义： 12345&lt;sql id=&quot;insertColumn&quot;&gt; &lt;if test=&quot;_databaseId==&#x27;mysql&#x27;&quot;&gt; last_name,email,gender,d_id,$&#123;自定义属性名&#125; &lt;/if&gt;&lt;/sql&gt; 引用： 1234&lt;!-- 引用外部定义的sql --&gt;&lt;include refid=&quot;insertColumn&quot;&gt; &lt;property name=&quot;自定义属性名&quot; value=&quot;自定义属性值&quot;/&gt;&lt;/include&gt; day3–mybatis 缓存mybatis 缓存两级缓存： 1、一级缓存（本地缓存）：sqlSession 级别的缓存，一级缓存是一直开启的； 在数据库同一次会话期间查询到的数据，会放在本地缓存中。以后如果需要获取相同的数据，直接从缓存中去拿，没必要再去查询数据库； 一级缓存的失效情况（没用到当前一级缓存的情况，效果就是,还需要再向数据库发出查询）： sqlSession 不同。 sqlSession 相同，查询条件不同。（当前一级缓存中还没有这个数据） sqlSession 相同，两次查询之间执行了增删改操作。 sqlSession 相同，手动清除了一级缓存（缓存清空） 2、二级缓存（全局缓存）：基于 namespace 级别的缓存，一个 namespace 对应一个二级缓存 1）工作机制： 一个会话，查询一条数据，这个数据就会被放在当前会话的一级缓存中； 如果会话关闭；一级缓存中的数据会被保存到二级缓存中；新的会话查询信息，就可以参照二级缓存中的内容； 不同的 namespace 查出的数据会放在自己对应的缓存（map）中。 sqlSession===EmployeeMapper==&gt;Employee DepartmentMapper==&gt;Department 2）效果：数据会从二级缓存中获取 查出的数据都会被默认先放在一级缓存中。只有会话提交或者关闭后，一级缓存中的数据才会转移到二级缓存中 3）使用步骤： 开启全局二级缓存配置：&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 去 mapper.xml 中配置使用二级缓存： 12345678910111213141516171819&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; readOnly=&quot;false&quot; size=&quot;1024&quot;&gt;&lt;/cache&gt; &lt;!-- eviction:缓存的回收策略： • LRU -- 最近最少使用的：移除最长时间不被使用的对象。 • FIFO -- 先进先出：按对象进入缓存的顺序来移除它们。 • SOFT -- 软引用：移除基于垃圾回收器状态和软引用规则的对象。 • WEAK -- 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。 • 默认的是 LRU。 flushInterval：缓存刷新间隔 缓存多长时间清空一次，默认不清空，设置一个毫秒值 readOnly:是否只读： true：只读；mybatis认为所有从缓存中获取数据的操作都是只读操作，不会修改数据。 mybatis为了加快获取速度，直接就会将数据在缓存中的引用交给用户。不安全，速度快 false：非只读：mybatis觉得获取的数据可能会被修改。 mybatis会利用序列化&amp;反序列的技术克隆一份新的数据给你。安全，速度慢 size：缓存存放多少元素； type：指定自定义缓存的全类名； 实现Cache接口即可； --&gt; 4）我们的 POJO 需要实现序列化接口 3、和缓存有关的设置/属性： 1）&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; false:关闭缓存（二级缓存关闭，一级缓存一直可用） 2）每个 select 标签都有 useCache=”true” false：不使用缓存（一级缓存依然使用，二级缓存不使用） 3）每个增删改标签 flushCache=”true” 增删改执行完成后就会清除缓存（一级缓存、二级缓存都会被清空）；查询标签里也有 flushCache，默认值为 false，如果改为 true,每次查询之后都会清空缓存； 4）session.clearCache(); 只是清除当前 session 的一级缓存 5）localCacheScope: 本地缓存作用域（一级缓存 SESSION）;当前会话的所有数据保存在会话缓存中； ​ STATEMENT:可以禁用一级缓存； 4、第三方 ehcache 整合 1）导入第三方缓存包即可； 2）导入与第三方缓存整合的适配包； 3）mapper.xml 中使用自定义缓存。 123&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;&gt;&lt;/cache&gt;&lt;!-- 引用缓存：namespace指定和哪个名称空间下的缓存一样 --&gt;&lt;cache-ref namespace=&quot;com.zwb.mybatis.dao.EmployeeMapper&quot;/&gt; day4–逆向工程逆向工程 Generator1、导入包 mybatis-generator-core-1.4.0.jar 2、在工程下创建 mbg.xml 文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt; &lt;generatorConfiguration&gt; &lt;!-- targetRuntime=&quot;MyBatis3Simple&quot;:生成简单版的CRUD MyBatis3：豪华版 --&gt; &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;!-- jdbcConnection:指定如何连接到目标数据库 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true&quot; userId=&quot;root&quot; password=&quot;&quot;&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- javaModelGenerator:指定javaBean的生成策略 targetPackage:目标报名 targetProject:目标工程 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.zwb.mybatis.bean&quot; targetProject=&quot;.\\src&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- sqlMapGenerator:sql映射生成策略 --&gt; &lt;sqlMapGenerator targetPackage=&quot;com.zwb.mybatis.dao&quot; targetProject=&quot;.\\conf&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- javaClientGenerator:指定mapper接口所在的位置 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.zwb.mybatis.dao&quot; targetProject=&quot;.\\src&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定要逆向分析哪些表，根据表要创建javabean --&gt; &lt;table tableName=&quot;tbl_dept&quot; domainObjectName=&quot;Department&quot;&gt;&lt;/table&gt; &lt;table tableName=&quot;tbl_employee&quot; domainObjectName=&quot;Employee&quot;&gt;&lt;/table&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt; 3、运行 Generator 123456789101112@Testpublic void testMbg() throws Exception&#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(&quot;mbg.xml&quot;); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null);&#125; 4、测试查询 12345678910111213141516171819202122232425262728293031323334@Testpublic void testMyBatis3() throws IOException &#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); SqlSession session = sqlSessionFactory.openSession(); try &#123; EmployeeMapper mapper = session.getMapper(EmployeeMapper.class); Employee employee = mapper.selectByPrimaryKey(1); System.out.println(employee); // xxxExample就是封装查询条件的 // 1. 查询所有 List&lt;Employee&gt; list = mapper.selectByExample(null); // 2. 查询员工名字中有e字母的，和员工性别是1的 // 封装员工查询条件的example EmployeeExample example = new EmployeeExample(); // 创建一个criteria拼装查询条件 Criteria criteria = example.createCriteria(); criteria.andLastNameLike(&quot;%e%&quot;); criteria.andGenderEqualTo(&quot;1&quot;); Criteria criteria2 = example.createCriteria(); criteria2.andEmailLike(&quot;%e%&quot;); example.or(criteria2); List&lt;Employee&gt; list2 = mapper.selectByExample(example); for (Employee e : list2) &#123; System.out.println(e); &#125; &#125; finally &#123; session.close(); &#125;&#125; day5–mybatis 工作原理MyBatis 工作原理1、mybatis 运行流程 1）获取 sqlSessionFactory 对象 ​ 解析文件的每一个信息保存在 Configuration 中，返回包含 Configuration 的 DefaultSqlSession； ​ 【注意：】[MappedStatement]：代表一个增删改查的详细信息 2）获取 sqlSession 对象 ​ 返回一个 DefaultSQlSession 对象，包含 Executor 和 Configuration; ​ 这一步会创建Executor对象； 3）获取接口的代理对象（MapperProxy） ​ getMapper，使用 MapperProxyFactory 创建一个 MapperProxy 的代理对象 ​ 代理对象里面包含了，DefaultSqlSession（Executor） 4）执行增删改查方法 2、总结 1）根据配置文件（全局，sql 映射）初始化出 Configuration 对象 2）创建一个 DefaultSqlSession 对象，他里面包含 Configuration 以及 Executor（根据全局配置文件中的 defaultExecutorType 创建出对应的 Executor） 3）DefaultSqlSession.getMapper()：拿到 Mapper 接口对应的 MapperProxy； 4）MapperProxy 里面有（DefaultSqlSession）； 5）执行增删改查方法： 调用 DefaultSqlSession 的增删改查（Executor）； 会创建一个 StatementHandler 对象。（同时也会创建出 ParameterHandler 和 ResultSetHandler） 调用 StatementHandler 预编译参数以及设置参数值;使用 ParameterHandler 来给 sql 设置参数 调用 StatementHandler 的增删改查方法； ResultSetHandler 封装结果 6）注意：四大对象每个创建的时候都有一个 interceptorChain.pluginAll(parameterHandler); day6–mybatis 插件1. MyBatis 插件原理在四大对象创建的时候 1、每个创建出来的对象不是直接返回的，而是 interceptorChain.pluginAll(parameterHandler); 2、获取到所有的 Interceptor（拦截器）（插件需要实现的接口）；调用 interceptor.plugin(target);返回 target 包装后的对象 3、插件机制，我们可以使用插件为目标对象创建一个代理对象；AOP(面向切面) ​ 我们的插件可以为四大对象创建出代理对象；代理对象就可以拦截到四大对象的每一个执行； 2. 插件编写：1、编写 interceptor 的实现类——MyFirstPlugin.java 2、使用@Intercepts 注解完成插件签名 123@Intercepts(&#123;@Signature(type=StatementHandler.class,method=&quot;parameterize&quot;,args=java.sql.Statement.class)&#125;) 3、将写好的插件注册到全局配置文件中 1234567&lt;!-- plugins:注册插件 --&gt;&lt;plugins&gt; &lt;plugin interceptor=&quot;com.zwb.mybatis.dao.MyFirstPlugin&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;&quot;/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 4、测试插件 3. 多个插件的运行流程创建动态代理的时候，是按照插件配置顺序创建层层代理对象。 执行目标方法的之后，按照逆向顺序执行。 4. PageHelper 分页插件1、导入 jar 包——pagehelper-5.1.9.jar jsqlparser-3.1.jar 2、在mybatis-config.xml中配置插件【注意标签的顺序】 123456&lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;!-- config params as the following --&gt; &lt;property name=&quot;param1&quot; value=&quot;value1&quot; /&gt; &lt;/plugin&gt;&lt;/plugins&gt; 3、使用分页插件 123456789101112131415161718192021222324252627282930313233@Test public void test2() throws IOException &#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); SqlSession session = sqlSessionFactory.openSession(); try &#123; EmployeeMapper mapper = session.getMapper(EmployeeMapper.class); Page&lt;Object&gt; page = PageHelper.startPage(5, 1); List&lt;Employee&gt; list = mapper.getAllEmps();// PageInfo&lt;Employee&gt; pageInfo = new PageInfo&lt;&gt;(list);// 传入要连续显示多少页 PageInfo&lt;Employee&gt; pageInfo = new PageInfo&lt;&gt;(list,5); for (Employee employee : list) &#123; System.out.println(employee); &#125; /*System.out.println(&quot;当前页码:&quot;+page.getPageNum()+&quot;，每页的记录数：&quot;+page.getPageSize()+&quot;，总记录数：&quot;+page.getTotal()); System.out.println(&quot;总页码：&quot;+page.getPages());*/ System.out.println(&quot;当前页码:&quot;+pageInfo.getPageNum()+&quot;，每页的记录数：&quot;+pageInfo.getPageSize()+&quot;，总记录数：&quot;+pageInfo.getTotal()); System.out.println(&quot;总页码：&quot;+pageInfo.getPages()); System.out.println(&quot;是否第一页&quot;+pageInfo.isIsFirstPage()); System.out.println(&quot;连续打印的页数：&quot;); int[] nums = pageInfo.getNavigatepageNums(); for (int i = 0; i &lt; nums.length; i++) &#123; System.out.println(nums[i]); &#125; &#125; finally &#123; session.close(); &#125; &#125; day7–批量操作批量：预编译 sql:1 次–&gt;设置参数:10000 次–&gt;执行:1 次 非批量：预编译 sql:10000 次–&gt;设置参数:10000 次–&gt;执行:10000 次 学习 mybatis 的一些坑ERROR11234567org.apache.ibatis.exceptions.PersistenceException: ### Error building SqlSession.### The error may exist in EmployeeMapper.xml### Cause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: org.apache.ibatis.builder.BuilderException: Error creating document instance. Cause: org.xml.sax.SAXParseException; lineNumber: 14; columnNumber: 9; XML 文档结构必须从头至尾包含在同一个实体内。 原因：EmployeeMapper.xml 文件里的 mapper 标签缺了一个 ‘’&gt;’’ 解决方案：添加“&gt;” ERROR21234567org.apache.ibatis.exceptions.PersistenceException:### Error querying database. Cause: java.lang.UnsupportedOperationException### The error may exist in EmployeeMapper.xml### The error may involve com.zwb.mybatis.dao.EmployeeMapper.getAllEmp### The error occurred while handling results### SQL: select * from tbl_employee### Cause: java.lang.UnsupportedOperationException 原因：getAllEmp()返回类型是 List，在EmployeeMapper.xml 文件中 resultType 属性配置的类型为java.util.List，但是 resultType 属性设置的是 List 里面每一项的类型 解决方案：将EmployeeMapper.xml 文件中 resultType 属性配置的类型为com.zwb.mybatis.bean.Employee","categories":[{"name":"java","slug":"java","permalink":"https://supertramp7.github.io/categories/java/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://supertramp7.github.io/tags/mybatis/"}]},{"title":"如何搭建一个自己的博客","slug":"personal_blog","date":"2022-02-19T08:17:38.196Z","updated":"2022-02-19T08:39:48.877Z","comments":true,"path":"personal_blog/","link":"","permalink":"https://supertramp7.github.io/personal_blog/","excerpt":"","text":"引言为什么要搭建自己的个人博客工作和学习过程中，我们经常遇到一些这样或那样的问题，此时我们可能会在网上找到相应的解决方法。但是过了一段时间之后，当我们再次碰到类似的问题时，早已忘记以前是怎么解决的了，于是又要到网上去搜，浪费大量的时间和精力。面对这些重复的问题，我们为什么不能把它们记录下来呢？ 在我看来，搭建自己的个人博客主要有以下好处： 有助于养成归纳总结的习惯，帮助记忆，把别人的知识变成自己的知识。 通过记录自己工作和生活，锻炼自己的写作的能力。 培养开放（开源）意识，与大家一起学习交流，共同进步。 搭建个人博客的多种选择目前，主流的博客主要分静态博客和动态博客两类： 所谓动态，就是指有前端有后端，可以登录到后台进行管理。静态博客是纯前端的展示，没有后端。 1. 动态博客搭建 1）直接在简书、CSDN（最近吐槽的比较多）、知乎、博客园等动态博客公共平台上写。 优点：简单 缺点：别人家的东西限制多 2）使用 WordPress 等成熟框架搭建动态博客 + 服务器部署 优点：相对简单 缺点：笨重 3）使用 Java、PHP、Python 等语言开发属于自己的动态博客 + 服务器部署 优点：功能强大 缺点：麻烦、不易上手 2. 静态博客搭建 1）使用 Hexo、Hugo、jekyll 等主流博客框架搭建静态博客 + 托管在 GitHub、码云等公共平台。 优点：轻量级、易上手、不花钱 缺点：访问速度慢 2）使用 Hexo、Hugo、jekyll 等主流博客框架搭建静态博客 + 云端服务器部署。 优点：有独立的域名、访问速度快、自主可控 缺点：要花钱买域名和云服务器 (我用的就是“Hexo+GitHub”这种方法，接下来详细地给大家介绍一下采用该方法搭建个人博客的原理和步骤。) 什么是 HexoHexo 可以理解为是基于 node.js 制作的一个博客工具。它是一个静态页面生成和上传的工具。 为什么选择 HexoHexo 在本地安装，不需要部署到我们的服务器上。我们只需要在本地通过 markdown 编写文章，然后让 Hexo 帮我们生成静态的 html 页面，并通过 Hexo 将生成的 html 文件上传到我们的服务器。 为什么选择托管在 GitHub 上托管在 github 上方便、不花钱 一、工作原理使用 Hexo 搭建个人博客并托管在 GitHub 的原理：简单来说就是在本地计算机搭建 Hexo 环境，Hexo 通过 generate 命令将*.md 文件渲染成静态的 html 页面，然后 Hexo 通过 deploy 命令触发 git 用户通过公钥免密登陆服务器，进而将静态页面推送到服务器的 git 仓库（repository）中。 二、搭建步骤在本地计算机安装 Hexo 环境1. 安装 Node.js去 Node.js 官网[2]下载 Windows (x64)长期支持版 Long Term Support (LTS) schedule。按提示逐步安装即可，安装完成后打开 cmd 查看版本号验证是否安装成功。 12C:\\Users\\11617&gt;node -vv12.14.1 Node.js 中自带了 npm 包管理工具，在 cmd 中查看 npm 版本。 12C:\\Users\\11617&gt;npm -v6.13.4 2. 安装 Gitgit 是一个版本控制工具，国外镜像下载巨慢，建议前往淘宝 Git for Windows 镜像下载 git 安装包。按提示逐步安装即可，安装完成后右键菜单中出现 Git Bash 和 Git GUI 菜单表明安装成功，如下图所示。 注：git 和 github 是两个东西。github 是基于 git 二次开发的，git 是 github 的核心，git 负责与 github 相关的所有本地工作。 3. 安装 Hexo在 F 盘新建 blog 文件夹用来存放个人博客，进入该文件夹，右键打开 Git Bash，使用 npm 安装 Hexo。 1$ npm install -g hexo-cli Hexo 安装完成后，在 blog 文件夹下新建 myblog 项目，并对其进行初始化。 12$ hexo init myblogl$ cd myblog 此时，会在 blog 文件夹下新建 myblog 文件夹，并在其内部生成相应的项目文件。如下图所示： 在 myblog 文件夹下启动 hexo 服务。 1$ hexo s 此时在本地打开浏览器，通过 http://localhost:4000/ 便可访问基于 Hexo 的个人博客主页了。如下图所示： 4. 我的第一篇文章在 myblog 文件夹下，右键打开 Git Bash，新建第一篇文章。 1$ hexo n &quot;我的第一篇博客文章&quot; 运行结果如下： 进入到 myblog/source/_posts/文件夹下。 123$ cd source&#x2F;_posts$ lshello-world.md 我的第一篇博客文章.md 打开“我的第一篇博客文章.md”并编辑保存。 重新退回到 myblog 文件夹下，清除缓存文件 db.json 和已生成的静态文件 public ，生成网站静态文件到默认设置的 public 文件夹，并重新启动 hexo。 1234$ cd ../..$ hexo clean$ hexo g$ hexo s 三、部署 GitHub将博客部署到 GitHub 上1. 登录 GitHub2. 新建仓库 —&gt; new repository 点击 Create repository，进入下一步。 3. 安装 git 插件1$ cnpm install --save hexo-deployer-git 4. 配置_config.yml 文件在 myblog 文件夹下打开_config.yml 文件并编辑保存。 1$ vim _config.yml 编辑如下： 保存退出后重新部署： 1$ hexo d 输入 github 账号、密码后刷新 GitHub 就可以看到博客。 5. 访问博客我的博客 四、更换主题yilila 主题1. 下载主题在 myblog 文件夹下，右键打开 Git Bash，下载主题到 themes 下的 yilia 文件夹下。 1$ git clone https://github.com/litten/hexo-theme-yilia.git themes yilia 2. 配置主题打开_config.yml 修改主题并保存。 3. 成功使用1234$ hexo clean$ hexo g$ hexo s$ hexo d 4. 优化Hexo yilia 主题一揽子优化方案 butterfly 主题1. 下载主题1git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly 2. 配置主题_config.yml 中 1theme：butterfly 3. 安装插件如果没有 pug 以及 stylus 的渲染器，请下载安装： 1npm install hexo-renderer-pug hexo-renderer-stylus --save ERROR1执行命令：git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 出现错误：fatal: unable to access &#39;https://github.com/litten/hexo-theme-yilia.git/&#39;: OpenSSL SSL_read: Connection was reset, errno 10054 原因：因为 git 在拉取或者提交项目时，中间会有 git 的 http 和 https 代理，但是我们本地环境本身就有 SSL 协议了，所以取消 git 的 https 代理即可，不行再取消 http 的代理。 解决方案：取消 git 本身的 https 代理，使用自己本机的代理，如果没有的话，其实默认还是用 git 的。 12345// 取消http代理git config --global --unset http.proxy// 取消https代理git config --global --unset https.proxy ERROR2执行代码：hexo d 出现错误：Logon failed, use ctrl+c to cancel basic credential prompt.remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead. 原因：自从 21 年 8 月 13 后不再支持用户名密码的方式验证了，需要创建个人访问令牌(personal access token)。 解决方案： 1.生成令牌 1）登录 GitHub 官网，点击 Settings 2）点击左侧 Developer settings 3）点击左侧 Personal access tokens 4）点击 Generate new token 5）填写 token 信息 6）点击 Generate token，生成令牌 2.应用令牌 首次推送提示 输入的的 2 次用户名密码，第一次是输入github的登陆用户名和密码；第二次是输入上面截图操作步骤最终填写的 Note（用户名） 和生成的 tokens（密码） ERROR3出现错误：hexo 博客在 yilia 主题下不显示作者名字解决方案：yilia 需要在主题下的_config.yml 加入 author: ,不在 menu:下","categories":[{"name":"博客","slug":"博客","permalink":"https://supertramp7.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://supertramp7.github.io/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"https://supertramp7.github.io/tags/blog/"},{"name":"github","slug":"github","permalink":"https://supertramp7.github.io/tags/github/"},{"name":"butterfly","slug":"butterfly","permalink":"https://supertramp7.github.io/tags/butterfly/"},{"name":"yilia","slug":"yilia","permalink":"https://supertramp7.github.io/tags/yilia/"}]}],"categories":[{"name":"java","slug":"java","permalink":"https://supertramp7.github.io/categories/java/"},{"name":"博客","slug":"博客","permalink":"https://supertramp7.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://supertramp7.github.io/tags/mybatis/"},{"name":"hexo","slug":"hexo","permalink":"https://supertramp7.github.io/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"https://supertramp7.github.io/tags/blog/"},{"name":"github","slug":"github","permalink":"https://supertramp7.github.io/tags/github/"},{"name":"butterfly","slug":"butterfly","permalink":"https://supertramp7.github.io/tags/butterfly/"},{"name":"yilia","slug":"yilia","permalink":"https://supertramp7.github.io/tags/yilia/"}]}