{"meta":{"title":"Supertramp","subtitle":"You are being watched.","description":"You're being watched.","author":"supertramp","url":"https://supertramp7.github.io","root":"/"},"pages":[{"title":"CATEGORIES","date":"2022-02-19T08:24:58.000Z","updated":"2022-02-19T08:25:23.975Z","comments":true,"path":"categories/index.html","permalink":"https://supertramp7.github.io/categories/index.html","excerpt":"","text":""},{"title":"mood","date":"2022-02-28T10:34:06.000Z","updated":"2022-02-28T10:34:06.491Z","comments":true,"path":"mood/index.html","permalink":"https://supertramp7.github.io/mood/index.html","excerpt":"","text":""},{"title":"study","date":"2022-02-28T10:34:18.000Z","updated":"2022-02-28T10:34:18.278Z","comments":true,"path":"study/index.html","permalink":"https://supertramp7.github.io/study/index.html","excerpt":"","text":""},{"title":"TAGS","date":"2022-02-19T08:21:52.000Z","updated":"2022-02-19T08:23:21.829Z","comments":true,"path":"tags/index.html","permalink":"https://supertramp7.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"学习mybatis的一些坑","slug":"mybatis","date":"2021-02-19T08:27:31.000Z","updated":"2022-02-19T10:24:34.488Z","comments":true,"path":"mybatis/","link":"","permalink":"https://supertramp7.github.io/mybatis/","excerpt":"","text":"mybatis 知识点day1–mybatis 基础1. mybatis 的使用步骤 1、根据xml配置文件（全局配置文件）创建一个SqlSessionFactory对象:有数据源一些运行环境信息 2、sql 映射文件：配置了每一个sql，以及sql的封装规则等； 3、将sql映射文件注册在全局配置文件中 4、写代码 1）根据全局配置文件得到SqlSessionFactory 2）使用SqlSessionFactory获取到session对象，使用他来执行增删改查，session用完关闭 3）方法一：使用sql的唯一标识来告诉mybatis执行那个 sql ，sql都是保存在sql映射文件中的 方法二：（接口式编程）使用接口获取mapper对象，再用mapper调用接口中的方法（和hibernate相似） 2. mybatis 的全局配置文件 mybatis-config.xml （属性的顺序不能改变） properties 属性：引入外部 properties 配置文件的内容 ​ resource: 引入类路径下的资源 ​ url: 引入网络路径或者磁盘路径下的资源 settings 属性：包含很多重要的设置项 ​ setting:用来设置每一个设置项 ​ name: 设置项名 ​ value: 设置项取值 typeAliases 属性: 别名处理器，可以为 Java 类型起别名，别名不区分大小写 ​ typeAlias: 为某个 Java 类型起别名 ​ type: 指定要起别名的类型全类名，默认别名就是类名小写；employee ​ alias: 指定新的别名 ​ package: 为某个包下的所有类批量起别名 ​ name: 指定包名（为当前包以及下面所有的后代包的每一个类都起一个默认别名（类名小写） ​ 批量起别名的情况下，使用@Alias 注解为某个类型指定新的别名 environments:环境，mybatis 可以配置多种环境，default 指定使用某种环境，可以达到快速切换环境 ​ environment：配置一个具体的环境信息；id 代表当前环境的唯一标识；必须有两个标签： ​ transactionManager：事务管理器； ​ type : 事务管理器的类型；JDBC|MANAGED ​ 自定义事务管理器：实现 TransactionFactory 接口，type 指定为全类名 ​ dataSource：数据源；​ type : UNPOOLED|POOLED|JNDI ​ 自定义数据源：实现 DataSourceFactory 接口，type 指定为全类名 databaseIdProvider:支持多数据库厂商的；type=”DB_VENDOR”：VendorDatabaseIdProvider，作用就是得到数据库厂商的标识，mybatis 就能根据数据库厂商标识来执行不同的 sql；MySQL,Oracle,SQL Server,xxxx mappers:将 sql 映射注册到全局配置中 mapper：注册一个 sql 映射 注册配置文件 resource:引用类路径下的 sql 映射文件url:引用网络路径或者磁盘路径下的 sql 映射文件 注册接口 class:引用（注册）接口 1、有 sql 映射文件，映射文件名必须和接口同名，并且放在与接口同一目录下； 2、 没有 sql 映射文件，所有的 sql 都是利用注解写在接口上; 推荐： 比较重要的、复杂的 Dao 接口我们来写 sql 映射文件 不重要的、简单的 Dao 接口，为了快速开发可以使用注解 package：批量注册; 注：必须要求映射文件和接口放在同一目录下，为了看起来方便，将 conf 下的映射文件的包名改为和 src 下的接口的包名一样（编译的时候是在一个同一个包下） 3. mybatis 映射文件 EmployeeMapper.xml1、增删改查 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!-- namespace：名称空间 id:唯一标识 resultType:返回值类型 #&#123;id&#125;: 从传递过来的参数中取出id值 --&gt; &lt;select id=&quot;getEmpById&quot; resultType=&quot;com.zwb.mybatis.bean.Employee&quot; databaseId=&quot;mysql&quot;&gt; select * from tbl_employee where id=#&#123;id&#125; &lt;/select&gt; &lt;!-- public void addEmp(Employee employee); --&gt; &lt;!-- parameterType：参数类型，可以省略； 获取自增主键的值： mysql支持自增主键，自增主键值的获取，mybatis也是利用statement.getGeneratedKeys(); useGeneratedKeys=&quot;true&quot;: 使用自增主键获取主键值策略 keyProperty：指定对应的主键属性，也就是mybatis获取到主键值以后，将这个值封装给JavaBean的哪个属性 --&gt; &lt;insert id=&quot;addEmp&quot; parameterType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; insert into tbl_employee(last_name,email,gender) values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;) &lt;/insert&gt; &lt;!-- public void updateEmp(Employee employee); --&gt; &lt;update id=&quot;updateEmp&quot;&gt; update tbl_employee set last_name=#&#123;lastName&#125;,email=#&#123;email&#125;,gender=#&#123;gender&#125; where id=#&#123;id&#125; &lt;/update&gt; &lt;!-- public void deleteEmpById(Integer id); --&gt; &lt;delete id=&quot;deleteEmpById&quot;&gt; delete from tbl_employee where id=#&#123;id&#125; &lt;/delete&gt; /** * 测试增删改 * 1. mybatis 允许增删改直接定义以下类型返回值 * Integer、Long、Boolean * 2. 手动提交数据 * sqlSessionFactory.openSession(); ===&gt; 手动提交 * sqlSessionFactory.openSession(true); ===&gt; 自动提交 * @throws IOException */ 2、mybatis 参数处理 单个参数：mybatis 不会做特殊处理。 ​ #{参数名(实际上可以任意写，因为参数就一个)}:取出参数值。 多个参数：mybatis 会做特殊处理。 ​ 多个参数会被封装成一个 map ​ key:param1…paramN，或者参数的索引 ​ value:传入的参数值 ​ #{}就是从 map 中获取指定的 key 的值； ​ 异常： ​ org.apache.ibatis.binding.BindingException: ​ Parameter &#39;id&#39; not found. ​ Available parameters are [arg1, arg0, param1, param2] ​ 操作： ​ 方法：public Employee getEmpByIdAndLastName(Integer id,String lastName); ​ 取值：#{id},#{lastName} 命名参数：明确指定封装参数时 map 的 key。 ​ 多个参数会被封装成一个 map, ​ key:使用@Param()注解指定的值 ​ value:传入的参数值 ​ #{指定的 key}取出对应的参数值 POJO: ​ 如果多个参数正好是业务逻辑的数据模型，可以直接传入 pojo ​ #{属性名}:取出掺入的 pojo 的属性值 Map: ​ 如果多个参数不是业务逻辑的数据模型，可以传入 map ​ #{key}:取出 map 中对应的值 TO: ​ 如果多个参数不是业务逻辑的数据模型，但经常使用，推荐来编写一个 TO(Transfer Object)数据传输对象 ​ Page&#123; ​ int index; ​ int size; ​ &#125; ====================思考========================= public Employee getEmp(@Param(“id”)Integer id,String lastName); 取值：id=#{id/parma1} last_name=#{param2} public Employee getEmp(Integer id,@Param(“e”)Employee employee); 取值：id=#{parma1} last_name=#{param2.lastName/e.lastName} // 特别注意：如果是Collection(List、Set)类型或者是数组，也会特殊处理。也是把传入的list或者数组封装在map中 key:Collection(collection),如果是List还可以使用这个key(list) 数组(array)public Employee getEmpById(List ids); 取值：取出第一个id的值：id=#{list[0]} ===================结合源码，mybatis怎么处理参数========================== ===================参数值的获取==========================select * from tbl_employee where id=${id} and last_name=#{lastName}select * from tbl_employee where id=1 and last_name=?#{}：可以获取map中的值或者pojo对象属性的值${}：可以获取map中的值或者pojo对象属性的值 区别： #{}：是以预编译的形式，将参数设置到sql语句中；PreparedStatement；防止sql注入 ${}：取出的值直接拼装在sql语句中；会有安全问题 大多情况下，我们取参数的值都应该去使用#{}； 某些情况下(原生jdbc不支持占位符的地方)，比如分表、排序..：按照年份分表拆分 select * from ${year}_salary where xxx; select * from tbl_employee order by ${f_name} ${order} #{}:更丰富的用法： 规定参数的一些规则： javaType、jdbcType、mode（存储过程）、numericScale、 resultMap、typeHandler、jdbcTypeName、expression（未来准备支持的功能） javaType通常需要在某种特定的条件下被设置： 在我们数据为null的时候，有些数据库可能不能识别mybatis对null的默认处理。比如Oracle（报错）； javaType OTHER：无效的类型；因为mybatis对所有的null都映射的是原生Jdbc的OTHER类型，oracle不认识； 由于全局配置中：javaTypeForNull=OTHER；oracle不支持；两种办法1、#{email,javaType=OTHER};2、全局设置javaTypeForNull=NULL 3、select 返回 List ​ esultType：如果返回的是一个集合，要写集合中元素的类型 4、select 记录封装 ​ 一条记录封装一个 map： ​ Map&lt;Integer,Employee&gt;：key 这条记录的主键，value 是这条记录 ​ 使用注解@MapKey(“id”)，告诉 mybatis 封装 map 时使用哪个属性作为 map 的 key 5、select resultMap 1）resultMap 自定义映射规则 12345678910111213141516171819&lt;!-- 自定义某个JavaBean的封装规则:type:自定义规则的Java类型; id:唯一id方便引用 --&gt; &lt;!-- 此时，全局配置文件里的驼峰命名规则可以去除掉了 --&gt; &lt;resultMap type=&quot;com.zwb.mybatis.bean.Employee&quot; id=&quot;MyEmp&quot;&gt; &lt;!-- 指定主键列的封装规则:column:指定哪一列； property:指定对应的javabean属性 --&gt; &lt;!-- result定义主键也可以，但是，id定义主键会底层有优化 --&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;!-- 指定非主键列的封装规则: --&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot;/&gt; &lt;!-- 其他不指定的列会自动封装，但是通常在resultMap里把全部的规则都写上 --&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot;/&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt; &lt;/resultMap&gt; &lt;!-- resuleMap:自定义结果集映射规则；和 resultType 不能同时出现 --&gt; &lt;!-- public Employee getEmpById(Integer id); --&gt; &lt;select id=&quot;getEmpById&quot; resultMap=&quot;MyEmp&quot;&gt; select * from tbl_employee where id=#&#123;id&#125; &lt;/select&gt; 2）resultMap 关联查询 1 - 级联属性封装结果集 1234567891011121314151617181920&lt;!-- 场景一： 查询Employee的同时，查出所在部门 ;id lastName email gender dept --&gt; &lt;!-- 联合查询：级联属性封装结果集 --&gt; &lt;resultMap type=&quot;com.zwb.mybatis.bean.Employee&quot; id=&quot;MyEmp2&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;lastName&quot; property=&quot;lastName&quot; /&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot; /&gt; &lt;result column=&quot;d_id&quot; property=&quot;dept.id&quot; /&gt; &lt;result column=&quot;d_name&quot; property=&quot;dept.departmentName&quot; /&gt; &lt;/resultMap&gt; &lt;!-- public Employee getEmpAndDept(Integer id); --&gt; &lt;select id=&quot;getEmpAndDept&quot; resultMap=&quot;MyEmp2&quot;&gt; SELECT e.id id,e.last_name lastName,e.email email,e.gender gender,d.id d_id,d.dept_name d_name from tbl_employee e,tbl_dept d WHERE e.d_id=d.id AND e.id=#&#123;id&#125; &lt;/select&gt; 2 - association 定义关联的单个对象的封装规则 12345678910111213&lt;!-- 使用association定义关联的单个对象的封装规则 --&gt; &lt;resultMap type=&quot;com.zwb.mybatis.bean.Employee&quot; id=&quot;MyEmp3&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;lastName&quot; property=&quot;lastName&quot; /&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot; /&gt; &lt;!-- association可以指定联合的javabean对象：property：指定哪个属性是联合的对象；javaType：指定这个属性对象的类型【不能省略】 --&gt; &lt;association property=&quot;dept&quot; javaType=&quot;com.zwb.mybatis.bean.Department&quot;&gt; &lt;id column=&quot;d_id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;d_name&quot; property=&quot;departmentName&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; 3 - association 分步查询 1234567891011121314151617181920&lt;!-- 使用association进行分步查询:step1:先按照员工id查询员工信息；step2：根据查询员工信息中的d_id值去部门表中查部门信息；step3：部门设置到员工中 --&gt; &lt;resultMap type=&quot;com.zwb.mybatis.bean.Employee&quot; id=&quot;MyEmpByStep&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot; /&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot; /&gt; &lt;!-- association定义关联对象的封装规则：select:表明当前属性是调用select指定的方法查出的结果；column：指定将哪一列的值传给这个方法 --&gt; &lt;!-- 流程：使用select指定的方法（传入column指定的这列参数的值）查出对象，并封装给property指定的属性 --&gt; &lt;association property=&quot;dept&quot; select=&quot;com.zwb.mybatis.dao.DepartmentMapper.getDeptById&quot; column=&quot;d_id&quot;&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!-- public Employee getEmpByIdStep(Integer id); --&gt; &lt;select id=&quot;getEmpByIdStep&quot; resultMap=&quot;MyEmpByStep&quot;&gt; SELECT * from tbl_employee where id=#&#123;id&#125; &lt;/select&gt; 4 - 延迟加载(懒加载) （按需加载）：部门信息在我们使用的时候再去查询，在分段查询的基础之上加上两个配置 123&lt;!-- 延迟加载 --&gt;&lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;&lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; 5 - collection 定义关联集合类型封装规则（一对多的情况） 123456789101112131415161718192021222324&lt;!-- collection嵌套结果集的方式，定义关联的集合类型元素的封装规则 --&gt; &lt;resultMap type=&quot;com.zwb.mybatis.bean.Department&quot; id=&quot;MyDept&quot;&gt; &lt;id column=&quot;did&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;dept_name&quot; property=&quot;departmentName&quot;/&gt; &lt;!-- collection定义关联的集合类型的属性的封装规则;ofType:指定集合里面元素的类型 --&gt; &lt;collection property=&quot;emps&quot; ofType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; &lt;!-- 定义这个集合中元素的封装规则 --&gt; &lt;id column=&quot;eid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot;/&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot;/&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- public Department getDeptByIdPlus(Integer id); --&gt; &lt;select id=&quot;getDeptByIdPlus&quot; resultMap=&quot;MyDept&quot;&gt; SELECT d.id did,d.dept_name dept_name,e.id eid,e.last_name last_name,e.email email,e.gender gender FROM tbl_dept d LEFT JOIN tbl_employee e ON d.id=e.d_id WHERE d.id=#&#123;id&#125; &lt;/select&gt; 6 - collection 的分布查询和延迟加载[和 association 一样] 1234567891011&lt;resultMap type=&quot;com.zwb.mybatis.bean.Department&quot; id=&quot;MyDeptStep&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;dept_name&quot; property=&quot;departmentName&quot;/&gt; &lt;collection property=&quot;emps&quot; select=&quot;com.zwb.mybatis.dao.EmployeeMapperPlus.getEmpsByDid&quot; column=&quot;id&quot;&gt;&lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- public Department getDeptByIdStep(Integer id); --&gt; &lt;select id=&quot;getDeptByIdStep&quot; resultMap=&quot;MyDeptStep&quot;&gt; SELECT id,dept_name from tbl_dept WHERE id=#&#123;id&#125; &lt;/select&gt; 7 - 分步查询传递多列值和 fetchType 扩展：多列值传递过去：将多列的值封装 map 传递：column=&quot;&#123;key1=column1,key2=column2&#125;&quot; ​ fetchType=”lazy”:表示使用延迟加载：lazy[延迟加载]|eager[立即加载] 8 - discriminator 鉴别器 123456789101112131415161718192021222324&lt;!-- discriminator鉴别器：mybatis可以使用discriminator判断某列的值，然后根据某列的值改变封装行为 --&gt; &lt;!-- 封装Employee：如果查出的是女生，就把部门信息查询出来，否则不查询；如果是男生，把last_name赋值给email --&gt; &lt;resultMap type=&quot;com.zwb.mybatis.bean.Employee&quot; id=&quot;MyEmpDis&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot; /&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot; /&gt; &lt;!-- column:指定要判断的列名；javaType:列值对应的java类型 --&gt; &lt;discriminator javaType=&quot;string&quot; column=&quot;gender&quot;&gt; &lt;!-- resultType:指定封装结果类型 ;[resultType|resultMap]选其一 --&gt; &lt;case value=&quot;0&quot; resultType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; &lt;association property=&quot;dept&quot; select=&quot;com.zwb.mybatis.dao.DepartmentMapper.getDeptById&quot; column=&quot;d_id&quot;&gt; &lt;/association&gt; &lt;/case&gt; &lt;case value=&quot;1&quot; resultType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot; /&gt; &lt;result column=&quot;last_name&quot; property=&quot;email&quot; /&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot; /&gt; &lt;/case&gt; &lt;/discriminator&gt; &lt;/resultMap&gt; day2–动态 sql动态 sql1、if 判断 123456789101112131415161718192021&lt;!-- 查询员工，要求：携带了哪个字段，查询条件就带上这个字段的值 --&gt;&lt;!-- public List&lt;Employee&gt; getEmpsByConditionIf(Employee employee); --&gt;&lt;select id=&quot;getEmpsByConditionIf&quot; resultType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; select * from tbl_employee where &lt;!-- test:判断表达式 --&gt; &lt;if test=&quot;id!=null&quot;&gt; id=#&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;lastName!=null and lastName!=&#x27;&#x27;&quot;&gt; and last_name like #&#123;lastName&#125; &lt;/if&gt; &lt;if test=&quot;email!=null and email.trim()!=&#x27;&#x27;&quot;&gt; and email=#&#123;email&#125; &lt;/if&gt; &lt;!-- ognl 会进行字符串与数字的转换判断 --&gt; &lt;if test=&quot;gender==0 or gender==1&quot;&gt; and gender=#&#123;gender&#125; &lt;/if&gt;&lt;/select&gt; 2、where 查询 查询的时候，如果某些条件没带可能 sql 拼装会有问题： 解决：1）给 where 后面加上 1=1 ，以后的条件都 and xxx； ​ 2）mybatis 使用 where 标签来将所有的查询条件包括在内,mybatis 就会将 where 标签中拼装的 sql，多出来的 and 或者 or 去掉（and 在后面的话不行） 12345678910111213141516&lt;where&gt; &lt;!-- test:判断表达式 --&gt; &lt;if test=&quot;id!=null&quot;&gt; id=#&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;lastName!=null and lastName!=&#x27;&#x27;&quot;&gt; and last_name like #&#123;lastName&#125; &lt;/if&gt; &lt;if test=&quot;email!=null and email.trim()!=&#x27;&#x27;&quot;&gt; and email=#&#123;email&#125; &lt;/if&gt; &lt;!-- ognl 会进行字符串与数字的转换判断 --&gt; &lt;if test=&quot;gender==0 or gender==1&quot;&gt; and gender=#&#123;gender&#125; &lt;/if&gt;&lt;/where&gt; 3、trim 自定义字符串截取 12345678910111213141516171819202122232425&lt;select id=&quot;getEmpsByConditionTrim&quot; resultType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; select * from tbl_employee &lt;!-- 后面多出的 and 或者 or where 标签不能解决 --&gt; &lt;!-- prefix:前缀：trim标签体中是整个字符串拼串后的结果，prefix给拼串后的整个字符串加一个前缀； suffix: 后缀，suffix给拼串后的整个字符串加一个后缀； prefixOverrides: 前缀覆盖：去掉整个字符串前面多余的字符； suffixOverrides: 后缀覆盖：去掉整个字符串后面多余的字符 --&gt; &lt;!-- 自定义字符串的截取规则 --&gt; &lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;and&quot;&gt; &lt;if test=&quot;id!=null&quot;&gt; id=#&#123;id&#125; and &lt;/if&gt; &lt;if test=&quot;lastName!=null and lastName!=&#x27;&#x27;&quot;&gt; last_name like #&#123;lastName&#125; and &lt;/if&gt; &lt;if test=&quot;email!=null and email.trim()!=&#x27;&#x27;&quot;&gt; email=#&#123;email&#125; and &lt;/if&gt; &lt;if test=&quot;gender==0 or gender==1&quot;&gt; gender=#&#123;gender&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; 4、choose 分支选择：带了 break 的 switch-case，如果带了 id 就用 id 查，只会进入其中一个 1234567891011121314&lt;select id=&quot;getEmpsByConditionChoose&quot; resultType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; select * from tbl_employee &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;id!=null&quot;&gt;id=#&#123;id&#125;&lt;/when&gt; &lt;when test=&quot;lastName!=null and lastName!=&#x27;&#x27;&quot;&gt;last_name like #&#123;lastName&#125;&lt;/when&gt; &lt;when test=&quot;email!=null and email.trim()!=&#x27;&#x27;&quot;&gt;email=#&#123;email&#125;&lt;/when&gt; &lt;otherwise&gt; gender =0 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; 5、set 与 if 结合的动态更新 123456789&lt;update id=&quot;updateEmp&quot;&gt; update tbl_employee &lt;set&gt; &lt;if test=&quot;lastName!=null&quot;&gt;last_name=#&#123;lastName&#125;,&lt;/if&gt; &lt;if test=&quot;email!=null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt; &lt;if test=&quot;gender!=null&quot;&gt;gender=#&#123;gender&#125;&lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125; &lt;/update&gt; 123456789Trim:&lt;update id=&quot;updateEmp&quot;&gt; update tbl_employee &lt;trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;lastName!=null&quot;&gt;last_name=#&#123;lastName&#125;,&lt;/if&gt; &lt;if test=&quot;email!=null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt; &lt;if test=&quot;gender!=null&quot;&gt;gender=#&#123;gender&#125;&lt;/if&gt; &lt;/trim&gt; where id=#&#123;id&#125; &lt;/update&gt; 6、foreach 遍历集合 12345678910111213&lt;select id=&quot;getEmpsByConditionForEach&quot; resultType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; select * from tbl_employee &lt;!-- collection:指定要遍历的集合：list类型的参数会特殊处理封装在map中，map的key就叫list； item：将遍历出的元素赋值给指定的变量 separator:每个元素之间的分隔符 open:遍历出所有结果拼接一个开始的字符 close:遍历出所有结果拼接一个结束的字符 index:索引。遍历list的时候index是索引，item是值；遍历map时，index就是map的key，item是map的值 #&#123;变量名&#125;就能取出变量得值也就是当前遍历出的元素--&gt; &lt;foreach collection=&quot;ids&quot; item=&quot;item_id&quot; separator=&quot;,&quot; open=&quot;where id in(&quot; close=&quot;)&quot;&gt; #&#123;item_id&#125; &lt;/foreach&gt;&lt;/select&gt; 7、foreach 批量保存（MySQL 数据库）（推荐方法一） 方法一：foreach 遍历 values(),(),() 123456&lt;insert id=&quot;addEmps&quot;&gt; INSERT INTO tbl_employee(last_name,email,gender,d_id) VALUES &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;,&quot;&gt; (#&#123;emp.lastName&#125;,#&#123;emp.email&#125;,#&#123;emp.gender&#125;,#&#123;emp.dept.id&#125;) &lt;/foreach&gt;&lt;/insert&gt; 方法二：将数据库连接属性添加 allowMultiQueries=true ，这种分号分隔多个 sql 可以用于其他的批量操作（删除，修改） dbconfig.properties 里 jdbc.url=jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true 123456&lt;insert id&#x3D;&quot;addEmps&quot;&gt; &lt;foreach collection&#x3D;&quot;emps&quot; item&#x3D;&quot;emp&quot; separator&#x3D;&quot;;&quot;&gt; INSERT INTO tbl_employee(last_name,email,gender,d_id) VALUES (#&#123;emp.lastName&#125;,#&#123;emp.email&#125;,#&#123;emp.gender&#125;,#&#123;emp.dept.id&#125;) &lt;&#x2F;foreach&gt; &lt;&#x2F;insert&gt; 8、两个内置参数 _parameter&amp; _databaseId :不只是方法传递过来的参数可以被用来判断，取值，mybatis 默认还有两个内置参数： 1）_parameter:代表整个参数 单个参数：_parameter就是这个参数 多个参数：参数会被封装为一个 map，_parameter就是代表这个 map2）_databaseId:如果配置了 databaseIdProvider 标签，_databaseId就是代表当前数据库的别名 123456789101112&lt;select id=&quot;getEmpsTestInnerParameter&quot; resultType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; &lt;if test=&quot;_databaseId==&#x27;mysql&#x27;&quot;&gt; select * from tbl_employee &lt;if test=&quot;_parameter!=null&quot;&gt; where last_name = #&#123;lastName&#125; &lt;/if&gt; &lt;/if&gt; &lt;!-- 假装有oracle数据库 --&gt; &lt;if test=&quot;_databaseId==&#x27;oracle&#x27;&quot;&gt; select * from employee &lt;/if&gt; &lt;/select&gt; 9、bind 绑定：可以将 OGNL 表达式的值绑定一个变量中，方便后来引用这个变量得值 1234567891011121314&lt;select id=&quot;getEmpsTestInnerParameter&quot; resultType=&quot;com.zwb.mybatis.bean.Employee&quot;&gt; &lt;!-- bind：可以将OGNL表达式的值绑定一个变量中，方便后来引用这个变量得值 --&gt; &lt;bind name=&quot;_lastName&quot; value=&quot;&#x27;_&#x27;+lastName+&#x27;%&#x27;&quot;/&gt; &lt;if test=&quot;_databaseId==&#x27;mysql&#x27;&quot;&gt; select * from tbl_employee &lt;if test=&quot;_parameter!=null&quot;&gt; where last_name like #&#123;_lastName&#125; &lt;/if&gt; &lt;/if&gt; &lt;!-- 假装有oracle数据库 --&gt; &lt;if test=&quot;_databaseId==&#x27;oracle&#x27;&quot;&gt; select * from employee &lt;/if&gt; &lt;/select&gt; 10、sql 标签：抽取可重用的 sql 片段，方便后面引用 1）sql 抽取：经常将要查询的列名，或者插入用的列名抽取出来方便使用2）include 来引用已经抽取的 sql3）include 还可以自定义一些 property，sql 标签内部就能使用自定义的属性 property 取值的正确方式${prop},不能使用这种#{prop} 定义： 12345&lt;sql id=&quot;insertColumn&quot;&gt; &lt;if test=&quot;_databaseId==&#x27;mysql&#x27;&quot;&gt; last_name,email,gender,d_id,$&#123;自定义属性名&#125; &lt;/if&gt;&lt;/sql&gt; 引用： 1234&lt;!-- 引用外部定义的sql --&gt;&lt;include refid=&quot;insertColumn&quot;&gt; &lt;property name=&quot;自定义属性名&quot; value=&quot;自定义属性值&quot;/&gt;&lt;/include&gt; day3–mybatis 缓存mybatis 缓存两级缓存： 1、一级缓存（本地缓存）：sqlSession 级别的缓存，一级缓存是一直开启的； 在数据库同一次会话期间查询到的数据，会放在本地缓存中。以后如果需要获取相同的数据，直接从缓存中去拿，没必要再去查询数据库； 一级缓存的失效情况（没用到当前一级缓存的情况，效果就是,还需要再向数据库发出查询）： sqlSession 不同。 sqlSession 相同，查询条件不同。（当前一级缓存中还没有这个数据） sqlSession 相同，两次查询之间执行了增删改操作。 sqlSession 相同，手动清除了一级缓存（缓存清空） 2、二级缓存（全局缓存）：基于 namespace 级别的缓存，一个 namespace 对应一个二级缓存 1）工作机制： 一个会话，查询一条数据，这个数据就会被放在当前会话的一级缓存中； 如果会话关闭；一级缓存中的数据会被保存到二级缓存中；新的会话查询信息，就可以参照二级缓存中的内容； 不同的 namespace 查出的数据会放在自己对应的缓存（map）中。 sqlSession===EmployeeMapper==&gt;Employee DepartmentMapper==&gt;Department 2）效果：数据会从二级缓存中获取 查出的数据都会被默认先放在一级缓存中。只有会话提交或者关闭后，一级缓存中的数据才会转移到二级缓存中 3）使用步骤： 开启全局二级缓存配置：&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 去 mapper.xml 中配置使用二级缓存： 12345678910111213141516171819&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; readOnly=&quot;false&quot; size=&quot;1024&quot;&gt;&lt;/cache&gt; &lt;!-- eviction:缓存的回收策略： • LRU -- 最近最少使用的：移除最长时间不被使用的对象。 • FIFO -- 先进先出：按对象进入缓存的顺序来移除它们。 • SOFT -- 软引用：移除基于垃圾回收器状态和软引用规则的对象。 • WEAK -- 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。 • 默认的是 LRU。 flushInterval：缓存刷新间隔 缓存多长时间清空一次，默认不清空，设置一个毫秒值 readOnly:是否只读： true：只读；mybatis认为所有从缓存中获取数据的操作都是只读操作，不会修改数据。 mybatis为了加快获取速度，直接就会将数据在缓存中的引用交给用户。不安全，速度快 false：非只读：mybatis觉得获取的数据可能会被修改。 mybatis会利用序列化&amp;反序列的技术克隆一份新的数据给你。安全，速度慢 size：缓存存放多少元素； type：指定自定义缓存的全类名； 实现Cache接口即可； --&gt; 4）我们的 POJO 需要实现序列化接口 3、和缓存有关的设置/属性： 1）&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; false:关闭缓存（二级缓存关闭，一级缓存一直可用） 2）每个 select 标签都有 useCache=”true” false：不使用缓存（一级缓存依然使用，二级缓存不使用） 3）每个增删改标签 flushCache=”true” 增删改执行完成后就会清除缓存（一级缓存、二级缓存都会被清空）；查询标签里也有 flushCache，默认值为 false，如果改为 true,每次查询之后都会清空缓存； 4）session.clearCache(); 只是清除当前 session 的一级缓存 5）localCacheScope: 本地缓存作用域（一级缓存 SESSION）;当前会话的所有数据保存在会话缓存中； ​ STATEMENT:可以禁用一级缓存； 4、第三方 ehcache 整合 1）导入第三方缓存包即可； 2）导入与第三方缓存整合的适配包； 3）mapper.xml 中使用自定义缓存。 123&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;&gt;&lt;/cache&gt;&lt;!-- 引用缓存：namespace指定和哪个名称空间下的缓存一样 --&gt;&lt;cache-ref namespace=&quot;com.zwb.mybatis.dao.EmployeeMapper&quot;/&gt; day4–逆向工程逆向工程 Generator1、导入包 mybatis-generator-core-1.4.0.jar 2、在工程下创建 mbg.xml 文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt; &lt;generatorConfiguration&gt; &lt;!-- targetRuntime=&quot;MyBatis3Simple&quot;:生成简单版的CRUD MyBatis3：豪华版 --&gt; &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;!-- jdbcConnection:指定如何连接到目标数据库 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true&quot; userId=&quot;root&quot; password=&quot;&quot;&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- javaModelGenerator:指定javaBean的生成策略 targetPackage:目标报名 targetProject:目标工程 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.zwb.mybatis.bean&quot; targetProject=&quot;.\\src&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- sqlMapGenerator:sql映射生成策略 --&gt; &lt;sqlMapGenerator targetPackage=&quot;com.zwb.mybatis.dao&quot; targetProject=&quot;.\\conf&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- javaClientGenerator:指定mapper接口所在的位置 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.zwb.mybatis.dao&quot; targetProject=&quot;.\\src&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定要逆向分析哪些表，根据表要创建javabean --&gt; &lt;table tableName=&quot;tbl_dept&quot; domainObjectName=&quot;Department&quot;&gt;&lt;/table&gt; &lt;table tableName=&quot;tbl_employee&quot; domainObjectName=&quot;Employee&quot;&gt;&lt;/table&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt; 3、运行 Generator 123456789101112@Testpublic void testMbg() throws Exception&#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(&quot;mbg.xml&quot;); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null);&#125; 4、测试查询 12345678910111213141516171819202122232425262728293031323334@Testpublic void testMyBatis3() throws IOException &#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); SqlSession session = sqlSessionFactory.openSession(); try &#123; EmployeeMapper mapper = session.getMapper(EmployeeMapper.class); Employee employee = mapper.selectByPrimaryKey(1); System.out.println(employee); // xxxExample就是封装查询条件的 // 1. 查询所有 List&lt;Employee&gt; list = mapper.selectByExample(null); // 2. 查询员工名字中有e字母的，和员工性别是1的 // 封装员工查询条件的example EmployeeExample example = new EmployeeExample(); // 创建一个criteria拼装查询条件 Criteria criteria = example.createCriteria(); criteria.andLastNameLike(&quot;%e%&quot;); criteria.andGenderEqualTo(&quot;1&quot;); Criteria criteria2 = example.createCriteria(); criteria2.andEmailLike(&quot;%e%&quot;); example.or(criteria2); List&lt;Employee&gt; list2 = mapper.selectByExample(example); for (Employee e : list2) &#123; System.out.println(e); &#125; &#125; finally &#123; session.close(); &#125;&#125; day5–mybatis 工作原理MyBatis 工作原理1、mybatis 运行流程 1）获取 sqlSessionFactory 对象 ​ 解析文件的每一个信息保存在 Configuration 中，返回包含 Configuration 的 DefaultSqlSession； ​ 【注意：】[MappedStatement]：代表一个增删改查的详细信息 2）获取 sqlSession 对象 ​ 返回一个 DefaultSQlSession 对象，包含 Executor 和 Configuration; ​ 这一步会创建Executor对象； 3）获取接口的代理对象（MapperProxy） ​ getMapper，使用 MapperProxyFactory 创建一个 MapperProxy 的代理对象 ​ 代理对象里面包含了，DefaultSqlSession（Executor） 4）执行增删改查方法 2、总结 1）根据配置文件（全局，sql 映射）初始化出 Configuration 对象 2）创建一个 DefaultSqlSession 对象，他里面包含 Configuration 以及 Executor（根据全局配置文件中的 defaultExecutorType 创建出对应的 Executor） 3）DefaultSqlSession.getMapper()：拿到 Mapper 接口对应的 MapperProxy； 4）MapperProxy 里面有（DefaultSqlSession）； 5）执行增删改查方法： 调用 DefaultSqlSession 的增删改查（Executor）； 会创建一个 StatementHandler 对象。（同时也会创建出 ParameterHandler 和 ResultSetHandler） 调用 StatementHandler 预编译参数以及设置参数值;使用 ParameterHandler 来给 sql 设置参数 调用 StatementHandler 的增删改查方法； ResultSetHandler 封装结果 6）注意：四大对象每个创建的时候都有一个 interceptorChain.pluginAll(parameterHandler); day6–mybatis 插件1. MyBatis 插件原理在四大对象创建的时候 1、每个创建出来的对象不是直接返回的，而是 interceptorChain.pluginAll(parameterHandler); 2、获取到所有的 Interceptor（拦截器）（插件需要实现的接口）；调用 interceptor.plugin(target);返回 target 包装后的对象 3、插件机制，我们可以使用插件为目标对象创建一个代理对象；AOP(面向切面) ​ 我们的插件可以为四大对象创建出代理对象；代理对象就可以拦截到四大对象的每一个执行； 2. 插件编写：1、编写 interceptor 的实现类——MyFirstPlugin.java 2、使用@Intercepts 注解完成插件签名 123@Intercepts(&#123;@Signature(type=StatementHandler.class,method=&quot;parameterize&quot;,args=java.sql.Statement.class)&#125;) 3、将写好的插件注册到全局配置文件中 1234567&lt;!-- plugins:注册插件 --&gt;&lt;plugins&gt; &lt;plugin interceptor=&quot;com.zwb.mybatis.dao.MyFirstPlugin&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;&quot;/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 4、测试插件 3. 多个插件的运行流程创建动态代理的时候，是按照插件配置顺序创建层层代理对象。 执行目标方法的之后，按照逆向顺序执行。 4. PageHelper 分页插件1、导入 jar 包——pagehelper-5.1.9.jar jsqlparser-3.1.jar 2、在mybatis-config.xml中配置插件【注意标签的顺序】 123456&lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;!-- config params as the following --&gt; &lt;property name=&quot;param1&quot; value=&quot;value1&quot; /&gt; &lt;/plugin&gt;&lt;/plugins&gt; 3、使用分页插件 123456789101112131415161718192021222324252627282930313233@Test public void test2() throws IOException &#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); SqlSession session = sqlSessionFactory.openSession(); try &#123; EmployeeMapper mapper = session.getMapper(EmployeeMapper.class); Page&lt;Object&gt; page = PageHelper.startPage(5, 1); List&lt;Employee&gt; list = mapper.getAllEmps();// PageInfo&lt;Employee&gt; pageInfo = new PageInfo&lt;&gt;(list);// 传入要连续显示多少页 PageInfo&lt;Employee&gt; pageInfo = new PageInfo&lt;&gt;(list,5); for (Employee employee : list) &#123; System.out.println(employee); &#125; /*System.out.println(&quot;当前页码:&quot;+page.getPageNum()+&quot;，每页的记录数：&quot;+page.getPageSize()+&quot;，总记录数：&quot;+page.getTotal()); System.out.println(&quot;总页码：&quot;+page.getPages());*/ System.out.println(&quot;当前页码:&quot;+pageInfo.getPageNum()+&quot;，每页的记录数：&quot;+pageInfo.getPageSize()+&quot;，总记录数：&quot;+pageInfo.getTotal()); System.out.println(&quot;总页码：&quot;+pageInfo.getPages()); System.out.println(&quot;是否第一页&quot;+pageInfo.isIsFirstPage()); System.out.println(&quot;连续打印的页数：&quot;); int[] nums = pageInfo.getNavigatepageNums(); for (int i = 0; i &lt; nums.length; i++) &#123; System.out.println(nums[i]); &#125; &#125; finally &#123; session.close(); &#125; &#125; day7–批量操作批量：预编译 sql:1 次–&gt;设置参数:10000 次–&gt;执行:1 次 非批量：预编译 sql:10000 次–&gt;设置参数:10000 次–&gt;执行:10000 次 学习 mybatis 的一些坑ERROR11234567org.apache.ibatis.exceptions.PersistenceException:### Error building SqlSession.### The error may exist in EmployeeMapper.xml### Cause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: org.apache.ibatis.builder.BuilderException: Error creating document instance. Cause: org.xml.sax.SAXParseException; lineNumber: 14; columnNumber: 9; XML 文档结构必须从头至尾包含在同一个实体内。 原因：EmployeeMapper.xml 文件里的 mapper 标签缺了一个 ‘’&gt;’’ 解决方案：添加“&gt;” ERROR21234567org.apache.ibatis.exceptions.PersistenceException:### Error querying database. Cause: java.lang.UnsupportedOperationException### The error may exist in EmployeeMapper.xml### The error may involve com.zwb.mybatis.dao.EmployeeMapper.getAllEmp### The error occurred while handling results### SQL: select * from tbl_employee### Cause: java.lang.UnsupportedOperationException 原因：getAllEmp()返回类型是 List，在EmployeeMapper.xml 文件中 resultType 属性配置的类型为java.util.List，但是 resultType 属性设置的是 List 里面每一项的类型 解决方案：将EmployeeMapper.xml 文件中 resultType 属性配置的类型为com.zwb.mybatis.bean.Employee","categories":[{"name":"java","slug":"java","permalink":"https://supertramp7.github.io/categories/java/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://supertramp7.github.io/tags/mybatis/"},{"name":"java","slug":"java","permalink":"https://supertramp7.github.io/tags/java/"}]},{"title":"SpringBoot知识点","slug":"springboot","date":"2021-02-18T16:00:00.000Z","updated":"2022-02-19T11:59:32.390Z","comments":true,"path":"springboot/","link":"","permalink":"https://supertramp7.github.io/springboot/","excerpt":"","text":"一、SpringBoot 入门1、 SpringBoot 简介 简化 Spring 应用开发的一个框架； 整个 Spring 技术栈的一个大整合； J2EE 开发的一站式解决方案； 2、微服务2014，martin fowler 微服务：架构风格 一个应用应该是一个小组小型服务；可以通过 HTTP 的方式进行互通； 单体应用：ALL IN ONE; 微服务架构：每一个功能元素最终都是一个可独立替换和独立升级的软件单元 3、环境准备环境约束： -jdk 1.8 -maven 3.x -intellijIDEA 2019 -SpringBoot 4、SpringBoot HelloWorld功能：浏览器发送 hello 请求，服务器接收请求并处理，响应 Hello World 字符串； 1、创建一个 maven 工程（jar）2、导入 spring boot 相关的依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3、编写一个主程序；启动 Spring Boot 应用1234567891011/** *@SpringBootApplication来标注一个主程序类，说明这是一个springboot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class); &#125;&#125; 4、编写相关的 Controller、Service12345678910@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping(&quot;/hello&quot;) public String Hello()&#123; return &quot;Hello World!&quot;; &#125;&#125; 5、运行主程序测试6、简化部署123456789&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包 --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 将这个应用打成 jar 包，直接使用 java -jar 的命令进行执行 5、Hello World 探究1、POM 文件1、父项目1234567891011121314 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;/parent&gt;他的父项目 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt; &lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本； Spring Boot 的版本仲裁中心；以后我们导入依赖默认是不需要写版本；（没有在 dependencies 里面管理的依赖自然需要声明版本号） 2、导入的依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-web: ​ spring-boot-starter：spring-boot 场景启动器；帮我们导入了 web 模块正常运行所依赖的组件； Spring Boot 将所有的功能场景都抽取出来，做成一个个的 starters（启动器），只需要在项目里面引入这些 starter 相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器。 2、主程序类，主入口类12345678910/** * @SpringBootApplication 来标注一个主程序类，说明这是一个springboot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class); &#125;&#125; @SpringBootApplication：spring boot 应用，标注在某个类上，说明这个类是 SpringBoot 的主配置类，SpringBoot 就应该运行这个类的 main 方法，来启动 SpringBoot 应用； 123456789@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration：SpringBoot 的配置类； ​ 标注在某个类上，表示这是一个 SpringBoot 的配置类； ​ @Configuration：配置类上来标注这个注解； ​ 配置类—–配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； ​ 以前我们需要配置的东西，SpringBoot 帮我们自动配置；**@EnableAutoConfiguration**告诉 SpringBoot 开启自动配置功能；这样自动配置才能生效； 123@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; ​ @AutoConfigurationPackage：自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class) ​ Spring 的底层注解@Import，给容器中导入一个组件；导入的组件由 AutoConfigurationPackages.Registrar.class 告诉 将主配置类（@SpringBootApplication 标注的类）的所在包及下面所有子包里面的所有组件扫描到 Spring 容器； ​ @Import(AutoConfigurationImportSelector.class)； ​ 给容器中导入组件? ​ AutoConfigurationImportSelector：导入哪些组件的选择器； ​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； ​ 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）;就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动编写配置、注入功能组件等工作； ​ SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)； Spring Boot 在启动的时候从类路径下的 META-INF/spring.factories 中获取 EnableAutoConfiguration 指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作； 以前我们需要自己配置的东西，自动配置类都帮我们做了； J2EE 的整体整合解决方案和自动配置都在 spring-boot-autoconfigure-1.5.9.RELEASE.jar； 6、使用 Spring Initializer 快速创建 Spring Boot 项目1、IDEA：使用 Spring Initializer 快速创建项目IDE 都支持使用 Spring 的项目创建向导快速创建一个 Spring Boot 项目； 选择我们需要的模块；向导会联网创建 Spring Boot 项目； 默认生成的 Spring Boot 项目； 主程序已经生成好了，我们只需要我们自己的逻辑 resources 文件夹中目录结构 static：保存所有的静态资源； js css images； templates：保存所有的模板页面；（Spring Boot 默认 jar 包使用嵌入式的 Tomcat，默认不支持 JSP 页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot 应用的配置文件；可以修改一些默认设置； 2、STS 使用 Spring Starter Project 快速创建项目二、配置文件1、配置文件SpringBoot 使用一个全局的配置文件，配置文件名是固定的； •application.properties •application.yml 配置文件的作用：修改 SpringBoot 自动配置的默认值；SpringBoot 在底层都给我们自动配置好； YAML（YAML Ain’t Markup Language） ​ YAML A Markup Language：是一个标记语言 ​ YAML isn’t Markup Language：不是一个标记语言； 标记语言： ​ 以前的配置文件；大多都使用的是 xxxx.xml文件； ​ YAML：以数据为中心，比 json、xml 等更适合做配置文件； ​ YAML：配置例子 12server: port: 8081 ​ XML： 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 2、YAML 语法：1、基本语法k:(空格)v：表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感； 2、值的写法字面量：普通的值（数字，字符串，布尔）​ k: v：字面直接来写； ​ 字符串默认不用加上单引号或者双引号； ​ “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 ​ name: “zhangsan \\n lisi”：输出；zhangsan 换行 lisi ​ ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 ​ name: ‘zhangsan \\n lisi’：输出；zhangsan \\n lisi 对象、Map（属性和值）（键值对）：​ k: v：在下一行来写对象的属性和值的关系；注意缩进 ​ 对象还是 k: v 的方式 123friends: lastName: zhangsan age: 20 行内写法： 1friends: &#123; lastName: zhangsan, age: 18 &#125; 数组（List、Set）：用- 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat, dog, pig] 3、配置文件值注入配置文件 123456789101112person: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: &#123; k1: v1, k2: 12 &#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 12 javaBean： 123456789101112131415161718192021/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = &quot;person&quot;：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * */@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 我们可以导入配置文件处理器，以后编写配置就有提示了 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 1、properties 配置文件在 idea 中默认 utf-8 可能会乱码调整 2、@Value 获取值和@ConfigurationProperties 获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303 数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件 yml 还是 properties 他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 如果说，我们专门编写了一个 javaBean 来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 3、配置文件注入值数据校验123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = &quot;person&quot;)@Validatedpublic class Person &#123; /** * &lt;bean class=&quot;Person&quot;&gt; * &lt;property name=&quot;lastName&quot; value=&quot;字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;&quot;&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 @Email //@Value(&quot;$&#123;person.last-name&#125;&quot;) private String lastName; //@Value(&quot;#&#123;11*2&#125;&quot;) private Integer age; //@Value(&quot;true&quot;) private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 4、@PropertySource&amp;@ImportResource&amp;@Bean@PropertySource：加载指定的配置文件； 123456789101112131415161718192021222324252627282930/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = &quot;person&quot;：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = &quot;person&quot;)默认从全局配置文件中获取值； * */@PropertySource(value = &#123;&quot;classpath:person.properties&quot;&#125;)@Component@ConfigurationProperties(prefix = &quot;person&quot;)//@Validatedpublic class Person &#123; /** * &lt;bean class=&quot;Person&quot;&gt; * &lt;property name=&quot;lastName&quot; value=&quot;字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;&quot;&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 // @Email //@Value(&quot;$&#123;person.last-name&#125;&quot;) private String lastName; //@Value(&quot;#&#123;11*2&#125;&quot;) private Integer age; //@Value(&quot;true&quot;) private Boolean boss; @ImportResource：导入 Spring 的配置文件，让配置文件里面的内容生效； Spring Boot 里面没有 Spring 的配置文件，我们自己编写的配置文件，也不能自动识别； 想让 Spring 的配置文件生效，加载进来；@ImportResource标注在一个配置类上 12@ImportResource(locations = &#123;&quot;classpath:beans.xml&quot;&#125;)导入Spring的配置文件让其生效 不来编写 Spring 的配置文件 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;helloService&quot; class=&quot;com.atguigu.springboot.service.HelloService&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; SpringBoot 推荐给容器中添加组件的方式；推荐使用全注解的方式 1、配置类**@Configuration**——&gt;Spring 配置文件 2、使用**@Bean**给容器中添加组件 12345678910111213141516/** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 * */@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02()&#123; System.out.println(&quot;配置类@Bean给容器中添加组件了...&quot;); return new HelloService(); &#125;&#125; 4、配置文件占位符1、随机数123$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125; 2、占位符获取之前配置的值，如果没有可以是用:指定默认值123456789person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 5、Profile1、多 Profile 文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 默认使用 application.properties 的配置； 2、yml 支持多文档块方式1234567891011121314151617server: port: 8081spring: profiles: active: prod---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境 3、激活指定 profile​ 1、在配置文件中指定 spring.profiles.active=dev ​ 2、命令行： ​ java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev； ​ 可以直接在测试的时候，配置传入命令行参数 ​ 3、虚拟机参数； ​ -Dspring.profiles.active=dev 6、配置文件加载位置springboot 启动会扫描以下位置的 application.properties 或者 application.yml 文件作为 Spring boot 的默认配置文件 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot 会从这四个位置全部加载主配置文件；互补配置； 我们还可以通过 spring.config.location 来改变默认的配置文件位置 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置； java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –spring.config.location=G:/application.properties 7、外部配置加载顺序==SpringBoot 也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置== 【自己测试并没有互补配置】 1.命令行参数 所有的配置都可以在命令行上进行指定 java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context-path=/abc 多个配置用空格分开； –配置项=值 2.来自 java:comp/env 的 JNDI 属性 3.Java 系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource 配置的 random.*属性值 ==由 jar 包外向 jar 包内进行寻找；== ==优先加载带 profile== 6.jar 包外部的 application-{profile}.properties 或 application.yml(带 spring.profile)配置文件 7.jar 包内部的 application-{profile}.properties 或 application.yml(带 spring.profile)配置文件 ==再来加载不带 profile== 8.jar 包外部的 application.properties 或 application.yml(不带 spring.profile)配置文件 9.jar 包内部的 application.properties 或 application.yml(不带 spring.profile)配置文件 10.@Configuration 注解类上的@PropertySource 11.通过 SpringApplication.setDefaultProperties 指定的默认属性 所有支持的配置加载来源； 参考官方文档 8、自动配置原理配置文件到底能写什么？怎么写？自动配置原理； 配置文件能配置的属性参照 1、自动配置原理：1）、SpringBoot 启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration== 2）、@EnableAutoConfiguration 作用： 利用 EnableAutoConfigurationImportSelector 给容器中导入一些组件？ 可以查看 selectImports()方法的内容； List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置 ```javaSpringFactoriesLoader.loadFactoryNames()扫描所有jar包类路径下 META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102**&#x3D;&#x3D;将 类路径下 META-INF&#x2F;spring.factories 里面配置的所有 EnableAutoConfiguration 的值加入到了容器中；&#x3D;&#x3D;**&#96;&#96;&#96;properties# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 每一个这样的 xxxAutoConfiguration 类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 3）、每一个自动配置类进行自动配置功能； 4）、以HttpEncodingAutoConfiguration（Http 编码自动配置）为例解释自动配置原理； 12345678910111213141516171819202122232425262728@Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnProperty(prefix = &quot;spring.http.encoding&quot;, value = &quot;enabled&quot;, matchIfMissing = true) //判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final HttpEncodingProperties properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的 properties 类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 5）、所有在配置文件中能配置的属性都是在 xxxxProperties 类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类 1234@ConfigurationProperties(prefix = &quot;spring.http.encoding&quot;) //从配置文件中获取指定的值和bean的属性进行绑定public class HttpEncodingProperties &#123; public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF-8&quot;); 精髓： ​ 1）、SpringBoot 启动会加载大量的自动配置类 ​ 2）、我们看我们需要的功能有没有 SpringBoot 默认写好的自动配置类； ​ 3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） ​ 4）、给容器中自动配置类添加组件的时候，会从 properties 类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfigurartion：自动配置类； 给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 2、细节1、@Conditional 派生注解（Spring 注解版原生的@Conditional 作用）作用：必须是@Conditional 指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional 扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的 java 版本是否符合要求 @ConditionalOnBean 容器中存在指定 Bean； @ConditionalOnMissingBean 容器中不存在指定 Bean； @ConditionalOnExpression 满足 SpEL 表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的 Bean，或者这个 Bean 是首选 Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是 web 环境 @ConditionalOnNotWebApplication 当前不是 web 环境 @ConditionalOnJndi JNDI 存在指定项 自动配置类必须在一定的条件下才能生效； 我们怎么知道哪些自动配置类生效； **==我们可以通过启用 debug=true 属性；来让控制台打印自动配置报告==**，这样我们就可以很方便的知道哪些自动配置类生效； 123456789101112131415161718192021222324=========================AUTO-CONFIGURATION REPORT=========================Positive matches:（自动配置类启用的）----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class &#x27;org.springframework.web.servlet.DispatcherServlet&#x27;; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition)Negative matches:（没有启动，没有匹配成功的自动配置类）----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes &#x27;javax.jms.ConnectionFactory&#x27;, &#x27;org.apache.activemq.ActiveMQConnectionFactory&#x27; (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes &#x27;org.aspectj.lang.annotation.Aspect&#x27;, &#x27;org.aspectj.lang.reflect.Advice&#x27; (OnClassCondition) 三、日志1、日志框架小张；开发一个大型系统； ​ 1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？ ​ 2、框架来记录系统的一些运行时信息；日志框架 ； zhanglogging.jar； ​ 3、高大上的几个功能？异步模式？自动归档？xxxx？ zhanglogging-good.jar？ ​ 4、将以前框架卸下来？换上新的框架，重新修改之前相关的 API；zhanglogging-prefect.jar； ​ 5、JDBC—数据库驱动； ​ 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar； ​ 给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层； 市面上的日志框架； JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…. 日志门面 （日志的抽象层） 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4j JUL（java.util.logging） Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面： SLF4J； 日志实现：Logback； SpringBoot：底层是 Spring 框架，Spring 框架默认是用 JCL；‘ ​ ==SpringBoot 选用 SLF4j 和 logback；== 2、SLF4j 使用1、如何在系统中使用 SLF4j https://www.slf4j.org以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法； 给系统里面导入 slf4j 的 jar 和 logback 的实现 jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(&quot;Hello World&quot;); &#125;&#125; 图示； 每一个日志的实现框架都有自己的配置文件。使用 slf4j 以后，配置文件还是做成日志实现框架自己本身的配置文件； 2、遗留问题a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用 slf4j 进行输出？ 如何让系统中所有的日志都统一到 slf4j； ==1、将系统中其他日志框架先排除出去；== ==2、用中间包来替换原有的日志框架；== ==3、我们导入 slf4j 其他的实现== 3、SpringBoot 日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot 使用它来做日志功能； 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; 底层依赖关系 总结： ​ 1）、SpringBoot 底层也是使用 slf4j+logback 的方式进行日志记录 ​ 2）、SpringBoot 也把其他的日志都替换成了 slf4j； ​ 3）、中间替换包？ 123456@SuppressWarnings(&quot;rawtypes&quot;)public abstract class LogFactory &#123; static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = &quot;http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j&quot;; static LogFactory logFactory = new SLF4JLogFactory(); ​ 4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？ ​ Spring 框架用的是 commons-logging； 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; ==SpringBoot 能自动适配所有的日志，而且底层使用 slf4j+logback 的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；== 4、日志使用；1、默认配置SpringBoot 默认帮我们配置好了日志； 123456789101112131415161718//记录器Logger logger = LoggerFactory.getLogger(getClass());@Testpublic void contextLoads() &#123; //System.out.println(); //日志的级别； //由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace(&quot;这是trace日志...&quot;); logger.debug(&quot;这是debug日志...&quot;); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别 logger.info(&quot;这是info日志...&quot;); logger.warn(&quot;这是warn日志...&quot;); logger.error(&quot;这是error日志...&quot;);&#125; 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n SpringBoot 修改日志的默认配置 123456789101112131415logging.level.com.atguigu=trace#logging.path=# 不指定路径在当前项目下生成springboot.log日志# 可以指定完整的路径；#logging.file=G:/springboot.log# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件logging.path=/spring/log# 在控制台输出的日志的格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n# 指定文件中日志输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n logging.file logging.path Example Description (none) (none) 只在控制台输出 指定文件名 (none) my.log 输出日志到 my.log 文件 (none) 指定目录 /var/log 输出到指定目录的 spring.log 文件中 2、指定配置给类路径下放上每个日志框架自己的配置文件即可；SpringBoot 就不使用他默认配置的了 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由 SpringBoot 解析日志配置，可以使用 SpringBoot 的高级 Profile 功能 12345&lt;springProfile name=&quot;staging&quot;&gt; &lt;!-- configuration to be enabled when the &quot;staging&quot; profile is active --&gt; 可以指定某段配置只在某个环境下生效&lt;/springProfile&gt; 如： 12345678910111213141516171819&lt;appender name=&quot;stdout&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt; &lt;springProfile name=&quot;dev&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=&quot;!dev&quot;&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; &lt;/appender&gt; 如果使用 logback.xml 作为日志配置文件，还要使用 profile 功能，会有以下错误 no applicable action for [springProfile] 5、切换日志框架可以按照 slf4j 的日志适配图，进行相关的切换； slf4j+log4j 的方式； 1234567891011121314151617181920&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 切换为 log4j2 123456789101112131415 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; 四、Web 开发1、简介使用 SpringBoot； 1）、创建 SpringBoot 应用，选中我们需要的模块； 2）、SpringBoot 已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 3）、自己编写业务代码； 自动配置原理？ 这个场景 SpringBoot 帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx 123xxxxAutoConfiguration：帮我们给容器中自动配置组件；xxxxProperties:配置类来封装配置文件的内容； 2、SpringBoot 对静态资源的映射规则；123@ConfigurationProperties(prefix = &quot;spring.resources&quot;, ignoreUnknownFields = false)public class ResourceProperties implements ResourceLoaderAware &#123; //可以设置和静态资源有关的参数，缓存时间等 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465WebMvcAuotConfiguration： @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(&quot;Default resource handling disabled&quot;); return; &#125; Integer cachePeriod = this.resourceProperties.getCachePeriod(); if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(&quot;/webjars/**&quot;) .addResourceLocations( &quot;classpath:/META-INF/resources/webjars/&quot;) .setCachePeriod(cachePeriod)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); //静态资源文件夹映射 if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(staticPathPattern) .addResourceLocations( this.resourceProperties.getStaticLocations()) .setCachePeriod(cachePeriod)); &#125; &#125; //配置欢迎页映射 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping( ResourceProperties resourceProperties) &#123; return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); &#125; //配置喜欢的图标 @Configuration @ConditionalOnProperty(value = &quot;spring.mvc.favicon.enabled&quot;, matchIfMissing = true) public static class FaviconConfiguration &#123; private final ResourceProperties resourceProperties; public FaviconConfiguration(ResourceProperties resourceProperties) &#123; this.resourceProperties = resourceProperties; &#125; @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() &#123; SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); //所有 **/favicon.ico mapping.setUrlMap(Collections.singletonMap(&quot;**/favicon.ico&quot;, faviconRequestHandler())); return mapping; &#125; @Bean public ResourceHttpRequestHandler faviconRequestHandler() &#123; ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler .setLocations(this.resourceProperties.getFaviconLocations()); return requestHandler; &#125; &#125; ==1）、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；== ​ webjars：以 jar 包的方式引入静态资源； http://www.webjars.org/ localhost:8080/webjars/jquery/3.3.1/jquery.js 123456&lt;!--引入jquery-webjar--&gt;在访问的时候只需要写webjars下面资源的名称即可 &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; ==2）、”/**“ 访问当前项目的任何资源，都去（静态资源的文件夹）找映射== 12345&quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;&quot;,&quot;classpath:&#x2F;resources&#x2F;&quot;,&quot;classpath:&#x2F;static&#x2F;&quot;,&quot;classpath:&#x2F;public&#x2F;&quot;&quot;&#x2F;&quot;：当前项目的根路径 localhost:8080/abc === 去静态资源文件夹里面找 abc ==3）、欢迎页； 静态资源文件夹下的所有 index.html 页面；被”/**“映射；== ​ localhost:8080/ 找 index 页面 ==4）、所有的 **/favicon.ico 都是在静态资源文件下找；== 3、模板引擎JSP、Velocity、Freemarker、Thymeleaf SpringBoot 推荐的 Thymeleaf； 语法更简单，功能更强大； 1、引入 thymeleaf；123456789101112 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; 2.1.6 &lt;/dependency&gt;切换thymeleaf版本&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; 2、Thymeleaf 使用1234567891011@ConfigurationProperties(prefix = &quot;spring.thymeleaf&quot;)public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = Charset.forName(&quot;UTF-8&quot;); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(&quot;text/html&quot;); public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;; public static final String DEFAULT_SUFFIX = &quot;.html&quot;; // 只要我们把 HTML 页面放在 classpath:/templates/，thymeleaf 就能自动渲染； 使用： 1、导入 thymeleaf 的名称空间 1&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; 2、使用 thymeleaf 语法； 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为 --&gt; &lt;div th:text=&quot;$&#123;hello&#125;&quot;&gt;这是显示欢迎信息&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 3、语法规则1）、th:text；改变当前元素里面的文本内容； ​ th：任意 html 属性；来替换原生属性的值 2）、表达式？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Simple expressions:（表达式语法） Variable Expressions: $&#123;...&#125;：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. $&#123;session.foo&#125; 3）、内置的一些工具对象：#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样； 补充：配合 th:object=&quot;$&#123;session.user&#125;： &lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt; &lt;p&gt;Name: &lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; Message Expressions: #&#123;...&#125;：获取国际化内容 Link URL Expressions: @&#123;...&#125;：定义URL； @&#123;/order/process(execId=$&#123;execId&#125;,execType=&#x27;FAST&#x27;)&#125; Fragment Expressions: ~&#123;...&#125;：片段引用表达式 &lt;div th:insert=&quot;~&#123;commons :: main&#125;&quot;&gt;...&lt;/div&gt;Literals（字面量） Text literals: &#x27;one text&#x27; , &#x27;Another one!&#x27; ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): -Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No-Operation: _ 4、SpringMVC 自动配置https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications 1. Spring MVC auto-configurationSpring Boot 自动配置好了 SpringMVC 以下是 SpringBoot 对 SpringMVC 的默认配置:==（WebMvcAutoConfiguration）== Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了 ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？）） ContentNegotiatingViewResolver：组合所有的视图解析器的； ==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；== Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars Static index.html support. 静态首页访问 Custom Favicon support (see below). favicon.ico 自动注册了 of Converter, GenericConverter, Formatter beans. Converter：转换器； public String hello(User user)：类型转换使用 Converter Formatter 格式化器； 2017.12.17===Date； 12345@Bean@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;date-format&quot;)//在文件中配置日期格式化的规则public Formatter&lt;Date&gt; dateFormatter() &#123; return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件&#125; ​ ==自己添加的格式化器转换器，我们只需要放在容器中即可== Support for HttpMessageConverters (see below). HttpMessageConverter：SpringMVC 用来转换 Http 请求和响应的；User—Json； HttpMessageConverters 是从容器中确定；获取所有的 HttpMessageConverter； ==自己给容器中添加 HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）== Automatic registration of MessageCodesResolver (see below).定义错误代码生成规则 Automatic use of a ConfigurableWebBindingInitializer bean (see below). ==我们可以配置一个 ConfigurableWebBindingInitializer 来替换默认的；（添加到容器）== 12初始化WebDataBinder；请求数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;JavaBean； org.springframework.boot.autoconfigure.web：web 的所有自动场景； If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 2、扩展 SpringMVC1234567&lt;mvc:view-controller path=&quot;/hello&quot; view-name=&quot;success&quot;/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/hello&quot;/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; ==编写一个配置类（@Configuration），是 WebMvcConfigurerAdapter 类型；不能标注@EnableWebMvc==; 既保留了所有的自动配置，也能用我们扩展的配置； 1234567891011//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(&quot;/atguigu&quot;).setViewName(&quot;success&quot;); &#125;&#125; 原理： ​ 1）、WebMvcAutoConfiguration 是 SpringMVC 的自动配置类 ​ 2）、在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class) 123456789101112131415161718 @Configurationpublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration &#123; private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); //从容器中获取所有的WebMvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用； @Override // public void addViewControllers(ViewControllerRegistry registry) &#123; // for (WebMvcConfigurer delegate : this.delegates) &#123; // delegate.addViewControllers(registry); // &#125; &#125; &#125;&#125; ​ 3）、容器中所有的 WebMvcConfigurer 都会一起起作用； ​ 4）、我们的配置类也会被调用； ​ 效果：SpringMVC 的自动配置和我们的扩展配置都会起作用； 3、全面接管 SpringMVC；SpringBoot 对 SpringMVC 的自动配置不需要了，所有都是我们自己配置；所有的 SpringMVC 的自动配置都失效了 我们需要在配置类中添加@EnableWebMvc 即可； 123456789101112//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@EnableWebMvc@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(&quot;/atguigu&quot;).setViewName(&quot;success&quot;); &#125;&#125; 原理： 为什么@EnableWebMvc 自动配置就失效了； 1）@EnableWebMvc 的核心 12@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc &#123; 2）、 12@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; 3）、 12345678910@Configuration@ConditionalOnWebApplication@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class &#125;)//容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123; 4）、@EnableWebMvc 将 WebMvcConfigurationSupport 组件导入进来； 5）、导入的 WebMvcConfigurationSupport 只是 SpringMVC 最基本的功能； 5、如何修改 SpringBoot 的默认配置模式： ​ 1）、SpringBoot 在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来； ​ 2）、在 SpringBoot 中会有非常多的 xxxConfigurer 帮助我们进行扩展配置 ​ 3）、在 SpringBoot 中会有很多的 xxxCustomizer 帮助我们进行定制配置 6、RestfulCRUD1）、默认访问首页1234567891011121314151617181920212223242526//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能//@EnableWebMvc 不要接管SpringMVC@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(&quot;/atguigu&quot;).setViewName(&quot;success&quot;); &#125; //所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;); registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;login&quot;); &#125; &#125;; return adapter; &#125;&#125; 2）、国际化1）、编写国际化配置文件； 2）、使用 ResourceBundleMessageSource 管理国际化资源文件 3）、在页面使用 fmt:message 取出国际化内容 步骤： 1）、编写国际化配置文件，抽取页面需要显示的国际化消息 2）、SpringBoot 自动配置好了管理国际化资源文件的组件； 12345678910111213141516171819202122232425262728@ConfigurationProperties(prefix = &quot;spring.messages&quot;)public class MessageSourceAutoConfiguration &#123; /** * Comma-separated list of basenames (essentially a fully-qualified classpath * location), each following the ResourceBundle convention with relaxed support for * slash based locations. If it doesn&#x27;t contain a package qualifier (such as * &quot;org.mypackage&quot;), it will be resolved from the classpath root. */ private String basename = &quot;messages&quot;; //我们的配置文件可以直接放在类路径下叫messages.properties； @Bean public MessageSource messageSource() &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(this.basename)) &#123; //设置国际化资源文件的基础名（去掉语言国家代码的） messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(this.basename))); &#125; if (this.encoding != null) &#123; messageSource.setDefaultEncoding(this.encoding.name()); &#125; messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale); messageSource.setCacheSeconds(this.cacheSeconds); messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat); return messageSource; &#125; 3）、去页面获取国际化的值； 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot; /&gt; &lt;meta name=&quot;description&quot; content=&quot;&quot; /&gt; &lt;meta name=&quot;author&quot; content=&quot;&quot; /&gt; &lt;title&gt;Signin Template for Bootstrap&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href=&quot;asserts/css/bootstrap.min.css&quot; th:href=&quot;@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;&quot; rel=&quot;stylesheet&quot; /&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href=&quot;asserts/css/signin.css&quot; th:href=&quot;@&#123;/asserts/css/signin.css&#125;&quot; rel=&quot;stylesheet&quot; /&gt; &lt;/head&gt; &lt;body class=&quot;text-center&quot;&gt; &lt;form class=&quot;form-signin&quot; action=&quot;dashboard.html&quot;&gt; &lt;img class=&quot;mb-4&quot; th:src=&quot;@&#123;/asserts/img/bootstrap-solid.svg&#125;&quot; src=&quot;asserts/img/bootstrap-solid.svg&quot; alt=&quot;&quot; width=&quot;72&quot; height=&quot;72&quot; /&gt; &lt;h1 class=&quot;h3 mb-3 font-weight-normal&quot; th:text=&quot;#&#123;login.tip&#125;&quot;&gt;Please sign in&lt;/h1&gt; &lt;label class=&quot;sr-only&quot; th:text=&quot;#&#123;login.username&#125;&quot;&gt;Username&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Username&quot; th:placeholder=&quot;#&#123;login.username&#125;&quot; required=&quot;&quot; autofocus=&quot;&quot; /&gt; &lt;label class=&quot;sr-only&quot; th:text=&quot;#&#123;login.password&#125;&quot;&gt;Password&lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; th:placeholder=&quot;#&#123;login.password&#125;&quot; required=&quot;&quot; /&gt; &lt;div class=&quot;checkbox mb-3&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; value=&quot;remember-me&quot; /&gt; [[#&#123;login.remember&#125;]] &lt;/label&gt; &lt;/div&gt; &lt;button class=&quot;btn btn-lg btn-primary btn-block&quot; type=&quot;submit&quot; th:text=&quot;#&#123;login.btn&#125;&quot;&gt;Sign in&lt;/button&gt; &lt;p class=&quot;mt-5 mb-3 text-muted&quot;&gt;© 2017-2018&lt;/p&gt; &lt;a class=&quot;btn btn-sm&quot;&gt;中文&lt;/a&gt; &lt;a class=&quot;btn btn-sm&quot;&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 效果：根据浏览器语言设置的信息切换了国际化； 原理： ​ 国际化 Locale（区域信息对象）；LocaleResolver（获取区域信息对象）； 12345678910111213 @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;locale&quot;) public LocaleResolver localeResolver() &#123; if (this.mvcProperties .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; &#125;默认的就是根据请求头带来的区域信息获取Locale进行国际化 4）、点击链接切换国际化 123456789101112131415161718192021222324252627282930/** * 可以在连接上携带区域信息 */public class MyLocaleResolver implements LocaleResolver &#123; @Override public Locale resolveLocale(HttpServletRequest request) &#123; String l = request.getParameter(&quot;l&quot;); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(l))&#123; String[] split = l.split(&quot;_&quot;); locale = new Locale(split[0],split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123; &#125;&#125; @Bean public LocaleResolver localeResolver()&#123; return new MyLocaleResolver(); &#125;&#125; 3）、登陆开发期间模板引擎页面修改以后，要实时生效 1）、禁用模板引擎的缓存 12# 禁用缓存spring.thymeleaf.cache&#x3D;false 2）、页面修改完成以后 ctrl+f9：重新编译； 登陆错误消息的显示 1&lt;p style=&quot;color: red&quot; th:text=&quot;$&#123;msg&#125;&quot; th:if=&quot;$&#123;not #strings.isEmpty(msg)&#125;&quot;&gt;&lt;/p&gt; 4）、拦截器进行登陆检查拦截器 12345678910111213141516171819202122232425262728293031/** * 登陆检查， */public class LoginHandlerInterceptor implements HandlerInterceptor &#123; //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object user = request.getSession().getAttribute(&quot;loginUser&quot;); if(user == null)&#123; //未登陆，返回登陆页面 request.setAttribute(&quot;msg&quot;,&quot;没有权限请先登陆&quot;); request.getRequestDispatcher(&quot;/index.html&quot;).forward(request,response); return false; &#125;else&#123; //已登陆，放行请求 return true; &#125; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 注册拦截器 1234567891011121314151617181920212223//所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;); registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;login&quot;); registry.addViewController(&quot;/main.html&quot;).setViewName(&quot;dashboard&quot;); &#125; //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; //super.addInterceptors(registry); //静态资源； *.css , *.js //SpringBoot 2.x 没有静态资源映射 registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(&quot;/**&quot;) .excludePathPatterns(&quot;/index.html&quot;,&quot;/&quot;,&quot;/user/login&quot;,&quot;/webjars/**&quot;,&quot;/asserts/css/**&quot;,&quot;/asserts/js/**&quot;,&quot;/asserts/img/**&quot;); &#125; &#125;; return adapter; &#125; 5）、CRUD-员工列表实验要求： 1）、RestfulCRUD：CRUD 满足 Rest 风格； URI： /资源名称/资源标识 HTTP 请求方式区分对资源 CRUD 操作 普通 CRUD（uri 来区分操作） RestfulCRUD 查询 getEmp emp—GET 添加 addEmp?xxx emp—POST 修改 updateEmp?id=xxx&amp;xxx=xx emp/{id}—PUT 删除 deleteEmp?id=1 emp/{id}—DELETE 2）、实验的请求架构; 实验功能 请求 URI 请求方式 查询所有员工 emps GET 查询某个员工(来到修改页面) emp/1 GET 来到添加页面 emp GET 添加员工 emp POST 来到修改页面（查出员工进行信息回显） emp/1 GET 修改员工 emp PUT 删除员工 emp/1 DELETE 3）、员工列表： thymeleaf 公共页面元素抽取12345671、抽取公共片段&lt;div th:fragment=&quot;copy&quot;&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;2、引入公共片段&lt;div th:insert=&quot;~&#123;footer :: copy&#125;&quot;&gt;&lt;/div&gt;~&#123;templatename::selector&#125;：模板名::选择器 ~&#123;templatename::fragmentname&#125;:模板名::片段名 3、默认效果： insert的公共片段在div标签中 如果使用th:insert等属性进行引入，可以不用写~&#123;&#125;：行内写法可以加上：[[~&#123;&#125;]];[(~&#123;&#125;)]； 三种引入公共片段的 th 属性： th:insert：将公共片段整个插入到声明引入的元素中 th:replace：将声明引入的元素替换为公共片段 th:include：将被引入的片段的内容包含进这个标签中 123456789101112131415&lt;footer th:fragment=&quot;copy&quot;&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;引入方式&lt;div th:insert=&quot;footer :: copy&quot;&gt;&lt;/div&gt;&lt;div th:replace=&quot;footer :: copy&quot;&gt;&lt;/div&gt;&lt;div th:include=&quot;footer :: copy&quot;&gt;&lt;/div&gt;效果&lt;div&gt; &lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;/div&gt;&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 引入片段的时候传入参数： 1234567891011121314151617181920212223242526272829&lt;nav class=&quot;col-md-2 d-none d-md-block bg-light sidebar&quot; id=&quot;sidebar&quot;&gt; &lt;div class=&quot;sidebar-sticky&quot;&gt; &lt;ul class=&quot;nav flex-column&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link active&quot; th:class=&quot;$&#123;activeUri==&#x27;main.html&#x27;?&#x27;nav-link active&#x27;:&#x27;nav-link&#x27;&#125;&quot; href=&quot;#&quot; th:href=&quot;@&#123;/main.html&#125;&quot;&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;feather feather-home&quot; &gt; &lt;path d=&quot;M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z&quot;&gt;&lt;/path&gt; &lt;polyline points=&quot;9 22 9 12 15 12 15 22&quot;&gt;&lt;/polyline&gt; &lt;/svg&gt; Dashboard &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;!--引入侧边栏;传入参数--&gt; &lt;div th:replace=&quot;commons/bar::#sidebar(activeUri=&#x27;emps&#x27;)&quot;&gt;&lt;/div&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/nav&gt; 6）、CRUD-员工添加添加页面 123456789101112131415161718192021222324252627282930313233343536&lt;form&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input type=&quot;email&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan@atguigu.com&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br /&gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; /&gt; &lt;label class=&quot;form-check-label&quot;&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; /&gt; &lt;label class=&quot;form-check-label&quot;&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;department&lt;/label&gt; &lt;select class=&quot;form-control&quot;&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot; /&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;添加&lt;/button&gt;&lt;/form&gt; 提交的数据格式不对：生日：日期； 2017-12-12；2017/12/12；2017.12.12； 日期的格式化；SpringMVC 将页面提交的值需要转换为指定的类型; 2017-12-12—Date； 类型转换，格式化; 默认日期是按照/的方式； 7）、CRUD-员工修改修改添加二合一表单 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--需要区分是员工修改还是添加；--&gt;&lt;form th:action=&quot;@&#123;/emp&#125;&quot; method=&quot;post&quot;&gt; &lt;!--发送put请求修改员工数据--&gt; &lt;!--1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）2、页面创建一个post表单3、创建一个input项，name=&quot;_method&quot;;值就是我们指定的请求方式--&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot; th:if=&quot;$&#123;emp!=null&#125;&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; th:if=&quot;$&#123;emp!=null&#125;&quot; th:value=&quot;$&#123;emp.id&#125;&quot; /&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name=&quot;lastName&quot; type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot; th:value=&quot;$&#123;emp!=null&#125;?$&#123;emp.lastName&#125;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name=&quot;email&quot; type=&quot;email&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan@atguigu.com&quot; th:value=&quot;$&#123;emp!=null&#125;?$&#123;emp.email&#125;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br /&gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; th:checked=&quot;$&#123;emp!=null&#125;?$&#123;emp.gender==1&#125;&quot; /&gt; &lt;label class=&quot;form-check-label&quot;&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; th:checked=&quot;$&#123;emp!=null&#125;?$&#123;emp.gender==0&#125;&quot; /&gt; &lt;label class=&quot;form-check-label&quot;&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;department&lt;/label&gt; &lt;!--提交的是部门的id--&gt; &lt;select class=&quot;form-control&quot; name=&quot;department.id&quot;&gt; &lt;option th:selected=&quot;$&#123;emp!=null&#125;?$&#123;dept.id == emp.department.id&#125;&quot; th:value=&quot;$&#123;dept.id&#125;&quot; th:each=&quot;dept:$&#123;depts&#125;&quot; th:text=&quot;$&#123;dept.departmentName&#125;&quot;&gt;1&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input name=&quot;birth&quot; type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot; th:value=&quot;$&#123;emp!=null&#125;?$&#123;#dates.format(emp.birth, &#x27;yyyy-MM-dd HH:mm&#x27;)&#125;&quot; /&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot; th:text=&quot;$&#123;emp!=null&#125;?&#x27;修改&#x27;:&#x27;添加&#x27;&quot;&gt;添加&lt;/button&gt;&lt;/form&gt; 8）、CRUD-员工删除123456789101112131415161718192021&lt;tr th:each=&quot;emp:$&#123;emps&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;emp.id&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt;[[$&#123;emp.lastName&#125;]]&lt;/td&gt; &lt;td th:text=&quot;$&#123;emp.email&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;emp.gender&#125;==0?&#x27;女&#x27;:&#x27;男&#x27;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;emp.department.departmentName&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;#dates.format(emp.birth, &#x27;yyyy-MM-dd HH:mm&#x27;)&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;a class=&quot;btn btn-sm btn-primary&quot; th:href=&quot;@&#123;/emp/&#125;+$&#123;emp.id&#125;&quot;&gt;编辑&lt;/a&gt; &lt;button th:attr=&quot;del_uri=@&#123;/emp/&#125;+$&#123;emp.id&#125;&quot; class=&quot;btn btn-sm btn-danger deleteBtn&quot;&gt;删除&lt;/button&gt; &lt;/td&gt;&lt;/tr&gt;&lt;script&gt; $(&#x27;.deleteBtn&#x27;).click(function () &#123; //删除当前员工的 $(&#x27;#deleteEmpForm&#x27;).attr(&#x27;action&#x27;, $(this).attr(&#x27;del_uri&#x27;)).submit(); return false; &#125;);&lt;/script&gt;最新版本的spring boot 默认不开启 restful 分割api 123456会报错：Resolved [org.springframework.web.HttpRequestMethodNotSupportedException: Request method &#39;DELETE&#39; not supported]原因：最新版本的spring boot 默认不开启 restful 分割api开启办法:# 启用hiddenMethod过滤器spring.mvc.hiddenmethod.filter.enabled&#x3D;true 7、错误处理机制1）、SpringBoot 默认的错误处理机制默认效果： ​ 1）、浏览器，返回一个默认的错误页面 浏览器发送请求的请求头： ​ 2）、如果是其他客户端，默认响应一个 json 数据 ​ 原理： ​ 可以参照 ErrorMvcAutoConfiguration；错误处理的自动配置； 给容器中添加了以下组件 ​ 1、DefaultErrorAttributes： 1234567891011帮我们在页面共享信息；@Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;(); errorAttributes.put(&quot;timestamp&quot;, new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes; &#125; ​ 2、BasicErrorController：处理默认/error 请求 12345678910111213141516171819202122232425@Controller@RequestMapping(&quot;$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;&quot;)public class BasicErrorController extends AbstractErrorController &#123; @RequestMapping(produces = &quot;text/html&quot;)//产生html类型的数据；浏览器发送的请求来到这个方法处理 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView(&quot;error&quot;, model) : modelAndView); &#125; @RequestMapping @ResponseBody //产生json数据，其他客户端来到这个方法处理； public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); &#125; ​ 3、ErrorPageCustomizer： 12@Value(&quot;$&#123;error.path:/error&#125;&quot;)private String path = &quot;/error&quot;; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则） ​ 4、DefaultErrorViewResolver： 123456789101112131415161718192021222324@Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView; &#125; private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; //默认SpringBoot可以去找到一个页面？ error/404 String errorViewName = &quot;error/&quot; + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); &#125; //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model); &#125; ​ 步骤： ​ 一但系统出现 4xx 或者 5xx 之类的错误；ErrorPageCustomizer 就会生效（定制错误的响应规则）；就会来到/error 请求；就会被BasicErrorController处理； ​ 1）响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的； 1234567891011protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) &#123; //所有的ErrorViewResolver得到ModelAndView for (ErrorViewResolver resolver : this.errorViewResolvers) &#123; ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) &#123; return modelAndView; &#125; &#125; return null;&#125; 2）、如果定制错误响应：1）、如何定制错误的页面；​ 1）、有模板引擎的情况下；error/状态码; 【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的 error 文件夹下】，发生此状态码的错误就会来到 对应的页面； ​ 我们可以使用 4xx 和 5xx 作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）； ​ 页面能获取的信息； ​ timestamp：时间戳 ​ status：状态码 ​ error：错误提示 ​ exception：异常对象 ​ message：异常消息 ​ errors：JSR303 数据校验的错误都在这里 ​ 2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找； ​ 3）、以上都没有错误页面，就是默认来到 SpringBoot 默认的错误提示页面； 2）、如何定制错误的 json 数据；​ 1）、自定义异常处理&amp;返回定制 json 数据； 12345678910111213@ControllerAdvicepublic class MyExceptionHandler &#123; @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String,Object&gt; handleException(Exception e)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;code&quot;,&quot;user.notexist&quot;); map.put(&quot;message&quot;,e.getMessage()); return map; &#125;&#125;//没有自适应效果... ​ 2）、转发到/error 进行自适应响应效果处理 1234567891011121314@ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 /** * Integer statusCode = (Integer) request .getAttribute(&quot;javax.servlet.error.status_code&quot;); */ request.setAttribute(&quot;javax.servlet.error.status_code&quot;,500); map.put(&quot;code&quot;,&quot;user.notexist&quot;); map.put(&quot;message&quot;,e.getMessage()); //转发到/error return &quot;forward:/error&quot;; &#125; 3）、将我们的定制数据携带出去；出现错误以后，会来到/error 请求，会被 BasicErrorController 处理，响应出去可以获取的数据是由 getErrorAttributes 得到的（是 AbstractErrorController（ErrorController）规定的方法）； ​ 1、完全来编写一个 ErrorController 的实现类【或者是编写 AbstractErrorController 的子类】，放在容器中； ​ 2、页面上能用的数据，或者是 json 返回能用的数据都是通过 errorAttributes.getErrorAttributes 得到； ​ 容器中 DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的； 自定义 ErrorAttributes 1234567891011//给容器中加入我们自己定义的ErrorAttributes@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace); map.put(&quot;company&quot;,&quot;atguigu&quot;); return map; &#125;&#125; 最终的效果：响应是自适应的，可以通过定制 ErrorAttributes 改变需要返回的内容， 8、配置嵌入式 Servlet 容器SpringBoot 默认使用 Tomcat 作为嵌入式的 Servlet 容器； 问题？ 1）、如何定制和修改 Servlet 容器的相关配置；1、修改和 server 有关的配置 123456789server.port=8081server.context-path=/crudserver.tomcat.uri-encoding=UTF-8//通用的Servlet容器设置server.xxx//Tomcat的设置server.tomcat.xxx 2、编写一个WebServerFactoryCustomizer：嵌入式的 Servlet 容器的定制器；来修改 Servlet 容器的配置 1234567891011@Bean public WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt; webServerFactoryCustomizer()&#123; return new WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt;() &#123; // 定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableWebServerFactory factory) &#123; factory.setPort(8081); &#125; &#125;; &#125; 2）、注册 Servlet 三大组件【Servlet、Filter、Listener】由于 SpringBoot 默认是以 jar 包的方式启动嵌入式的 Servlet 容器来启动 SpringBoot 的 web 应用，没有 web.xml 文件。 注册三大组件用以下方式 ServletRegistrationBean 1234567//注册三大组件@Beanpublic ServletRegistrationBean myServlet()&#123; ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),&quot;/myServlet&quot;); return registrationBean;&#125; FilterRegistrationBean 1234567@Beanpublic FilterRegistrationBean myFilter()&#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList(&quot;/hello&quot;,&quot;/myServlet&quot;)); return registrationBean;&#125; ServletListenerRegistrationBean 12345@Beanpublic ServletListenerRegistrationBean myListener()&#123; ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener()); return registrationBean;&#125; SpringBoot 帮我们自动 SpringMVC 的时候，自动的注册 SpringMVC 的前端控制器；DIspatcherServlet； DispatcherServletAutoConfiguration 中： 123456789101112131415161718@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)public ServletRegistrationBean dispatcherServletRegistration( DispatcherServlet dispatcherServlet) &#123; ServletRegistrationBean registration = new ServletRegistrationBean( dispatcherServlet, this.serverProperties.getServletMapping()); //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径 registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); registration.setLoadOnStartup( this.webMvcProperties.getServlet().getLoadOnStartup()); if (this.multipartConfig != null) &#123; registration.setMultipartConfig(this.multipartConfig); &#125; return registration;&#125; 2）、SpringBoot 能不能支持其他的 Servlet 容器； 3）、替换为其他嵌入式 Servlet 容器 默认支持： Tomcat（默认使用） 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; 引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；&lt;/dependency&gt; Jetty 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; Undertow 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; 4）、嵌入式 Servlet 容器自动配置原理；EmbeddedServletContainerAutoConfiguration：嵌入式的 Servlet 容器自动配置？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Configuration@ConditionalOnWebApplication@Import(BeanPostProcessorsRegistrar.class)//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：//后置处理器：bean初始化前后（创建完对象，还没属性赋值）执行初始化工作public class EmbeddedServletContainerAutoConfiguration &#123; @Configuration @ConditionalOnClass(&#123; Servlet.class, Tomcat.class &#125;)//判断当前是否引入了Tomcat依赖； @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器 public static class EmbeddedTomcat &#123; @Bean public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() &#123; return new TomcatEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Jetty is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Server.class, Loader.class, WebAppContext.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedJetty &#123; @Bean public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() &#123; return new JettyEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Undertow is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedUndertow &#123; @Bean public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() &#123; return new UndertowEmbeddedServletContainerFactory(); &#125; &#125; 1）、EmbeddedServletContainerFactory（嵌入式 Servlet 容器工厂） 1234567public interface EmbeddedServletContainerFactory &#123; //获取嵌入式的Servlet容器 EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers);&#125; 2）、EmbeddedServletContainer：（嵌入式的 Servlet 容器） 3）、以TomcatEmbeddedServletContainerFactory为例 123456789101112131415161718192021222324@Overridepublic EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers) &#123; //创建一个Tomcat Tomcat tomcat = new Tomcat(); //配置Tomcat的基本环节 File baseDir = (this.baseDirectory != null ? this.baseDirectory : createTempDir(&quot;tomcat&quot;)); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) &#123; tomcat.getService().addConnector(additionalConnector); &#125; prepareContext(tomcat.getHost(), initializers); //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器 return getTomcatEmbeddedServletContainer(tomcat);&#125; 4）、我们对嵌入式容器的配置修改是怎么生效？ 1ServerProperties、EmbeddedServletContainerCustomizer EmbeddedServletContainerCustomizer：定制器帮我们修改了 Servlet 容器的配置？ 怎么修改的原理？ 5）、容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor 12345678910111213141516171819202122232425262728293031323334353637//初始化之前@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件 if (bean instanceof ConfigurableEmbeddedServletContainer) &#123; // postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean); &#125; return bean;&#125;private void postProcessBeforeInitialization( ConfigurableEmbeddedServletContainer bean) &#123; //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值； for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123; customizer.customize(bean); &#125;&#125;private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() &#123; if (this.customizers == null) &#123; // Look up does not include the parent context this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;( this.beanFactory //从容器中获取所有这个类型的组件：EmbeddedServletContainerCustomizer //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件 .getBeansOfType(EmbeddedServletContainerCustomizer.class, false, false) .values()); Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); &#125; return this.customizers;&#125;ServerProperties也是定制器 步骤： 1）、SpringBoot 根据导入的依赖情况，给容器中添加相应的 EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】 2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor； 只要是嵌入式的 Servlet 容器工厂，后置处理器就工作； 3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法 ###5）、嵌入式 Servlet 容器启动原理； 什么时候创建嵌入式的 Servlet 容器工厂？什么时候获取嵌入式的 Servlet 容器并启动 Tomcat； 获取嵌入式的 Servlet 容器工厂： 1）、SpringBoot 应用启动运行 run 方法 2）、refreshContext(context);SpringBoot 刷新 IOC 容器【创建 IOC 容器对象，并初始化容器，创建容器中的每一个组件】；如果是 web 应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：AnnotationConfigApplicationContext 3）、refresh(context);刷新刚才创建好的 ioc 容器； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(&quot;Exception encountered during context initialization - &quot; + &quot;cancelling refresh attempt: &quot; + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset &#x27;active&#x27; flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring&#x27;s core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 4）、 onRefresh(); web 的 ioc 容器重写了 onRefresh 方法 5）、webioc 容器会创建嵌入式的 Servlet 容器；createEmbeddedServletContainer(); 6）、获取嵌入式的 Servlet 容器工厂： EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory(); ​ 从 ioc 容器中获取 EmbeddedServletContainerFactory 组件；TomcatEmbeddedServletContainerFactory创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制 Servlet 容器的相关配置； 7）、使用容器工厂获取嵌入式的 Servlet 容器：this.embeddedServletContainer = containerFactory .getEmbeddedServletContainer(getSelfInitializer()); 8）、嵌入式的 Servlet 容器创建对象并启动 Servlet 容器； 先启动嵌入式的 Servlet 容器，再将 ioc 容器中剩下没有创建出的对象获取出来； ==IOC 容器启动创建嵌入式的 Servlet 容器== 9、使用外置的 Servlet 容器嵌入式 Servlet 容器：应用打成可执行的 jar ​ 优点：简单、便携； ​ 缺点：默认不支持 JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义 EmbeddedServletContainerCustomizer】，自己编写嵌入式 Servlet 容器的创建工厂【EmbeddedServletContainerFactory】）； 外置的 Servlet 容器：外面安装 Tomcat—应用 war 包的方式打包； 步骤1）、必须创建一个 war 项目；（利用 idea 创建好目录结构） 2）、将嵌入式的 Tomcat 指定为 provided； 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 3）、必须编写一个SpringBootServletInitializer的子类，并调用 configure 方法 123456789public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; //传入SpringBoot应用的主程序 return application.sources(SpringBoot04WebJspApplication.class); &#125;&#125; 4）、启动服务器就可以使用； 原理jar 包：执行 SpringBoot 主类的 main 方法，启动 ioc 容器，创建嵌入式的 Servlet 容器； war 包：启动服务器，服务器启动 SpringBoot 应用【SpringBootServletInitializer】，启动 ioc 容器； servlet3.0（Spring 注解版）： 8.2.4 Shared libraries / runtimes pluggability： 规则： ​ 1）、服务器启动（web 应用启动）会创建当前 web 应用里面每一个 jar 包里面 ServletContainerInitializer 实例： ​ 2）、ServletContainerInitializer 的实现放在 jar 包的 META-INF/services 文件夹下，有一个名为 javax.servlet.ServletContainerInitializer 的文件，内容就是 ServletContainerInitializer 的实现类的全类名 ​ 3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类； 流程： 1）、启动 Tomcat 2）、org\\springframework\\spring-web\\4.3.14.RELEASE\\spring-web-4.3.14.RELEASE.jar!\\META-INF\\services\\javax.servlet.ServletContainerInitializer： Spring 的 web 模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer 3）、SpringServletContainerInitializer 将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到 onStartup 方法的 Set&lt;Class&lt;?&gt;&gt;；为这些 WebApplicationInitializer 类型的类创建实例； 4）、每一个 WebApplicationInitializer 都调用自己的 onStartup； 5）、相当于我们的 SpringBootServletInitializer 的类会被创建对象，并执行 onStartup 方法 6）、SpringBootServletInitializer 实例执行 onStartup 的时候会 createRootApplicationContext；创建容器 1234567891011121314151617181920212223242526272829303132333435363738protected WebApplicationContext createRootApplicationContext( ServletContext servletContext) &#123; //1、创建SpringApplicationBuilder SpringApplicationBuilder builder = createSpringApplicationBuilder(); StandardServletEnvironment environment = new StandardServletEnvironment(); environment.initPropertySources(servletContext, null); builder.environment(environment); builder.main(getClass()); ApplicationContext parent = getExistingRootWebApplicationContext(servletContext); if (parent != null) &#123; this.logger.info(&quot;Root context already created (using as parent).&quot;); servletContext.setAttribute( WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null); builder.initializers(new ParentContextApplicationContextInitializer(parent)); &#125; builder.initializers( new ServletContextApplicationContextInitializer(servletContext)); builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class); //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来 builder = configure(builder); //使用builder创建一个Spring应用 SpringApplication application = builder.build(); if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils .findAnnotation(getClass(), Configuration.class) != null) &#123; application.getSources().add(getClass()); &#125; Assert.state(!application.getSources().isEmpty(), &quot;No SpringApplication sources have been defined. Either override the &quot; + &quot;configure method or add an @Configuration annotation&quot;); // Ensure error pages are registered if (this.registerErrorPageFilter) &#123; application.getSources().add(ErrorPageFilterConfiguration.class); &#125; //启动Spring应用 return run(application);&#125; 7）、Spring 的应用就启动并且创建 IOC 容器 1234567891011121314151617181920212223242526272829303132333435public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try &#123; ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); Banner printedBanner = printBanner(environment); context = createApplicationContext(); analyzers = new FailureAnalyzers(context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新IOC容器 refreshContext(context); afterRefresh(context, applicationArguments); listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; ==启动 Servlet 容器，再启动 SpringBoot 应用== 五、Docker1、简介Docker是一个开源的应用容器引擎；是一个轻量级容器技术； Docker 支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像； 运行中的这个镜像称为容器，容器启动是非常快速的。 2、核心概念docker 主机(Host)：安装了 Docker 程序的机器（Docker 直接安装在操作系统之上）； docker 客户端(Client)：连接 docker 主机进行操作； docker 仓库(Registry)：用来保存各种打包好的软件镜像； docker 镜像(Images)：软件打包好的镜像；放在 docker 仓库中； docker 容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用 使用 Docker 的步骤： 1）、安装 Docker 2）、去 Docker 仓库找到这个软件对应的镜像； 3）、使用 Docker 运行这个镜像，这个镜像就会生成一个 Docker 容器； 4）、对容器的启动停止就是对软件的启动停止； 3、安装 Docker1）、安装 linux 虚拟机​ 1）、VMWare、VirtualBox（安装）； ​ 2）、导入虚拟机文件 centos7-atguigu.ova； ​ 3）、双击启动 linux 虚拟机;使用 root/ 123456 登陆 ​ 4）、使用客户端连接 linux 服务器进行命令操作； ​ 5）、设置虚拟机网络； ​ 桥接网络===选好网卡====接入网线； ​ 6）、设置好网络以后使用命令重启虚拟机的网络 1service network restart ​ 7）、查看 linux 的 ip 地址 1ip addr ​ 8）、使用客户端连接 linux； 2）、在 linux 虚拟机上安装 docker步骤： 12345678910111213141、检查内核版本，必须是3.10及以上uname -r2、安装dockeryum install docker3、输入y确认安装4、启动docker[root@localhost ~]# systemctl start docker[root@localhost ~]# docker -vDocker version 1.12.6, build 3e8e77d/1.12.65、开机启动docker[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.6、停止dockersystemctl stop docker 4、Docker 常用命令&amp;操作1）、镜像操作 操作 命令 说明 检索 docker search 关键字 eg：docker search redis 我们经常去 docker hub 上检索镜像的详细信息，如镜像的 TAG。 拉取 docker pull 镜像名:tag :tag 是可选的，tag 表示标签，多为软件的版本，默认是 latest 列表 docker images 查看所有本地镜像 删除 docker rmi image-id 删除指定的本地镜像 https://hub.docker.com/ 2）、容器操作软件镜像（QQ 安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的 QQ）； 步骤： 123456789101112131415161718192021222324252627282930311、搜索镜像[root@localhost ~]# docker search tomcat2、拉取镜像[root@localhost ~]# docker pull tomcat3、根据镜像启动容器docker run --name mytomcat -d tomcat:latest4、docker ps查看运行中的容器5、 停止运行中的容器docker stop 容器的id6、查看所有的容器docker ps -a7、启动容器docker start 容器id8、删除一个容器 docker rm 容器id9、启动一个做了端口映射的tomcat[root@localhost ~]# docker run -d -p 8888:8080 tomcat-d：后台运行-p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口10、为了演示简单关闭了linux的防火墙service firewalld status ；查看防火墙状态service firewalld stop：关闭防火墙11、查看容器的日志docker logs container-name/container-id更多命令参看https://docs.docker.com/engine/reference/commandline/docker/可以参考每一个镜像的文档 3）、安装 MySQL 示例1docker pull mysql 错误的启动 1234567891011121314151617[root@localhost ~]# docker run --name mysql01 -d mysql42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846mysql退出了[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES42f09819908b mysql &quot;docker-entrypoint.sh&quot; 34 seconds ago Exited (1) 33 seconds ago mysql01538bde63e500 tomcat &quot;catalina.sh run&quot; About an hour ago Exited (143) About an hour ago compassionate_goldstinec4f1ac60b3fc tomcat &quot;catalina.sh run&quot; About an hour ago Exited (143) About an hour ago lonely_fermi81ec743a5271 tomcat &quot;catalina.sh run&quot; About an hour ago Exited (143) About an hour ago sick_ramanujan//错误日志[root@localhost ~]# docker logs 42f09819908berror: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个 正确的启动 12345[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb874c56bec49 mysql &quot;docker-entrypoint.sh&quot; 4 seconds ago Up 3 seconds 3306/tcp mysql01 做了端口映射 12345[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESad10e4bc5c6a mysql &quot;docker-entrypoint.sh&quot; 4 seconds ago Up 2 seconds 0.0.0.0:3306-&gt;3306/tcp mysql02 几个其他的高级操作 123456docker run --name mysql03 -v &#x2F;conf&#x2F;mysql:&#x2F;etc&#x2F;mysql&#x2F;conf.d -e MYSQL_ROOT_PASSWORD&#x3D;my-secret-pw -d mysql:tag把主机的&#x2F;conf&#x2F;mysql文件夹挂载到 mysqldocker容器的&#x2F;etc&#x2F;mysql&#x2F;conf.d文件夹里面改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（&#x2F;conf&#x2F;mysql）docker run --name some-mysql -e MYSQL_ROOT_PASSWORD&#x3D;my-secret-pw -d mysql:tag --character-set-server&#x3D;utf8mb4 --collation-server&#x3D;utf8mb4_unicode_ci指定mysql的一些配置参数 六、SpringBoot 与数据访问1、JDBC123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 123456spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.15.22:3306/jdbc driver-class-name: com.mysql.jdbc.Driver 效果： ​ 默认是用 org.apache.tomcat.jdbc.pool.DataSource 作为数据源； ​ 数据源的相关配置都在 DataSourceProperties 里面； 自动配置原理： org.springframework.boot.autoconfigure.jdbc： 1、参考 DataSourceConfiguration，根据配置创建数据源，默认使用 Tomcat 连接池；可以使用 spring.datasource.type 指定自定义的数据源类型； 2、SpringBoot 默认可以支持； 1org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、 3、自定义数据源类型 1234567891011121314/** * Generic DataSource configuration. */@ConditionalOnMissingBean(DataSource.class)@ConditionalOnProperty(name = &quot;spring.datasource.type&quot;)static class Generic &#123; @Bean public DataSource dataSource(DataSourceProperties properties) &#123; //使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性 return properties.initializeDataSourceBuilder().build(); &#125;&#125; 4、DataSourceInitializer：ApplicationListener； ​ 作用： ​ 1）、runSchemaScripts();运行建表语句； ​ 2）、runDataScripts();运行插入数据的 sql 语句； 默认只需要将文件命名为： 123456schema-*.sql、data-*.sql默认规则：schema.sql，schema-all.sql；可以使用 schema: - classpath:department.sql 指定位置 5、操作数据库：自动配置了 JdbcTemplate 操作数据库 2、整合 Druid 数据源1234567891011121314151617181920212223242526272829303132333435363738394041424344导入druid数据源@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) @Bean public DataSource druid()&#123; return new DruidDataSource(); &#125; //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(&quot;loginUsername&quot;,&quot;admin&quot;); initParams.put(&quot;loginPassword&quot;,&quot;123456&quot;); initParams.put(&quot;allow&quot;,&quot;&quot;);//默认就是允许所有访问 initParams.put(&quot;deny&quot;,&quot;192.168.15.21&quot;); bean.setInitParameters(initParams); return bean; &#125; //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;)); return bean; &#125;&#125; 3、整合 MyBatis12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; 步骤： ​ 1）、配置数据源相关属性（见上一节 Druid） ​ 2）、给数据库建表 ​ 3）、创建 JavaBean 4）、注解版1234567891011121314151617//指定这是一个操作数据库的mapper@Mapperpublic interface DepartmentMapper &#123; @Select(&quot;select * from department where id=#&#123;id&#125;&quot;) public Department getDeptById(Integer id); @Delete(&quot;delete from department where id=#&#123;id&#125;&quot;) public int deleteDeptById(Integer id); @Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;) @Insert(&quot;insert into department(departmentName) values(#&#123;departmentName&#125;)&quot;) public int insertDept(Department department); @Update(&quot;update department set departmentName=#&#123;departmentName&#125; where id=#&#123;id&#125;&quot;) public int updateDept(Department department);&#125; 问题： 自定义 MyBatis 的配置规则；给容器中添加一个 ConfigurationCustomizer； 1234567891011121314@org.springframework.context.annotation.Configurationpublic class MyBatisConfig &#123; @Bean public ConfigurationCustomizer configurationCustomizer()&#123; return new ConfigurationCustomizer()&#123; @Override public void customize(Configuration configuration) &#123; configuration.setMapUnderscoreToCamelCase(true); &#125; &#125;; &#125;&#125; 123456789使用MapperScan批量扫描所有的Mapper接口；@MapperScan(value = &quot;com.atguigu.springboot.mapper&quot;)@SpringBootApplicationpublic class SpringBoot06DataMybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot06DataMybatisApplication.class, args); &#125;&#125; 5）、配置文件版123mybatis: config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置 mapper-locations: classpath:mybatis/mapper/*.xml 指定sql映射文件的位置 更多使用参照 http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/ 4、整合 SpringData JPA1）、SpringData 简介 2）、整合 SpringData JPAJPA:ORM（Object Relational Mapping）； 1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系； 12345678910111213//使用JPA注解配置映射关系@Entity //告诉JPA这是一个实体类（和数据表映射的类）@Table(name = &quot;tbl_user&quot;) //@Table来指定和哪个数据表对应;如果省略默认表名就是user；public class User &#123; @Id //这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键 private Integer id; @Column(name = &quot;last_name&quot;,length = 50) //这是和数据表对应的一个列 private String lastName; @Column //省略默认列名就是属性名 private String email; 2）、编写一个 Dao 接口来操作实体类对应的数据表（Repository） 1234//继承JpaRepository来完成对数据库的操作public interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;&#125; 3）、基本的配置 JpaProperties 1234567spring: jpa: hibernate: # 更新或者创建数据表结构 ddl-auto: update # 控制台显示SQL show-sql: true 七、启动配置原理几个重要的事件回调机制 配置在 META-INF/spring.factories ApplicationContextInitializer SpringApplicationRunListener 只需要放在 ioc 容器中 ApplicationRunner CommandLineRunner 启动流程： 1、创建 SpringApplication 对象12345678910111213141516initialize(sources);private void initialize(Object[] sources) &#123; //保存主配置类 if (sources != null &amp;&amp; sources.length &gt; 0) &#123; this.sources.addAll(Arrays.asList(sources)); &#125; //判断当前是否一个web应用 this.webEnvironment = deduceWebEnvironment(); //从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来 setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); //从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //从多个配置类中找到有main方法的主配置类 this.mainApplicationClass = deduceMainApplicationClass();&#125; 2、运行 run 方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); //获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories SpringApplicationRunListeners listeners = getRunListeners(args); //回调所有的获取SpringApplicationRunListener.starting()方法 listeners.starting(); try &#123; //封装命令行参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); //准备环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); //创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成 Banner printedBanner = printBanner(environment); //创建ApplicationContext；决定创建web的ioc还是普通的ioc context = createApplicationContext(); analyzers = new FailureAnalyzers(context); //准备上下文环境;将environment保存到ioc中；而且applyInitializers()； //applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法 //回调所有的SpringApplicationRunListener的contextPrepared()； // prepareContext(context, environment, listeners, applicationArguments, printedBanner); //prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）； //s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版 //扫描，创建，加载所有组件的地方；（配置类，组件，自动配置） refreshContext(context); //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调 //ApplicationRunner先回调，CommandLineRunner再回调 afterRefresh(context, applicationArguments); //所有的SpringApplicationRunListener回调finished方法 listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; //整个SpringBoot应用启动完成以后返回启动的ioc容器； return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; 3、事件监听机制配置在 META-INF/spring.factories ApplicationContextInitializer 1234567public class HelloApplicationContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; &#123; @Override public void initialize(ConfigurableApplicationContext applicationContext) &#123; System.out.println(&quot;ApplicationContextInitializer...initialize...&quot;+applicationContext); &#125;&#125; SpringApplicationRunListener 12345678910111213141516171819202122232425262728293031323334public class HelloSpringApplicationRunListener implements SpringApplicationRunListener &#123; //必须有的构造器 public HelloSpringApplicationRunListener(SpringApplication application, String[] args)&#123; &#125; @Override public void starting() &#123; System.out.println(&quot;SpringApplicationRunListener...starting...&quot;); &#125; @Override public void environmentPrepared(ConfigurableEnvironment environment) &#123; Object o = environment.getSystemProperties().get(&quot;os.name&quot;); System.out.println(&quot;SpringApplicationRunListener...environmentPrepared..&quot;+o); &#125; @Override public void contextPrepared(ConfigurableApplicationContext context) &#123; System.out.println(&quot;SpringApplicationRunListener...contextPrepared...&quot;); &#125; @Override public void contextLoaded(ConfigurableApplicationContext context) &#123; System.out.println(&quot;SpringApplicationRunListener...contextLoaded...&quot;); &#125; @Override public void finished(ConfigurableApplicationContext context, Throwable exception) &#123; System.out.println(&quot;SpringApplicationRunListener...finished...&quot;); &#125;&#125; 配置（META-INF/spring.factories） 12345org.springframework.context.ApplicationContextInitializer=\\com.atguigu.springboot.listener.HelloApplicationContextInitializerorg.springframework.boot.SpringApplicationRunListener=\\com.atguigu.springboot.listener.HelloSpringApplicationRunListener 只需要放在 ioc 容器中 ApplicationRunner 1234567@Componentpublic class HelloApplicationRunner implements ApplicationRunner &#123; @Override public void run(ApplicationArguments args) throws Exception &#123; System.out.println(&quot;ApplicationRunner...run....&quot;); &#125;&#125; CommandLineRunner 1234567@Componentpublic class HelloCommandLineRunner implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println(&quot;CommandLineRunner...run...&quot;+ Arrays.asList(args)); &#125;&#125; 八、自定义 starterstarter： ​ 1、这个场景需要使用到的依赖是什么？ ​ 2、如何编写自动配置 12345678910111213@Configuration //指定这个类是一个配置类@ConditionalOnXXX //在指定条件成立的情况下自动配置类生效@AutoConfigureAfter //指定自动配置类的顺序@Bean //给容器中添加组件@ConfigurationPropertie结合相关xxxProperties类来绑定相关的配置@EnableConfigurationProperties //让xxxProperties生效加入到容器中自动配置类要能加载将需要启动就加载的自动配置类，配置在META-INF/spring.factoriesorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\ ​ 3、模式： 启动器只用来做依赖导入； 专门来写一个自动配置模块； 启动器依赖自动配置；别人只需要引入启动器（starter） mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter 步骤： 1）、启动器模块 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--启动器--&gt; &lt;dependencies&gt; &lt;!--引入自动配置模块--&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2）、自动配置模块 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--引入spring-boot-starter；所有starter的基本配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 123456789101112131415161718192021222324252627package com.atguigu.starter;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(prefix = &quot;atguigu.hello&quot;)public class HelloProperties &#123; private String prefix; private String suffix; public String getPrefix() &#123; return prefix; &#125; public void setPrefix(String prefix) &#123; this.prefix = prefix; &#125; public String getSuffix() &#123; return suffix; &#125; public void setSuffix(String suffix) &#123; this.suffix = suffix; &#125;&#125; 12345678910111213141516171819package com.atguigu.starter;public class HelloService &#123; HelloProperties helloProperties; public HelloProperties getHelloProperties() &#123; return helloProperties; &#125; public void setHelloProperties(HelloProperties helloProperties) &#123; this.helloProperties = helloProperties; &#125; public String sayHellAtguigu(String name)&#123; return helloProperties.getPrefix()+&quot;-&quot; +name + helloProperties.getSuffix(); &#125;&#125; 1234567891011121314151617181920212223package com.atguigu.starter;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@ConditionalOnWebApplication //web应用才生效@EnableConfigurationProperties(HelloProperties.class)public class HelloServiceAutoConfiguration &#123; @Autowired HelloProperties helloProperties; @Bean public HelloService helloService()&#123; HelloService service = new HelloService(); service.setHelloProperties(helloProperties); return service; &#125;&#125; 更多 SpringBoot 整合示例https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples","categories":[{"name":"java","slug":"java","permalink":"https://supertramp7.github.io/categories/java/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://supertramp7.github.io/tags/mybatis/"},{"name":"java","slug":"java","permalink":"https://supertramp7.github.io/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"https://supertramp7.github.io/tags/springboot/"},{"name":"intellij IDEA","slug":"intellij-IDEA","permalink":"https://supertramp7.github.io/tags/intellij-IDEA/"},{"name":"maven","slug":"maven","permalink":"https://supertramp7.github.io/tags/maven/"},{"name":"jdk","slug":"jdk","permalink":"https://supertramp7.github.io/tags/jdk/"}]},{"title":"如何搭建一个自己的博客","slug":"personal_blog","date":"2021-02-16T16:00:00.000Z","updated":"2022-02-19T10:24:59.433Z","comments":true,"path":"personal_blog/","link":"","permalink":"https://supertramp7.github.io/personal_blog/","excerpt":"","text":"引言为什么要搭建自己的个人博客工作和学习过程中，我们经常遇到一些这样或那样的问题，此时我们可能会在网上找到相应的解决方法。但是过了一段时间之后，当我们再次碰到类似的问题时，早已忘记以前是怎么解决的了，于是又要到网上去搜，浪费大量的时间和精力。面对这些重复的问题，我们为什么不能把它们记录下来呢？ 在我看来，搭建自己的个人博客主要有以下好处： 有助于养成归纳总结的习惯，帮助记忆，把别人的知识变成自己的知识。 通过记录自己工作和生活，锻炼自己的写作的能力。 培养开放（开源）意识，与大家一起学习交流，共同进步。 搭建个人博客的多种选择目前，主流的博客主要分静态博客和动态博客两类： 所谓动态，就是指有前端有后端，可以登录到后台进行管理。静态博客是纯前端的展示，没有后端。 1. 动态博客搭建 1）直接在简书、CSDN（最近吐槽的比较多）、知乎、博客园等动态博客公共平台上写。 优点：简单 缺点：别人家的东西限制多 2）使用 WordPress 等成熟框架搭建动态博客 + 服务器部署 优点：相对简单 缺点：笨重 3）使用 Java、PHP、Python 等语言开发属于自己的动态博客 + 服务器部署 优点：功能强大 缺点：麻烦、不易上手 2. 静态博客搭建 1）使用 Hexo、Hugo、jekyll 等主流博客框架搭建静态博客 + 托管在 GitHub、码云等公共平台。 优点：轻量级、易上手、不花钱 缺点：访问速度慢 2）使用 Hexo、Hugo、jekyll 等主流博客框架搭建静态博客 + 云端服务器部署。 优点：有独立的域名、访问速度快、自主可控 缺点：要花钱买域名和云服务器 (我用的就是“Hexo+GitHub”这种方法，接下来详细地给大家介绍一下采用该方法搭建个人博客的原理和步骤。) 什么是 HexoHexo 可以理解为是基于 node.js 制作的一个博客工具。它是一个静态页面生成和上传的工具。 为什么选择 HexoHexo 在本地安装，不需要部署到我们的服务器上。我们只需要在本地通过 markdown 编写文章，然后让 Hexo 帮我们生成静态的 html 页面，并通过 Hexo 将生成的 html 文件上传到我们的服务器。 为什么选择托管在 GitHub 上托管在 github 上方便、不花钱 一、工作原理使用 Hexo 搭建个人博客并托管在 GitHub 的原理：简单来说就是在本地计算机搭建 Hexo 环境，Hexo 通过 generate 命令将*.md 文件渲染成静态的 html 页面，然后 Hexo 通过 deploy 命令触发 git 用户通过公钥免密登陆服务器，进而将静态页面推送到服务器的 git 仓库（repository）中。 二、搭建步骤在本地计算机安装 Hexo 环境1. 安装 Node.js去 Node.js 官网[2]下载 Windows (x64)长期支持版 Long Term Support (LTS) schedule。按提示逐步安装即可，安装完成后打开 cmd 查看版本号验证是否安装成功。 12C:\\Users\\11617&gt;node -vv12.14.1 Node.js 中自带了 npm 包管理工具，在 cmd 中查看 npm 版本。 12C:\\Users\\11617&gt;npm -v6.13.4 2. 安装 Gitgit 是一个版本控制工具，国外镜像下载巨慢，建议前往淘宝 Git for Windows 镜像下载 git 安装包。按提示逐步安装即可，安装完成后右键菜单中出现 Git Bash 和 Git GUI 菜单表明安装成功，如下图所示。 注：git 和 github 是两个东西。github 是基于 git 二次开发的，git 是 github 的核心，git 负责与 github 相关的所有本地工作。 3. 安装 Hexo在 F 盘新建 blog 文件夹用来存放个人博客，进入该文件夹，右键打开 Git Bash，使用 npm 安装 Hexo。 1$ npm install -g hexo-cli Hexo 安装完成后，在 blog 文件夹下新建 myblog 项目，并对其进行初始化。 12$ hexo init myblogl$ cd myblog 此时，会在 blog 文件夹下新建 myblog 文件夹，并在其内部生成相应的项目文件。如下图所示： 在 myblog 文件夹下启动 hexo 服务。 1$ hexo s 此时在本地打开浏览器，通过 http://localhost:4000/ 便可访问基于 Hexo 的个人博客主页了。如下图所示： 4. 我的第一篇文章在 myblog 文件夹下，右键打开 Git Bash，新建第一篇文章。 1$ hexo n &quot;我的第一篇博客文章&quot; 运行结果如下： 进入到 myblog/source/_posts/文件夹下。 123$ cd source&#x2F;_posts$ lshello-world.md 我的第一篇博客文章.md 打开“我的第一篇博客文章.md”并编辑保存。 重新退回到 myblog 文件夹下，清除缓存文件 db.json 和已生成的静态文件 public ，生成网站静态文件到默认设置的 public 文件夹，并重新启动 hexo。 1234$ cd ../..$ hexo clean$ hexo g$ hexo s 三、部署 GitHub将博客部署到 GitHub 上1. 登录 GitHub2. 新建仓库 —&gt; new repository 点击 Create repository，进入下一步。 3. 安装 git 插件1$ cnpm install --save hexo-deployer-git 4. 配置_config.yml 文件在 myblog 文件夹下打开_config.yml 文件并编辑保存。 1$ vim _config.yml 编辑如下： 保存退出后重新部署： 1$ hexo d 输入 github 账号、密码后刷新 GitHub 就可以看到博客。 5. 访问博客我的博客 四、更换主题yilila 主题1. 下载主题在 myblog 文件夹下，右键打开 Git Bash，下载主题到 themes 下的 yilia 文件夹下。 1$ git clone https://github.com/litten/hexo-theme-yilia.git themes yilia 2. 配置主题打开_config.yml 修改主题并保存。 3. 成功使用1234$ hexo clean$ hexo g$ hexo s$ hexo d 4. 优化Hexo yilia 主题一揽子优化方案 butterfly 主题1. 下载主题1git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly 2. 配置主题_config.yml 中 1theme：butterfly 3. 安装插件如果没有 pug 以及 stylus 的渲染器，请下载安装： 1npm install hexo-renderer-pug hexo-renderer-stylus --save ERROR1执行命令：git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 出现错误：fatal: unable to access &#39;https://github.com/litten/hexo-theme-yilia.git/&#39;: OpenSSL SSL_read: Connection was reset, errno 10054 原因：因为 git 在拉取或者提交项目时，中间会有 git 的 http 和 https 代理，但是我们本地环境本身就有 SSL 协议了，所以取消 git 的 https 代理即可，不行再取消 http 的代理。 解决方案：取消 git 本身的 https 代理，使用自己本机的代理，如果没有的话，其实默认还是用 git 的。 12345// 取消http代理git config --global --unset http.proxy// 取消https代理git config --global --unset https.proxy ERROR2执行代码：hexo d 出现错误：Logon failed, use ctrl+c to cancel basic credential prompt.remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead. 原因：自从 21 年 8 月 13 后不再支持用户名密码的方式验证了，需要创建个人访问令牌(personal access token)。 解决方案： 1.生成令牌 1）登录 GitHub 官网，点击 Settings 2）点击左侧 Developer settings 3）点击左侧 Personal access tokens 4）点击 Generate new token 5）填写 token 信息 6）点击 Generate token，生成令牌 2.应用令牌 首次推送提示 输入的的 2 次用户名密码，第一次是输入github的登陆用户名和密码；第二次是输入上面截图操作步骤最终填写的 Note（用户名） 和生成的 tokens（密码） ERROR3出现错误：hexo 博客在 yilia 主题下不显示作者名字解决方案：yilia 需要在主题下的_config.yml 加入 author: ,不在 menu:下","categories":[{"name":"博客","slug":"博客","permalink":"https://supertramp7.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://supertramp7.github.io/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"https://supertramp7.github.io/tags/blog/"},{"name":"github","slug":"github","permalink":"https://supertramp7.github.io/tags/github/"},{"name":"butterfly","slug":"butterfly","permalink":"https://supertramp7.github.io/tags/butterfly/"},{"name":"yilia","slug":"yilia","permalink":"https://supertramp7.github.io/tags/yilia/"}]}],"categories":[{"name":"java","slug":"java","permalink":"https://supertramp7.github.io/categories/java/"},{"name":"博客","slug":"博客","permalink":"https://supertramp7.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://supertramp7.github.io/tags/mybatis/"},{"name":"java","slug":"java","permalink":"https://supertramp7.github.io/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"https://supertramp7.github.io/tags/springboot/"},{"name":"intellij IDEA","slug":"intellij-IDEA","permalink":"https://supertramp7.github.io/tags/intellij-IDEA/"},{"name":"maven","slug":"maven","permalink":"https://supertramp7.github.io/tags/maven/"},{"name":"jdk","slug":"jdk","permalink":"https://supertramp7.github.io/tags/jdk/"},{"name":"hexo","slug":"hexo","permalink":"https://supertramp7.github.io/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"https://supertramp7.github.io/tags/blog/"},{"name":"github","slug":"github","permalink":"https://supertramp7.github.io/tags/github/"},{"name":"butterfly","slug":"butterfly","permalink":"https://supertramp7.github.io/tags/butterfly/"},{"name":"yilia","slug":"yilia","permalink":"https://supertramp7.github.io/tags/yilia/"}]}